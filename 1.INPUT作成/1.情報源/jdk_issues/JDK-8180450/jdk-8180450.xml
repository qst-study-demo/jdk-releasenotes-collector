<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Sat Sep 27 10:07:17 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8180450] secondary_super_cache does not scale well</title>
                <link>https://bugs.openjdk.org/browse/JDK-8180450</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>On some workloads, updates to the Klass::secondary_super_cache field&lt;br/&gt;
cause excessive cache line invalidation traffic, with noticeable slowdowns.&lt;br/&gt;
&lt;br/&gt;
Specifically, the cache itself may become unstable (which is a normal corner case for one-element caches) and at that point a multi-threaded application may begin &amp;quot;hammering&amp;quot; on the cache line from multiple threads, causing an explosion of coherence traffic.&lt;br/&gt;
&lt;br/&gt;
One customer reported this as happening when multiple threads were traversing heterogeneous sequences of objects, testing the same classes against more than one interface, with rapid variation between the interfaces.  &lt;br/&gt;
&lt;br/&gt;
In such a case, two interfaces could compete to use the single SSC slot on each class that occurs in the object sequence.  The competition would turn into frequent updating of the SSC slots by multiple threads, causing cache lines to ping-pong between processors.&lt;br/&gt;
&lt;br/&gt;
To fix this, the SSC has to have some sort of limit on its update rate, or be replaced by a mechanism that scales better.&lt;br/&gt;
&lt;br/&gt;
The simplest fix is probably to put an &amp;quot;update count&amp;quot; profile counter somewhere, and consult that counter just before updating the SSC.  If the counter is too high (evidence of a high contention rate), don&amp;#39;t update the SSC.  The trade-off is between linear searches of the Klass::secondary_supers array (which is stable and therefore replicated across caches) versus time spent waiting to acquire write access to the SSC (which may be hundreds of cycles).  Linear search will easily win in those cases, except of course for very dense dynamic query mixes over very complex interface graphs, which is a corner case we can leave for the future.&lt;br/&gt;
&lt;br/&gt;
The obvious place to put the update count is next to the SSC, on the same cache line.  When the miss count overflows past some selected threshold, the SSC is left unchanged.  On balance the extra footprint of a 32-bit field per Klass seems acceptable.&lt;br/&gt;
&lt;br/&gt;
Such a counter should be allowed to decay, so that temporary bursts in type test complexity do not shut down the SSC forever.&lt;br/&gt;
&lt;br/&gt;
Another possible fix would be a thread-local update counter for the SSC, under JavaThread::current.  In that case, only Java code could use the extra fix to avoid cache contention, but that is probably acceptable also.  This fix would be significantly more complex, but would have the benefit that only &amp;quot;offending&amp;quot; threads would throttle themselves.&lt;br/&gt;
&lt;br/&gt;
Similarly, the counter could be placed in the MethodData object which carries the profile of the instruction which is causing the SSC contention.  (This instruction could be instanceof, checkcast, aastore, or a call to an intrinsic method that emulates one of those.)  This fix would be even more complex than the thread-based fix, and would probably be overkill given the relatively small importance of the problem.&lt;br/&gt;
&lt;br/&gt;
If the secondary_supers lists ever grow in length to more than a few tens of elements, additional mechanisms may be needed for quickly testing the subtype relation.  Probably a tree walk would be sufficient.  Sometimes unified caches (global or thread-local) are proposed, or perhaps unified numbering schemes, but those, also, seem overkill for this problem.</description>
                <environment></environment>
        <key id="4929227">JDK-8180450</key>
            <summary>secondary_super_cache does not scale well</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="aph">Andrew Haley</assignee>
                                    <reporter username="jrose">John Rose</reporter>
                        <labels>
                            <label>amazon-interest</label>
                            <label>hs-comp-triaged</label>
                            <label>jdk21</label>
                            <label>jdk21-defer-request</label>
                            <label>jdk21-defer-yes</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>oracle-triage-14</label>
                            <label>performance</label>
                    </labels>
                <created>Tue, 16 May 2017 14:47:19 -0700</created>
                <updated>Tue, 27 May 2025 11:13:21 -0700</updated>
                            <resolved>Tue, 16 Apr 2024 07:24:32 -0700</resolved>
                                    <version>9</version>
                    <version>10</version>
                    <version>11</version>
                    <version>12</version>
                    <version>13</version>
                    <version>17</version>
                    <version>20</version>
                    <version>21</version>
                    <version>22</version>
                                    <fixVersion>23</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>4</votes>
                                    <watches>37</watches>
                                                                                                                <comments>
                            <comment id="14750220" author="sgehwolf" created="Fri, 7 Feb 2025 02:39:37 -0800"  >Further backport clarification:&lt;br/&gt;
&lt;br/&gt;
This bug addresses x86_64 and aarch64. Other ports for Linux are in &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8331117&quot; title=&quot;[PPC64] secondary_super_cache does not scale well&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8331117&quot;&gt;&lt;strike&gt;JDK-8331117&lt;/strike&gt;&lt;/a&gt; (ppc64) and &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8331126&quot; title=&quot;[s390x] secondary_super_cache does not scale well&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8331126&quot;&gt;&lt;strike&gt;JDK-8331126&lt;/strike&gt;&lt;/a&gt; (s390x).</comment>
                            <comment id="14750204" author="sgehwolf" created="Fri, 7 Feb 2025 01:59:42 -0800"  >Backporting considerations for JDK 21u (comment from Andrew Haley on the 21u PR):&lt;br/&gt;
&lt;br/&gt;
A later bug, &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8344355&quot; title=&quot;Register corruption in MacroAssembler::lookup_secondary_supers_table_var: x86-64 only&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8344355&quot;&gt;&lt;strike&gt;JDK-8344355&lt;/strike&gt;&lt;/a&gt;, does not apply to the JDK 21u backport of this bug. The bug &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8344355&quot; title=&quot;Register corruption in MacroAssembler::lookup_secondary_supers_table_var: x86-64 only&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8344355&quot;&gt;&lt;strike&gt;JDK-8344355&lt;/strike&gt;&lt;/a&gt; fixed was caused by &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8331341&quot; title=&quot;secondary_super_cache does not scale well: C1 and interpreter&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8331341&quot;&gt;&lt;strike&gt;JDK-8331341&lt;/strike&gt;&lt;/a&gt;: secondary_super_cache does not scale well: C1 and interpreter. &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8331341&quot; title=&quot;secondary_super_cache does not scale well: C1 and interpreter&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8331341&quot;&gt;&lt;strike&gt;JDK-8331341&lt;/strike&gt;&lt;/a&gt; is not included here, and I have no intention of ever backporting it.</comment>
                            <comment id="14731127" author="roboduke" created="Wed, 11 Dec 2024 09:42:19 -0800"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/1090&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/1090&lt;/a&gt;&lt;br/&gt;
Date: 2024-10-24 10:10:45 +0000</comment>
                            <comment id="14728368" author="coleenp" created="Wed, 4 Dec 2024 06:06:14 -0800"  >It doesn&amp;#39;t look like any code sets the secondary_super_cache field anymore, but it&amp;#39;s still referred to in the code in UseSecondarySupersCache.  Should this be removed and cleaned up?  Does graal use it?&lt;br/&gt;
&lt;br/&gt;
$ grep -r _secondary_super_cache&lt;br/&gt;
share/jvmci/vmStructs_jvmci.cpp:  nonstatic_field(Klass,                       _secondary_super_cache,                        Klass*)                                \&lt;br/&gt;
share/oops/klass.hpp:  // The fields _super_check_offset, _secondary_super_cache, _secondary_supers&lt;br/&gt;
share/oops/klass.hpp:  // Where to look to observe a supertype (it is &amp;amp;_secondary_super_cache for&lt;br/&gt;
share/oops/klass.hpp:  Klass*      _secondary_super_cache;&lt;br/&gt;
share/oops/klass.hpp:  Klass* secondary_super_cache() const     { return _secondary_super_cache; }&lt;br/&gt;
share/oops/klass.hpp:  void set_secondary_super_cache(Klass* k) { _secondary_super_cache = k; }&lt;br/&gt;
share/oops/klass.hpp:  static ByteSize secondary_super_cache_offset() { return byte_offset_of(Klass, _secondary_super_cache); }&lt;br/&gt;
share/oops/klass.cpp:      super_check_cell = &amp;amp;_secondary_super_cache;&lt;br/&gt;
share/oops/klass.cpp:  // _secondary_super_cache may be updated by an is_subtype_of() call&lt;br/&gt;
share/oops/klass.cpp:  set_secondary_super_cache(nullptr);&lt;br/&gt;
share/opto/memnode.cpp:    // Treat Klass::_secondary_super_cache as a constant when the cache is disabled.&lt;br/&gt;
share/runtime/vmStructs.cpp:  nonstatic_field(Klass,                       _secondary_super_cache,                        Klass*)                                \&lt;br/&gt;
&lt;br/&gt;
Edit: I see, it is still set places in the generated code.  Bad grep.</comment>
                            <comment id="14667985" author="roboduke" created="Thu, 25 Apr 2024 06:46:17 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk22u/pull/166&quot;&gt;https://git.openjdk.org/jdk22u/pull/166&lt;/a&gt;&lt;br/&gt;
Date: 2024-04-25 13:38:56 +0000</comment>
                            <comment id="14665631" author="dukebot" created="Tue, 16 Apr 2024 07:24:31 -0700"  >Changeset: f11a496d&lt;br/&gt;
Author:    Andrew Haley &amp;lt;&lt;a href=&apos;mailto:aph@openjdk.org&apos;&gt;aph@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2024-04-16 14:21:48 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/f11a496de61d800a680517457eb43b078a633953&quot;&gt;https://git.openjdk.org/jdk/commit/f11a496de61d800a680517457eb43b078a633953&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14657516" author="roboduke" created="Thu, 14 Mar 2024 11:55:46 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/18309&quot;&gt;https://git.openjdk.org/jdk/pull/18309&lt;/a&gt;&lt;br/&gt;
Date: 2024-03-14 18:24:11 +0000</comment>
                            <comment id="14625243" author="thartmann" created="Thu, 9 Nov 2023 06:19:54 -0800"  >Setting this to tbd in favor of &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8316180&quot; title=&quot;Thread-local backoff for secondary_super_cache updates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8316180&quot;&gt;&lt;strike&gt;JDK-8316180&lt;/strike&gt;&lt;/a&gt; .</comment>
                            <comment id="14611299" author="JIRAUSER20308" created="Thu, 14 Sep 2023 12:14:12 -0700"  >Out of curiosity, does there exist (or could there exist) a write mode that is _weaker_ than plain on Intel or other CPUs? Something that might (for example) write the value to the local L1 cache but without directly causing an eventual subsequent write to other cache levels or main memory (or perhaps doing so only if it can be determined that the cost would be low or none)?&lt;br/&gt;
&lt;br/&gt;
Such a mode could hypothetically have many of the advantages of all of these options put together, with few of the drawbacks.</comment>
                            <comment id="14611250" author="drwhite" created="Thu, 14 Sep 2023 09:13:09 -0700"  >That sounds reasonable Aleksey. We&amp;#39;re converting the benchmark to JMH form, but will post it soon (then PR)</comment>
                            <comment id="14611132" author="shade" created="Thu, 14 Sep 2023 02:19:40 -0700"  >Hi Derek! Excellent news, thanks! Would you mind sharing the benchmark somewhere?&lt;br/&gt;
&lt;br/&gt;
I think we are still talking about stop-gap mitigation strategies, not the Real Fix (tm), right? If so, simplicity is a virtue. For backportable fix for production use, I would be concerned to never updating the cache after first install (#3), since we can get unlucky with polluting the cache with unlucky value during the startup phase. Never updating the cache (#2) also looks risky for prod use, as we penalize even the uncontended case; and we would not know the impact until we tried it in prod. This feels unsatisfactory for mitigating fix.&lt;br/&gt;
&lt;br/&gt;
The better strategy looks like something that would converge to most frequent cached value eventually, which leaves us #4.&lt;br/&gt;
&lt;br/&gt;
#4A is basically &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8316180&quot; title=&quot;Thread-local backoff for secondary_super_cache updates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8316180&quot;&gt;&lt;strike&gt;JDK-8316180&lt;/strike&gt;&lt;/a&gt;. I don&amp;#39;t think the backoff counter per Java thread is a big deal footprint-wise. That counter can be made more generic, to cover other contended caches, if any. (I actually had &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8316180&quot; title=&quot;Thread-local backoff for secondary_super_cache updates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8316180&quot;&gt;&lt;strike&gt;JDK-8316180&lt;/strike&gt;&lt;/a&gt; code handy from my compilation counters contention work I did in background.) The statistical drawback I see with #4A is that we might have sampling problems if we get the &amp;quot;bad&amp;quot; class exactly each N lookups, and only install that one.&lt;br/&gt;
&lt;br/&gt;
#4B mitigates the sampling problem with #4A, but it becomes architecture-specific, relying on platform providing fast unprivileged access to TSC-like counters. Unless we want to accept the VM call to `os::nanotime()`, which I think we don&amp;#39;t. Not sure how much of the additional latency TSC read would bring; it feels odd to add more latency on can-update-cache checking path than we have for linear scans. The experiments with #4A seem to show that cost of scan on trivial contending code is a handful of nanoseconds.&lt;br/&gt;
&lt;br/&gt;
Nerd-snipy idea: I wonder if we can combine #4A and #4B by fuzzing the counter in #4A using &amp;quot;random&amp;quot; counter from #4B. This saves latency on fast-slow-path, and accept TSC latency on slow-slow-path. But maybe #4A is already good on its own, especially provided its simplicity.&lt;br/&gt;
&lt;br/&gt;
So, my proposal would be to go with &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8316180&quot; title=&quot;Thread-local backoff for secondary_super_cache updates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8316180&quot;&gt;&lt;strike&gt;JDK-8316180&lt;/strike&gt;&lt;/a&gt;, implement more architectures, fold Derek benchmarks there, figure out the sensible backoff using Derek&amp;#39;s benchmarks, deploy that fix as stop-gap mitigation. Once work on the Real Fix (tm) restarts here, we would have the benchmarks already ready to go, and there would be a more aggressive baseline that the fix would need to win against to justify its (probably higher) complexity.&lt;br/&gt;
&lt;br/&gt;
What do you think, Derek?</comment>
                            <comment id="14611008" author="drwhite" created="Wed, 13 Sep 2023 13:58:36 -0700"  >Thanks for looking at this Aleksey!&lt;br/&gt;
&lt;br/&gt;
There are a few solutions to this problem:&lt;br/&gt;
1: Keep current secondary supercache code.&lt;br/&gt;
2: Never write to secondary supercache.&lt;br/&gt;
3: Only write to the secondary supercache once.&lt;br/&gt;
4: Only write to the secondary supercache sometimes.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;A) By keeping a thread-local counter as suggested by Aleksey - at the cost of a thread local.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;B) By sampling some bits of the core&amp;#39;s cycle counter (AKA a psuedo-random number) and write only if &amp;quot;&amp;lt; X&amp;quot;. Maybe at the cost of a little more code.&lt;br/&gt;
...&lt;br/&gt;
&lt;br/&gt;
We&amp;#39;ve also been working on an &amp;quot;instanceof&amp;quot; benchmark that scales:&lt;br/&gt;
&amp;nbsp;- Number of threads&lt;br/&gt;
&amp;nbsp;- Ratio of reads/writes of the secondary supercache&lt;br/&gt;
&amp;nbsp;- Length of the interface list&lt;br/&gt;
&lt;br/&gt;
We have compared running with enabled and disabled secondary supercache (#1 vs #2). We don&amp;#39;t have everything rolled up, but some interesting observations are:&lt;br/&gt;
&amp;nbsp;- With only 1 thread, the secondary supercache wins in all other scenarios.&lt;br/&gt;
- If the secondary supercache is updated even 5% of the time, disabling the secondary supercache wins (with more than a few threads and &amp;quot;normal&amp;quot; interface list lengths). E.g., if the secondary supercache is never updated beyond the first time, the secondary supercache wins, other it quickly starts loosing...&lt;br/&gt;
- The interface length has to be really long (100+ of interfaces) to make the secondary supercache win if there is even a moderate amount of contention.&lt;br/&gt;
&lt;br/&gt;
So this is pointing me to a simpler fix #3 - only update the secondary supercache the first time (when NULL), with a backup choice for #4B if we don&amp;#39;t want to use up a thread-local for every software cache that&amp;#39;s doesn&amp;#39;t scale.&lt;br/&gt;
&lt;br/&gt;
Note that in this benchmark, the interface array is being hit heavily, so tends to be cached. In a &amp;quot;real application&amp;quot; this might fall out of cache. but on the other hand if the array is long it&amp;#39;s easily HW prefetchable. Also, in a &amp;quot;real app&amp;quot; there would be other code running between calls to instance of, but there would still be cache-line contention between cores that impact memory latencies. So it would be a car crash in slow motion, but still a (performance) crash.</comment>
                            <comment id="14610961" author="vlivanov" created="Wed, 13 Sep 2023 09:25:58 -0700"  >The fix proposed in &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8316180&quot; title=&quot;Thread-local backoff for secondary_super_cache updates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8316180&quot;&gt;&lt;strike&gt;JDK-8316180&lt;/strike&gt;&lt;/a&gt; does look promising as a stop-the-gap solution for the scalability issue.</comment>
                            <comment id="14610907" author="shade" created="Wed, 13 Sep 2023 07:04:47 -0700"  >Derek, have you had any success with this? I think as the stop-gap we can do TLR counters, like &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8316180&quot; title=&quot;Thread-local backoff for secondary_super_cache updates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8316180&quot;&gt;&lt;strike&gt;JDK-8316180&lt;/strike&gt;&lt;/a&gt;. &lt;br/&gt;
It seems to considerably alleviate the problems on very contended cases with just a little bit of backoff.</comment>
                            <comment id="14592718" author="thartmann" created="Thu, 29 Jun 2023 04:40:56 -0700"  >Deferral Request (JDK 21):&lt;br/&gt;
We are running out of time for JDK 21 and the complexity / risk of a full fix is high.&lt;br/&gt;
&lt;br/&gt;
[~drwhite] if you have a simple stop-the-gap solution for JDK 21, feel free to propose that for review/discussion.</comment>
                            <comment id="14584283" author="drwhite" created="Wed, 24 May 2023 19:57:25 -0700"  >We wanted to reverify that the secondary supercache provides a benefit on modern HW before trying to patch it. We went back to the original &amp;quot;Fast subtype checking in the HotSpot JVM&amp;quot; paper by Cliff Click and John Rose [1] and are trying to reproduce their results that motivated the optimization. BTW, SPECjbb 2000 and SPECjvm98 are showing their age :-)&lt;br/&gt;
&lt;br/&gt;
We&amp;#39;re still making sure that we are scaling the benchmark properly, but some early results point to the optimization not scaling much earlier than I expected, compared to not updating the cache at all. If that holds true there may be an even simpler patch :-)&lt;br/&gt;
&lt;br/&gt;
[1] &lt;a href=&quot;https://www.researchgate.net/publication/221552851_Fast_subtype_checking_in_the_HotSpot_JVM&quot;&gt;https://www.researchgate.net/publication/221552851_Fast_subtype_checking_in_the_HotSpot_JVM&lt;/a&gt;</comment>
                            <comment id="14584106" author="JIRAUSER20308" created="Wed, 24 May 2023 06:42:54 -0700"  >Thank you for your efforts on this issue. I&amp;#39;m wondering, did the simple scheme ever bear fruit, or is it still too early to tell?</comment>
                            <comment id="14575463" author="drwhite" created="Thu, 20 Apr 2023 09:50:45 -0700"  >Thanks Vladimir, we&amp;#39;ll take a stab at a fix and see where it&amp;#39;s appropriate to use.</comment>
                            <comment id="14574792" author="vlivanov" created="Tue, 18 Apr 2023 11:58:13 -0700"  >Hi Derek [~drwhite],&lt;br/&gt;
&lt;br/&gt;
The current plan to address the issue in 21 is to replace linear search over secondary_supers array with a faster lookup implementation which would make secondary_super_cache obsolete.&lt;br/&gt;
&lt;br/&gt;
If you have a simple stop-the-gap solution, please, share the details (or post it for review). Speaking of backports, I would be much more comfortable with a straightforward change to mitigate the scalability issue rather than bringing in a complete rewrite.</comment>
                            <comment id="14573900" author="drwhite" created="Fri, 14 Apr 2023 11:38:02 -0700"  >Hi John, Vladimir,&lt;br/&gt;
&lt;br/&gt;
How likely is it that a fix for this will get in to JDK 21?&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m quite anxious to get something in soon, even if it&amp;#39;s an interim fix. &lt;br/&gt;
&lt;br/&gt;
Our kernel folks suggested a really simple scheme that we&amp;#39;d be happy to put out for review soon, but if you&amp;#39;ve already working on a more global fix for JDK 21 that&amp;#39;s fine.</comment>
                            <comment id="14537760" author="sgrinovero" created="Tue, 15 Nov 2022 10:28:41 -0800"  >Many thanks ~thartmann, glad to hear! We can help with performance tests.</comment>
                            <comment id="14537753" author="thartmann" created="Tue, 15 Nov 2022 10:16:25 -0800"  >Raising priority due to recent reports.</comment>
                            <comment id="14536886" author="sgrinovero" created="Mon, 14 Nov 2022 05:35:26 -0800"  >I&amp;#39;ll add some references to our work in Red Hat since there&amp;#39;s a revival of interest; it was surprising for us to see the Netflix blog being published, apparently independently, while we were tinkering with the same problem.&lt;br/&gt;
&lt;br/&gt;
Past summer we noticed some suspicious performance results in one of our Quarkus performance benchmarks; we&amp;#39;ve been plagued with poor reproducibility of results: strong variability, especially on machines with many CPUs. These were dedicated &amp;quot;performance lab&amp;quot; servers, configured by experts for the very purpose of producing reliable, reproducible performance figures.&lt;br/&gt;
&lt;br/&gt;
We had also noticed a very high impact on total performance depending on the warmup patterns being used, and overall we were concerned that we were far from the theoretical performance results we were expecting from this simple code; confirmed by achieving significantly higher figures by writing code in different languages not running on the JVM.&lt;br/&gt;
&lt;br/&gt;
After a brilliant deep-dive investigation by Francesco Nigro (Red Hat middleware performance team) and with the help of Andrew Haley and Andrew Dinn (Red Hat OpenJDK team) they figured out that we were affected by this particular issue, to an extent of having a very significant impact.&lt;br/&gt;
&lt;br/&gt;
Francesco created an agent to help people like me, maintainers of Java OSS libraries, to identify code patterns which were triggering the issue. The agent is available here:&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/RedHatPerf/type-pollution-agent&quot;&gt;https://github.com/RedHatPerf/type-pollution-agent&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
We&amp;#39;re now using this agent in the community to identify and prioritize patches on a number of popular open source libraries; we&amp;#39;re well aware that fixing this JDK issue is preferrable but we&amp;#39;re doing this to get a better grasp on the impact; the intention being to provide more data here as soon as we can converge all those patches to different projects.&lt;br/&gt;
&lt;br/&gt;
A sample of these patches might be useful:&lt;br/&gt;
&lt;br/&gt;
Hibernate ORM:&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/hibernate/hibernate-orm/pull/5444&quot;&gt;https://github.com/hibernate/hibernate-orm/pull/5444&lt;/a&gt;&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/hibernate/hibernate-orm/pull/5483&quot;&gt;https://github.com/hibernate/hibernate-orm/pull/5483&lt;/a&gt;&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/hibernate/hibernate-orm/pull/5502&quot;&gt;https://github.com/hibernate/hibernate-orm/pull/5502&lt;/a&gt;&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/hibernate/hibernate-orm/pull/5527&quot;&gt;https://github.com/hibernate/hibernate-orm/pull/5527&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Hibernate Reactive:&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/hibernate/hibernate-reactive/pull/1400&quot;&gt;https://github.com/hibernate/hibernate-reactive/pull/1400&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Smallrye Mutiny:&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/smallrye/smallrye-mutiny/pull/1081&quot;&gt;https://github.com/smallrye/smallrye-mutiny/pull/1081&lt;/a&gt;&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/smallrye/smallrye-mutiny/pull/1113&quot;&gt;https://github.com/smallrye/smallrye-mutiny/pull/1113&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Smallrye Common:&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/smallrye/smallrye-common/pull/190&quot;&gt;https://github.com/smallrye/smallrye-common/pull/190&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Vert.x:&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/eclipse-vertx/vert.x/pull/4520&quot;&gt;https://github.com/eclipse-vertx/vert.x/pull/4520&lt;/a&gt;&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/eclipse-vertx/vert.x/pull/4525&quot;&gt;https://github.com/eclipse-vertx/vert.x/pull/4525&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Vert.x Web:&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/vert-x3/vertx-web/pull/2289&quot;&gt;https://github.com/vert-x3/vertx-web/pull/2289&lt;/a&gt;&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/eclipse-vertx/vert.x/pull/4525&quot;&gt;https://github.com/eclipse-vertx/vert.x/pull/4525&lt;/a&gt;]&lt;br/&gt;
&lt;br/&gt;
Netty:&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/netty/netty/pull/12709&quot;&gt;https://github.com/netty/netty/pull/12709&lt;/a&gt;&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/netty/netty/pull/12806&quot;&gt;https://github.com/netty/netty/pull/12806&lt;/a&gt;&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/netty/netty/pull/12980&quot;&gt;https://github.com/netty/netty/pull/12980&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Quarkus:&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/quarkusio/quarkus/pull/29044&quot;&gt;https://github.com/quarkusio/quarkus/pull/29044&lt;/a&gt;&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/quarkusio/quarkus/pull/28985&quot;&gt;https://github.com/quarkusio/quarkus/pull/28985&lt;/a&gt;&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/quarkusio/quarkus/pull/29109&quot;&gt;https://github.com/quarkusio/quarkus/pull/29109&lt;/a&gt;&lt;br/&gt;
&amp;nbsp;- &lt;a href=&quot;https://github.com/quarkusio/quarkus/pull/29136&quot;&gt;https://github.com/quarkusio/quarkus/pull/29136&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
These patches to our projects are not something to be proud of: it doesn&amp;#39;t look like clean Java code, certainly not easy to maintain. Hopefully these won&amp;#39;t be needed for long, and while we don&amp;#39;t have final figures yet the preliminary tests are looking extremely promising.&lt;br/&gt;
&lt;br/&gt;
N.B. the agent is prone to report false positives; we&amp;#39;re still learning how to best distinguish a real problem from an apparent one, so it&amp;#39;s possible that some of these patches are actually unnecessary. Our plan is to verify things via hard performance numbers, but having many cases identified it&amp;#39;s become unpractical to test each patch individually (although we did so on some of them).</comment>
                            <comment id="14536675" author="eosterlund" created="Fri, 11 Nov 2022 08:13:51 -0800"  >I should mention that for my new invoke bindings code, I have a prototype where each type gets a &amp;quot;selector&amp;quot;; a randomly unified yet unique number. Each class had a cuckoo style hash table for its super types. For a type check operation, I would check first in the primary bucket, and then the secondary bucket. They are immutable after creation. Very quick lookup times, and no contention. Might be interesting to try out.</comment>
                            <comment id="14536338" author="simonis" created="Thu, 10 Nov 2022 07:53:25 -0800"  >Yet another incarnation of this problem: &lt;a href=&quot;https://netflixtechblog.com/seeing-through-hardware-counters-a-journey-to-threefold-performance-increase-2721924a2822&quot;&gt;https://netflixtechblog.com/seeing-through-hardware-counters-a-journey-to-threefold-performance-increase-2721924a2822&lt;/a&gt;</comment>
                            <comment id="14534269" author="drwhite" created="Wed, 2 Nov 2022 16:01:31 -0700"  >I&amp;#39;d like to add three thoughts:&lt;br/&gt;
&lt;br/&gt;
1) This is way more common than the initial priority rating is suggesting. We (Intel) have seen several customers hit this issue, RedHat/Quarkus put out a nice video describing the problem (&lt;a href=&quot;https://youtu.be/G40VfIsnCdo&quot;&gt;https://youtu.be/G40VfIsnCdo&lt;/a&gt;) and there are multiple cases of patches to major libraries essentially fleeing from instanceOf and checkCast usages (it seems like daily!).&lt;br/&gt;
&lt;br/&gt;
2) There is also a false sharing issue between _secondary_super_cache and _secondary_supers (and possibly _primary_supers). At the least a quick fix to pad _secondary_super_cache to avoid false sharing will help.&lt;br/&gt;
&lt;br/&gt;
3) One potential fix occurred as I wrote this, so no code or perf data:&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
Basic idea: Don&amp;#39;t update the _secondary_super_cache after a search if we detect that the _secondary_super_cache changed while we searched. This will start throttling updates at extreme contention.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Klass* orig_value = _secondary_super_cache;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (search_secondary_supers(k)) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SemiAtomic::cmpxchg(&amp;amp;_secondary_super_cache, orig_value, k);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;quot;SemiAtomic&amp;quot;, because we need the effect of cmpxchg, but don&amp;#39;t need the atomicity. Testing is needed to see if Atomic::cmpxchg is OK, or if a non atomic sequence of &amp;quot;load, cmp, bne, store&amp;quot; performs better. &lt;br/&gt;
&lt;br/&gt;
A variation is to poison the _secondary_super_cache if we EVER see a failure in the &amp;quot;cmpxchg&amp;quot;, because the &amp;quot;cmpxchg&amp;quot; may not fail enough if the first load of _secondary_super_cache is slower than the search_secondary_supers().&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Klass* orig_value = _secondary_super_cache;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (search_secondary_supers(k)) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (orig_value != POISON) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!SemiAtomic::cmpxchg(&amp;amp;_secondary_super_cache, orig_value, k)) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_secondary_super_cache = POISON;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
Or maybe the &amp;quot;cmpxchg&amp;quot; never fails and we need something else. I&amp;#39;m happy to hear any thoughts on this or other approaches...</comment>
                            <comment id="14534126" author="simonis" created="Wed, 2 Nov 2022 06:43:17 -0700"  >The PR for &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8151481&quot; title=&quot;j.u.regex.Pattern  cleanup&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8151481&quot;&gt;&lt;strike&gt;JDK-8151481&lt;/strike&gt;&lt;/a&gt; (&lt;a href=&quot;https://github.com/openjdk/jdk/pull/6434&quot;&gt;https://github.com/openjdk/jdk/pull/6434&lt;/a&gt;) explains how the secondary_super_cache issue negatively affected the performance of j.u.regex.Pattern. </comment>
                            <comment id="14529353" author="cstein" created="Wed, 12 Oct 2022 01:28:59 -0700"  >Added link to &lt;a href=&quot;https://github.com/franz1981/type-pollution-agent&quot;&gt;https://github.com/franz1981/type-pollution-agent&lt;/a&gt;</comment>
                            <comment id="14361584" author="jrose" created="Fri, 7 Aug 2020 16:39:23 -0700"  >Background information:&lt;br/&gt;
&lt;a href=&quot;http://cr.openjdk.java.net/~jrose/jvm/checktype-2001.txt&quot;&gt;http://cr.openjdk.java.net/~jrose/jvm/checktype-2001.txt&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8251318&quot;&gt;https://bugs.openjdk.java.net/browse/JDK-8251318&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://mail.openjdk.java.net/pipermail/hotspot-runtime-dev/2020-August/041056.html&quot;&gt;https://mail.openjdk.java.net/pipermail/hotspot-runtime-dev/2020-August/041056.html&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://mail.openjdk.java.net/pipermail/hotspot-runtime-dev/2020-August/041051.html&quot;&gt;https://mail.openjdk.java.net/pipermail/hotspot-runtime-dev/2020-August/041051.html&lt;/a&gt;</comment>
                            <comment id="14246399" author="thartmann" created="Wed, 20 Feb 2019 03:09:21 -0800"  >ILW = Performance issue with secondary_super_cache (not a regression), with rare workloads, no workaround (but disable writing to cache in code and re-build hotspot) = MMH = P3</comment>
                            <comment id="14085356" author="jrose" created="Tue, 16 May 2017 15:13:35 -0700"  >Mulugeta Mammo of Intel came across this during a Genomics study and the same problem was later discovered in Cassandra.  Here is more information from Mulugeta:&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
Original JIRA post that includes the example: &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9823&quot;&gt;https://issues.scala-lang.org/browse/SI-9823&lt;/a&gt;&lt;br/&gt;
The PR that uses virtual calls: &lt;a href=&quot;https://github.com/scala/scala/pull/5364&quot;&gt;https://github.com/scala/scala/pull/5364&lt;/a&gt;&lt;br/&gt;
JVM workaround: disabling a writing to the secondary super cache:&lt;a href=&quot;http://hg.openjdk.java.net/jdk8u/jdk8u60/hotspot/file/37240c1019fd/src/cpu/x86/vm/macroAssembler_x86.cpp&quot;&gt;http://hg.openjdk.java.net/jdk8u/jdk8u60/hotspot/file/37240c1019fd/src/cpu/x86/vm/macroAssembler_x86.cpp&lt;/a&gt; lines: 5053, 5055, 5114&lt;br/&gt;
Scala download (we used 2.10.4 but 2.11 versions has same issue as well): &lt;a href=&quot;https://www.scala-lang.org/download/all.html&quot;&gt;https://www.scala-lang.org/download/all.html&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
The below code demonstrates the problem. After disabling the secondary super cache, I measured a performance gain as high as 40x on Haswell-EP with 2 sockets and 36 cores.&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
// javac Main.java&lt;br/&gt;
// java -XX:-Inline -XX:-TieredCompilation Main 36 8000000&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
import java.util.concurrent.ExecutorService;&lt;br/&gt;
import java.util.concurrent.Executors;&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
interface I1 {}&lt;br/&gt;
interface I2 {}&lt;br/&gt;
interface I3 extends I1, I2 {}&lt;br/&gt;
class B implements I3 {}&lt;br/&gt;
class C implements I3 {}&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
public class Main {&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;public static void main(String[] args) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int numThreads = Integer.parseInt(args[0]);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int loopCount = Integer.parseInt(args[1]);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ExecutorService es = Executors.newFixedThreadPool(numThreads);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;I3 b = new B();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;I3 c = new C();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int i = 0; i != numThreads; i++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;es.submit(() - &amp;gt;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int j = 0; j != loopCount; j++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;foo(b);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;foo(c);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;goo(b);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;goo(c);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;es.shutdown();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;public static boolean foo(I3 i) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return i instanceof I1;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;public static boolean goo(I3 i) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return i instanceof I2;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
}&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5152182">JDK-8351340</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10600">
                    <name>Causes</name>
                                            <outwardlinks description="causes">
                                        <issuelink>
            <issuekey id="5159343">JDK-8357525</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10002">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="5027021">JDK-8251318</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5131801">JDK-8334220</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5127898">JDK-8331117</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5129429">JDK-8332228</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5138839">JDK-8339916</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="4869888">JDK-8151481</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5128261">JDK-8331341</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5129743">JDK-8332498</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5127917">JDK-8331126</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5127998">JDK-8331159</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5129853">JDK-8332604</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5128261">JDK-8331341</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5129836">JDK-8332587</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5110203">JDK-8316180</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i28m8b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17414"><![CDATA[b19]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="208"><![CDATA[compiler]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>