<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Sat Sep 27 09:09:02 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8334719] (se) Deferred close of SelectableChannel may result in a Selector doing the final close before concurrent I/O on channel has completed</title>
                <link>https://bugs.openjdk.org/browse/JDK-8334719</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>The hs_err_&amp;lt;pid&amp;gt;.log shows:&lt;br/&gt;
&lt;br/&gt;
Event: 5.943 Thread 0x0000023ed289e5f0 Exception &amp;lt;a &amp;#39;java/net/SocketException&amp;#39;{0x00000000dbd53808}: Socket operation on nonsocket: sendto&amp;gt; (0x00000000dbd53808) &lt;br/&gt;
thrown [s\open\src\hotspot\share\prims\jni.cpp, line 539]&lt;br/&gt;
&lt;br/&gt;
This happens intermittently (and relatively rarely) but even if the channel is in non-blocking mode.&lt;br/&gt;
&lt;br/&gt;
Work arounds:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- Use non-blocking IO and a RW lock to control receive/send/close and avoid concurrent calls to close&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- or make sure everything happens in the selector thread&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- or use VirtualThread for sending and receiving - but that can lead to hangs due to &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8334574&quot; title=&quot;Socket operations never complete when run on a virtual thread&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8334574&quot;&gt;JDK-8334574&lt;/a&gt; &lt;br/&gt;
&lt;br/&gt;
</description>
                <environment></environment>
        <key id="5132376">JDK-8334719</key>
            <summary>(se) Deferred close of SelectableChannel may result in a Selector doing the final close before concurrent I/O on channel has completed</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="6" iconUrl="https://bugs.openjdk.org/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jpai">Jaikiran Pai</assignee>
                                    <reporter username="dfuchs">Daniel Fuchs</reporter>
                        <labels>
                            <label>hgupdate-sync</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                    </labels>
                <created>Fri, 21 Jun 2024 03:18:12 -0700</created>
                <updated>Fri, 20 Dec 2024 03:30:13 -0800</updated>
                            <resolved>Wed, 26 Jun 2024 21:40:57 -0700</resolved>
                                    <version>17</version>
                    <version>21</version>
                    <version>24</version>
                                    <fixVersion>24</fixVersion>
                                    <component>core-libs</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>9</watches>
                                                                                                                <comments>
                            <comment id="14710817" author="roboduke" created="Mon, 7 Oct 2024 02:12:30 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/1027&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/1027&lt;/a&gt;&lt;br/&gt;
Date: 2024-10-07 09:00:45 +0000</comment>
                            <comment id="14710816" author="goetz" created="Mon, 7 Oct 2024 02:09:43 -0700"  >Fix request [21u]&lt;br/&gt;
&lt;br/&gt;
I backport this for parity with 21.0.6-oracle.&lt;br/&gt;
Medium risk. Presumably rare scenario, but adds locking in important component.&lt;br/&gt;
Clean backport but needed to adapt test syntax to Java 21.&lt;br/&gt;
Test passes and fails without the fix. SAP nightly testing passed.</comment>
                            <comment id="14708368" author="alanb" created="Fri, 27 Sep 2024 04:15:11 -0700"  >[~jpai] No objection from me.</comment>
                            <comment id="14685707" author="msheppar" created="Fri, 28 Jun 2024 06:19:19 -0700"  >cheers, thanks for that clarification ... I overlooked the isOpen check in the SelectorImpl::implCloseSelector and the state check in the  kill method&lt;br/&gt;
(less haste, more scrutiny required)</comment>
                            <comment id="14685440" author="alanb" created="Thu, 27 Jun 2024 09:22:42 -0700"  >[~msheppar] The kill method is only invoked when the channel is closed, so T2 calling ensureOpen will throw ClosedChannelException.</comment>
                            <comment id="14685435" author="msheppar" created="Thu, 27 Jun 2024 09:08:29 -0700"  >OK grand.&lt;br/&gt;
&lt;br/&gt;
consider a slight variation on scenario 2&lt;br/&gt;
&lt;br/&gt;
T1 T2 are executing simultaneously T1 has unlock the lock, allowing T2 to continue executing, BUT T1 gets bumped by the OS scheduler&lt;br/&gt;
&amp;nbsp;(move over buddy and give another thread a chance), thus for T2 ensureOpen is all good and it makes it way to the low level &#8220;select&#8221;.&lt;br/&gt;
T1 resumes processing while T2 is still actively processing the accept, and the FD is closed, while T2 is still doing its business.&lt;br/&gt;
&lt;br/&gt;
This would result in a problem, I would think ?</comment>
                            <comment id="14685426" author="jpai" created="Thu, 27 Jun 2024 08:46:08 -0700"  >Hello Mark,&lt;br/&gt;
&lt;br/&gt;
&amp;gt; If t1 kill holds the lock, it blocks accept, but kill instantaneously releases the lock, and accept continues,&lt;br/&gt;
&lt;br/&gt;
The crucial detail here is that the code in ServerSocketChannelImpl.accept() (and similarly read/write/send/receive operations in relevant channel implementations) after acquiring the relevant lock will call an ensureOpen(), which will throw the (expected) ClosedChannelException and won&amp;#39;t let the accept() (read/write/send/receive operations) to proceed. &lt;br/&gt;
</comment>
                            <comment id="14685425" author="alanb" created="Thu, 27 Jun 2024 08:43:32 -0700"  >[~msheppar] A  t1 doing a selection operation will only call kill when the channel is not open. If t2 calls accept then it calls ensureOpen() after acquiring the accept lock and this will throw as the channel is not open.</comment>
                            <comment id="14685423" author="msheppar" created="Thu, 27 Jun 2024 08:39:41 -0700"  >&lt;br/&gt;
I didn&amp;#39;t get a chance to comment on this before you integrated&lt;br/&gt;
as I was trying to reason if my observations are bona fide concerns&lt;br/&gt;
&lt;br/&gt;
But, this solution looks somewhat racy:&lt;br/&gt;
&lt;br/&gt;
Take a simple scenario involving the ServerSocketChannelImpl  changes &lt;br/&gt;
&lt;br/&gt;
kill has acceptLock.lock; acceptLock.unlock  added&lt;br/&gt;
But  it doesn&amp;#39;t create a critical section for processing the finish and only a temporary  synchronisation point with accept &lt;br/&gt;
&lt;br/&gt;
two threads&lt;br/&gt;
t1 invoking kill&lt;br/&gt;
t2 invoking accept&lt;br/&gt;
&lt;br/&gt;
Scenario 1: &lt;br/&gt;
T2 executing and acquired the lock, t1 invokes kill and block on acquiring the lock.&lt;br/&gt;
Lock is released by t2, t1 now proceeds invoking unlock and processing the finish with close.&lt;br/&gt;
&lt;br/&gt;
Scenario 2:&lt;br/&gt;
t1 enters kill invokes lock,  while t2  simultaneously enters accept executing the initial statements and then lock&lt;br/&gt;
If t1 kill holds the lock, it blocks accept, but kill instantaneously releases the lock, and accept continues, while  kill also continues&lt;br/&gt;
and the outcome of the concurrent processing is the close of an FD while in processing an accept. Which seems to be problem which&lt;br/&gt;
the fixing is attempting to overcome.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;similar scenarios can be conceived around the other changes. As such it is not immediately obvious what the lock and unlock idiom is&lt;br/&gt;
achieving by way of serialising the concurrent execution on the shared FD resource.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14685262" author="roboduke" created="Wed, 26 Jun 2024 21:51:42 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: jdk23&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/19920&quot;&gt;https://git.openjdk.org/jdk/pull/19920&lt;/a&gt;&lt;br/&gt;
Date: 2024-06-27 04:46:37 +0000</comment>
                            <comment id="14685261" author="dukebot" created="Wed, 26 Jun 2024 21:40:56 -0700"  >Changeset: 9bb675f8&lt;br/&gt;
Author:    Jaikiran Pai &amp;lt;&lt;a href=&apos;mailto:jpai@openjdk.org&apos;&gt;jpai@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2024-06-27 04:38:32 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/9bb675f89dd1eeec423ca96cb3f96d29f5de477c&quot;&gt;https://git.openjdk.org/jdk/commit/9bb675f89dd1eeec423ca96cb3f96d29f5de477c&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14684578" author="roboduke" created="Tue, 25 Jun 2024 04:37:23 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/19879&quot;&gt;https://git.openjdk.org/jdk/pull/19879&lt;/a&gt;&lt;br/&gt;
Date: 2024-06-25 11:31:53 +0000</comment>
                            <comment id="14684140" author="alanb" created="Mon, 24 Jun 2024 06:33:36 -0700"  >I&amp;#39;ve fixed the title of this issue to make it clearer what this issue is about.</comment>
                            <comment id="14684071" author="alanb" created="Mon, 24 Jun 2024 03:01:27 -0700"  >This is a bug that arises when closing a selectable channel that is registered with a Selector. These cases defer the close until the channel is flushed from the Selector. There is bug in this code, specifically the kill method, where it should wait for any (non-blocking) I/O op in progress to finish before closing the file descriptor and releasing the resources. That is, it is needs the same lock/unlock that is in implCloseNonBlockingMode. For SocketChannel the bug may manifest as a &amp;quot;Bad file descriptor&amp;quot;. For DatagramChannel it can manifest with this exception or UB due to the release of its off-heap resources.&lt;br/&gt;
&lt;br/&gt;
The issue will duplicate JDK 17, maybe further back, e.g. JDK 13.</comment>
                            <comment id="14683708" author="dfuchs" created="Fri, 21 Jun 2024 08:24:21 -0700"  >[~jpai] has some ideas ;-) </comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5135363">JDK-8337366</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5136228">JDK-8337913</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5140659">JDK-8341523</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5141207">JDK-8341941</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5134222">JDK-8336355</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10002">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                                        </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                                                <inwardlinks description="relates to">
                                                        </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="109837" name="jdk.patch" size="3563" author="alanb" created="Mon, 24 Jun 2024 03:04:36 -0700"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i36txn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17314"><![CDATA[b04]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="228"><![CDATA[java.nio]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10100" key="com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons">
                        <customfieldname>Verification</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17000"><![CDATA[Verified]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>