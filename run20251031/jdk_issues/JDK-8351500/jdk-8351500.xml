<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Sat Sep 27 10:57:18 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8351500] G1: NUMA migrations cause crashes in region allocation</title>
                <link>https://bugs.openjdk.org/browse/JDK-8351500</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>(Note: This bug manifests on JDK 21 and 17; we don&amp;#39;t see crashes or asserts on mainline JDK. but I argue that the underlying root issue is also in mainline JDK and would best be fixed there).&lt;br/&gt;
&lt;br/&gt;
One of our customers found that NUMA migrations (more precisely, the OS task getting scheduled to a different NUMA node) can cause G1 to crash if they happen at exactly the wrong moment.&lt;br/&gt;
&lt;br/&gt;
JVM runs with +UseNUMA +UseNUMAInterleaving, G1GC and 4TB heap, two or four NUMA nodes, about 5000 application threads and 159 GC worker threads. JVM crashes (rarely, about once every four hours or so). &lt;br/&gt;
&lt;br/&gt;
Call stacks wildly different, e.g.:&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;28 Stack: [0x00007e506733f000,0x00007e5067540000],  sp=0x00007e506753cf10,  free space=2039k&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;29 Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;30 V  [libjvm.so+0xf32422]  Symbol::as_klass_external_name() const+0x12  (symbol.hpp:140)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;31 V  [libjvm.so+0xda71ff]  SharedRuntime::generate_class_cast_message(Klass*, Klass*, Symbol*)+0x1f  (sharedRuntime.cpp:2179)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;32 V  [libjvm.so+0xda99c4]  SharedRuntime::generate_class_cast_message(JavaThread*, Klass*)+0xd4  (sharedRuntime.cpp:2171)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;33 V  [libjvm.so+0x578e2c]  Runtime1::throw_class_cast_exception(JavaThread*, oopDesc*)+0x13c  (c1_Runtime1.cpp:735)&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
in some crashes, it looks like we load a zero from the heap where no zero should be (eg. as narrow Klass ID from an oop header).&lt;br/&gt;
&lt;br/&gt;
However, if you run a debug JVM, you usually see an assert either in G1Allocator or in CollectedHeap, for example&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
&amp;nbsp;&amp;nbsp;27 Current thread (0x00007fb770087b70):  JavaThread &amp;quot;Thread-33&amp;quot;        [_thread_in_vm, id=123345, stack(0x00007fb7a86d7000,0x00007fb7a87d8000) (1028K)]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;28 &lt;br/&gt;
&amp;nbsp;&amp;nbsp;29 Stack: [0x00007fb7a86d7000,0x00007fb7a87d8000],  sp=0x00007fb7a87d62f0,  free space=1020k&lt;br/&gt;
&amp;nbsp;&amp;nbsp;30 Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;31 V  [libjvm.so+0x9fdd6b]  CollectedHeap::fill_with_object_impl(HeapWordImpl**, unsigned long, bool) [clone .part.0]+0x2b  (collectedHeap.cpp:470)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;32 V  [libjvm.so+0x9fff1d]  CollectedHeap::fill_with_object(HeapWordImpl**, unsigned long, bool)+0x39d  (arrayOop.hpp:58)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;33 V  [libjvm.so+0xc5009f]  G1AllocRegion::fill_up_remaining_space(HeapRegion*)+0x1ef  (g1AllocRegion.cpp:79)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;34 V  [libjvm.so+0xc5027c]  G1AllocRegion::retire_internal(HeapRegion*, bool)+0x6c  (g1AllocRegion.cpp:106)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;35 V  [libjvm.so+0xc51347]  MutatorAllocRegion::retire(bool)+0xb7  (g1AllocRegion.cpp:300)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;36 V  [libjvm.so+0xc50ed9]  G1AllocRegion::new_alloc_region_and_allocate(unsigned long, bool)+0x59  (g1AllocRegion.cpp:139)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;37 V  [libjvm.so+0xc9b140]  G1CollectedHeap::attempt_allocation_slow(unsigned long)+0x6d0  (g1AllocRegion.inline.hpp:120)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;38 V  [libjvm.so+0xc9e4ff]  G1CollectedHeap::attempt_allocation(unsigned long, unsigned long, unsigned long*)+0x39f  (g1CollectedHeap.cpp:643)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;39 V  [libjvm.so+0xc9bd4f]  G1CollectedHeap::mem_allocate(unsigned long, bool*)+0x5f  (g1CollectedHeap.cpp:401)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;40 V  [libjvm.so+0x13b9b6d]  MemAllocator::mem_allocate_slow(MemAllocator::Allocation&amp;amp;) const+0x5d  (memAllocator.cpp:240)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;41 V  [libjvm.so+0x13b9ca1]  MemAllocator::allocate() const+0xa1  (memAllocator.cpp:357)&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
The problem is in `G1Allocator`. `G1AllocRegion` objects tied to NUMA nodes. For most actions involving the `G1Allocator`, we determine the `G1AllocRegion` of the current thread, then redirect the action toward that alloc region. However, due to OS scheduling the NUMA-to-thread-association can change arbitrarily. That means calls to `G1Allocator` are not guaranteed to hit the same `G1AllocRegion` object as last time.&lt;br/&gt;
&lt;br/&gt;
Now, we have control flows that assume that we work with the same `G1AllocRegion` object over their duration, since we build up state in `G1AllocRegion`. The JDK 21 control flow affected is:&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
- `G1CollectedHeap::attempt_allocation_slow`&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- `G1Allocator::attempt_allocation_locked`                 (A)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `G1AllocRegion::attempt_allocation_locked`             &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `G1AllocRegion::attempt_allocation`                  (try again allocating from HeapRegion under lock protection); failing that:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `G1AllocRegion::attempt_allocation_using_new_region`&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `G1AllocRegion::retire`                            (retires current allocation region; may keep it as retained region)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `G1AllocRegion::new_alloc_region_and_allocate`     (allocate new HeapRegion and set it; failing that, sets dummy region), failing that:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- `G1Allocator::attempt_allocation_force`                  (B)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `G1AllocRegion::attempt_allocation_force`&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `G1AllocRegion::new_alloc_region_and_allocate`&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
Here, if we change NUMA node from (A) to (B), we will address different `G1AllocRegion` objects. But `G1AllocRegion::attempt_allocation_force` assumes that the current allocation region for this object is retired, which is done by the preceding `G1AllocRegion::attempt_allocation_locked`, but for a different region.&lt;br/&gt;
&lt;br/&gt;
This causes us to abandon the current allocation region; it won&amp;#39;t be added to the collection set. On debug JVMs, we hit one of two asserts. We either complain about the current allocation region being not dummy at the entrance of new_alloc_region_and_allocate; In JDK 17, we assert when retire the wrong region, and it is more empty than expected. The effect of this can be delayed, happening on the next retire, since it can affect the retained region.&lt;br/&gt;
&lt;br/&gt;
----&lt;br/&gt;
&lt;br/&gt;
Reproduction and Regression testing&lt;br/&gt;
&lt;br/&gt;
Reproducing the bug is difficult. I did not have a NUMA machine, and even if I had one, NUMA task-node migrations are very rare. Therefore, I build something like a &amp;quot;FakeNUMA&amp;quot; mode which essentially interposes OS NUMA calls and fakes a NUMA system of 8 nodes. I also added a &amp;quot;FakeNUMAStressMigrations&amp;quot; mode mimicking frequent node migrations. With these simple tools, I could reproduce the customer problem (with gc/TestJNICriticalStressTest, slightly modified to increase the number of JNICritical threads). I plan to bring the FakeNUMA mode upstream, but have no time atm to polish it up.&lt;br/&gt;
</description>
                <environment></environment>
        <key id="5152370">JDK-8351500</key>
            <summary>G1: NUMA migrations cause crashes in region allocation</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="stuefe">Thomas Stuefe</assignee>
                                    <reporter username="stuefe">Thomas Stuefe</reporter>
                        <labels>
                            <label>NUMA</label>
                            <label>gc-g1</label>
                            <label>jdk21u-critical-no</label>
                            <label>jdk21u-critical-request</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>jdk24u-fix-SQE-ok-next</label>
                            <label>jdk24u-fix-request</label>
                            <label>jdk24u-fix-yes</label>
                    </labels>
                <created>Mon, 10 Mar 2025 06:32:41 -0700</created>
                <updated>Tue, 15 Jul 2025 00:18:59 -0700</updated>
                            <resolved>Thu, 13 Mar 2025 09:13:44 -0700</resolved>
                                    <version>17</version>
                    <version>21</version>
                    <version>25</version>
                                    <fixVersion>25</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="14798496" author="stuefe" created="Tue, 15 Jul 2025 00:18:59 -0700"  >Note, backport to JDK 17 :&lt;br/&gt;
&lt;br/&gt;
There is no technical reason this fix could not be backported to JDK 17. We withdrew the patch because of a lack of time and because we deemed it as non-critical for now, since we only saw this problem with one customer on JDK 21. &lt;br/&gt;
&lt;br/&gt;
The fix should be pretty safe to backport unless the underlying implementation changes dramatically in JDK 17. For future reference, the patch for JDK 17 is here: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/3607&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/3607&lt;/a&gt;.</comment>
                            <comment id="14782711" author="roboduke" created="Thu, 22 May 2025 10:01:27 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/3607&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/3607&lt;/a&gt;&lt;br/&gt;
Date: 2025-05-22 13:16:06 +0000</comment>
                            <comment id="14782709" author="roboduke" created="Thu, 22 May 2025 09:59:32 -0700"  >[jdk17u-fix-request] Approval Request from Thomas Stuefe&lt;br/&gt;
This is a solution for a quite hairy problem that hits customers on NUMA machines. It is rare, intermittent, and quite difficult to pinpoint. I therefore would appreciate it if I got approval for backporting.&lt;br/&gt;
&lt;br/&gt;
Risk: lowish. The mechanism is quite clear, the patch, albeit unclean, simple in essence. I also took care to test its functioning well (see JBS description for details.)</comment>
                            <comment id="14764571" author="roboduke" created="Thu, 27 Mar 2025 01:03:13 -0700"  >[jdk21u-fix-request] Approval Request from Thomas Stuefe&lt;br/&gt;
This is a fix for one of our customers. It prevents daily crashes in their production systems.&lt;br/&gt;
&lt;br/&gt;
Risk: low to low-medium. Patch itself is simple, but mixed with additional aesthetical changes. But those are very simple themselves, so I think this is fine.&lt;br/&gt;
&lt;br/&gt;
Testing:&lt;br/&gt;
&lt;br/&gt;
- SAP ran their JDK 21 test CI successfully.&lt;br/&gt;
- Adoptium ran all their tests too&lt;br/&gt;
- I tested the fix with an additional patch on top that fakes a NUMA system with a high chance of node migration. I verified that without fix we crash, with fix we don&amp;#39;t.&lt;br/&gt;
- GHAs are green.&lt;br/&gt;
&lt;br/&gt;
Before pushing, I will re-merge and let GHAs run through again.</comment>
                            <comment id="14763349" author="sgehwolf" created="Mon, 24 Mar 2025 06:14:20 -0700"  >[OpenJDK 21u critical approval comment]&lt;br/&gt;
&lt;br/&gt;
This change has had very little real world exposure and touches default GC code. We are one day before the code freeze for the April 21.0.7 release which makes approving this nearly impossible. This would be better suited for the July 21.0.8 release.</comment>
                            <comment id="14763300" author="roboduke" created="Mon, 24 Mar 2025 04:16:52 -0700"  >[jdk21u-critical-request] Approval Request from Thomas Stuefe&lt;br/&gt;
This is a fix for one of our customers. It prevents daily crashes in their production systems. &lt;br/&gt;
&lt;br/&gt;
Risk: low to low-medium. Patch itself is simple, but somewhat tainted by additional aesthetics. Those are simple in themselves, though, so I think this is fine.&lt;br/&gt;
&lt;br/&gt;
Testing: &lt;br/&gt;
- SAP ran their JDK 21 test CI successfully. &lt;br/&gt;
- I tested the fix with an additional patch atop that fakes a NUMA system with a high chance of node migration and verified that without fix we crash, with fix we don&amp;#39;t. &lt;br/&gt;
- GHAs are green.</comment>
                            <comment id="14763291" author="roboduke" created="Mon, 24 Mar 2025 03:48:51 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u/pull/461&quot;&gt;https://git.openjdk.org/jdk21u/pull/461&lt;/a&gt;&lt;br/&gt;
Date: 2025-03-24 07:38:03 +0000</comment>
                            <comment id="14761077" author="roboduke" created="Fri, 14 Mar 2025 10:45:49 -0700"  >[jdk24u-fix-request] Approval Request from Thomas Stuefe&lt;br/&gt;
This fixes a crash with UseNUMA on large NUMA installations.</comment>
                            <comment id="14761020" author="roboduke" created="Fri, 14 Mar 2025 07:13:50 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk24u/pull/138&quot;&gt;https://git.openjdk.org/jdk24u/pull/138&lt;/a&gt;&lt;br/&gt;
Date: 2025-03-14 13:29:03 +0000</comment>
                            <comment id="14760859" author="roboduke" created="Thu, 13 Mar 2025 22:40:05 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/1488&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/1488&lt;/a&gt;&lt;br/&gt;
Date: 2025-03-13 16:47:52 +0000</comment>
                            <comment id="14760705" author="dukebot" created="Thu, 13 Mar 2025 09:13:43 -0700"  >Changeset: 37ec7962&lt;br/&gt;
Branch: master&lt;br/&gt;
Author:    Thomas Stuefe &amp;lt;&lt;a href=&apos;mailto:stuefe@openjdk.org&apos;&gt;stuefe@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2025-03-13 16:08:08 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/37ec796255ae857588a5c7e0d572407dd81cbec9&quot;&gt;https://git.openjdk.org/jdk/commit/37ec796255ae857588a5c7e0d572407dd81cbec9&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14759668" author="roboduke" created="Tue, 11 Mar 2025 08:31:42 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/23984&quot;&gt;https://git.openjdk.org/jdk/pull/23984&lt;/a&gt;&lt;br/&gt;
Date: 2025-03-11 14:01:11 +0000</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5153331">JDK-8352387</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5154190">JDK-8353102</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10002">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="5150915">JDK-8350490</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5152502">JDK-8351630</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5152521">JDK-8351649</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5152395">JDK-8351526</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5152654">JDK-8351770</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10005" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>OS</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17023"><![CDATA[linux]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3a4p7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17352"><![CDATA[b15]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="209"><![CDATA[gc]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>