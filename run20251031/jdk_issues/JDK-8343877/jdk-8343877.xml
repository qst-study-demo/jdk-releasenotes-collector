<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Sat Sep 27 09:28:16 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8343877] Test AsyncClose.java intermittent fails - Socket.getInputStream().read() wasn&apos;t preempted</title>
                <link>https://bugs.openjdk.org/browse/JDK-8343877</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>Test java/net/Socket/asyncClose/AsyncClose.java intermittent fails with VM options -Xcomp -XX:TieredStopAtLevel=1, the test log snippet:&lt;br/&gt;
&lt;br/&gt;
command: main -Djava.net.preferIPv4Stack=true AsyncClose&lt;br/&gt;
reason: User specified action: run main/othervm -Djava.net.preferIPv4Stack=true AsyncClose &lt;br/&gt;
started: Fri Nov 08 21:07:06 CST 2024&lt;br/&gt;
Mode: othervm [/othervm specified]&lt;br/&gt;
finished: Fri Nov 08 21:07:12 CST 2024&lt;br/&gt;
elapsed time (seconds): 6.014&lt;br/&gt;
configuration:&lt;br/&gt;
STDOUT:&lt;br/&gt;
******************************&lt;br/&gt;
Test: Socket.getInputStream().read()&lt;br/&gt;
Failed: &lt;br/&gt;
&amp;nbsp;- Socket.getInputStream().read() returned unexpectedly!!&lt;br/&gt;
&amp;nbsp;- Socket.getInputStream().read() wasn&amp;#39;t preempted</description>
                <environment>&lt;p&gt;+ uname -a&lt;br/&gt;
Linux iZwz97g64ams7d2vxm4xaiZ 5.10.134-17.2.al8.aarch64 #1 SMP Fri Aug 9 15:44:30 CST 2024 aarch64 aarch64 aarch64 GNU/Linux&lt;br/&gt;
+ cat /etc/os-release&lt;br/&gt;
NAME=&quot;Alibaba Cloud Linux&quot;&lt;br/&gt;
VERSION=&quot;3 (OpenAnolis Edition)&quot;&lt;br/&gt;
ID=&quot;alinux&quot;&lt;br/&gt;
ID_LIKE=&quot;rhel fedora centos anolis&quot;&lt;br/&gt;
VERSION_ID=&quot;3&quot;&lt;br/&gt;
VARIANT=&quot;OpenAnolis Edition&quot;&lt;br/&gt;
VARIANT_ID=&quot;openanolis&quot;&lt;br/&gt;
ALINUX_MINOR_ID=&quot;2104&quot;&lt;br/&gt;
ALINUX_UPDATE_ID=&quot;10&quot;&lt;br/&gt;
PLATFORM_ID=&quot;platform:al8&quot;&lt;br/&gt;
PRETTY_NAME=&quot;Alibaba Cloud Linux 3.2104 U10 (OpenAnolis Edition)&quot;&lt;br/&gt;
ANSI_COLOR=&quot;0;31&quot;&lt;br/&gt;
HOME_URL=&quot;https://www.aliyun.com/&quot;&lt;br/&gt;
+ free -h&lt;br/&gt;
&#160; &#160; &#160; &#160; &#160; &#160; &#160; total &#160; &#160; &#160; &#160;used &#160; &#160; &#160; &#160;free &#160; &#160; &#160;shared &#160;buff/cache &#160; available&lt;br/&gt;
Mem: &#160; &#160; &#160; &#160; &#160;492Gi &#160; &#160; &#160; 1.3Gi &#160; &#160; &#160; 435Gi &#160; &#160; &#160; 0.0Ki &#160; &#160; &#160; &#160;56Gi &#160; &#160; &#160; 487Gi&lt;br/&gt;
Swap: &#160; &#160; &#160; &#160; &#160; &#160;0B &#160; &#160; &#160; &#160; &#160;0B &#160; &#160; &#160; &#160; &#160;0B&lt;br/&gt;
+ lscpu&lt;br/&gt;
+ head -n 25&lt;br/&gt;
Architecture: &#160; &#160; &#160; &#160;aarch64&lt;br/&gt;
Byte Order: &#160; &#160; &#160; &#160; &#160;Little Endian&lt;br/&gt;
CPU(s): &#160; &#160; &#160; &#160; &#160; &#160; &#160;64&lt;br/&gt;
On-line CPU(s) list: 0-63&lt;br/&gt;
Thread(s) per core: &#160;1&lt;br/&gt;
Core(s) per socket: &#160;64&lt;br/&gt;
Socket(s): &#160; &#160; &#160; &#160; &#160; 1&lt;br/&gt;
NUMA node(s): &#160; &#160; &#160; &#160;1&lt;br/&gt;
Vendor ID: &#160; &#160; &#160; &#160; &#160; ARM&lt;br/&gt;
BIOS Vendor ID: &#160; &#160; &#160;Alibaba Cloud&lt;br/&gt;
Model: &#160; &#160; &#160; &#160; &#160; &#160; &#160; 0&lt;br/&gt;
Model name: &#160; &#160; &#160; &#160; &#160;Neoverse-N2&lt;br/&gt;
BIOS Model name: &#160; &#160; virt-rhel7.6.0&lt;br/&gt;
Stepping: &#160; &#160; &#160; &#160; &#160; &#160;r0p0&lt;br/&gt;
CPU MHz: &#160; &#160; &#160; &#160; &#160; &#160; 3000.000&lt;br/&gt;
CPU max MHz: &#160; &#160; &#160; &#160; 3000.0000&lt;br/&gt;
CPU min MHz: &#160; &#160; &#160; &#160; 3000.0000&lt;br/&gt;
BogoMIPS: &#160; &#160; &#160; &#160; &#160; &#160;100.00&lt;br/&gt;
L1d cache: &#160; &#160; &#160; &#160; &#160; 64K&lt;br/&gt;
L1i cache: &#160; &#160; &#160; &#160; &#160; 64K&lt;br/&gt;
L2 cache: &#160; &#160; &#160; &#160; &#160; &#160;1024K&lt;br/&gt;
L3 cache: &#160; &#160; &#160; &#160; &#160; &#160;65536K&lt;br/&gt;
NUMA node0 CPU(s): &#160; 0-63&lt;br/&gt;
Flags: &#160; &#160; &#160; &#160; &#160; &#160; &#160; fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma lrcpc dcpop sha3 sm3 sm4 asimddp sha512 sve asimdfhm dit uscat ilrcpc flagm ssbs sb dcpodp sve2 sveaes svepmull svebitperm svesha3 svesm4 flagm2 frint svei8mm svebf16 i8mm bf16 dgh&lt;br/&gt;
+ java -version&lt;br/&gt;
openjdk version &quot;24-internal&quot; 2025-03-18&lt;br/&gt;
OpenJDK Runtime Environment (build 24-internal-0c281acf)&lt;br/&gt;
OpenJDK 64-Bit Server VM (build 24-internal-0c281acf, mixed mode, sharing)&lt;br/&gt;
+ java -Xinternalversion&lt;br/&gt;
OpenJDK 64-Bit Server VM (24-internal-0c281acf) for linux-aarch64 JRE (24-internal-0c281acf), built on 2024-11-08T12:09:47Z with gcc 10.2.1 20210130 (Red Hat 10.2.1-11)&lt;br/&gt;
+ jtreg -version&lt;br/&gt;
jtreg 7.4-dev+0&lt;br/&gt;
Installed in /tmp/tone/run/jtreg/jtreg/lib/jtreg.jar&lt;br/&gt;
Running on platform version 24-internal from /tmp/tone/run/jtreg/jdk-repo/build/linux-aarch64-server-release/images/jdk.&lt;br/&gt;
Built with Java(TM) 2 SDK, Version 11.0.21+9-LTS on June 14, 2024.&lt;br/&gt;
Copyright (c) 1999, 2022, Oracle and/or its affiliates. All rights reserved.&lt;br/&gt;
Use is subject to license terms.&lt;br/&gt;
JT Harness, version 6.0 ea b24 (June 14, 2024)&lt;br/&gt;
Java Assembler Tools, version 7.0 ea b09 (June 14, 2024)&lt;br/&gt;
TestNG: testng-7.3.0.jar, guice-5.1.0.jar, jcommander-1.82.jar&lt;br/&gt;
JUnit: junit-platform-console-standalone-1.10.2.jar&lt;br/&gt;
+ git remote -v&lt;br/&gt;
origin &#160;git@github.com:openjdk/jdk.git (fetch)&lt;br/&gt;
origin &#160;git@github.com:openjdk/jdk.git (push)&lt;br/&gt;
+ git branch&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;master&lt;br/&gt;
+ git log -n 1&lt;br/&gt;
+ head -n 1&lt;br/&gt;
commit 0c281acfb4c87436096cb562d70f800dffa3671a&lt;br/&gt;
+ git status&lt;br/&gt;
On branch master&lt;br/&gt;
Your branch is up to date with &apos;origin/master&apos;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;nothing to commit, working tree clean&lt;br/&gt;
+ git diff&lt;/p&gt;</environment>
        <key id="5143450">JDK-8343877</key>
            <summary>Test AsyncClose.java intermittent fails - Socket.getInputStream().read() wasn&apos;t preempted</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jpai">Jaikiran Pai</assignee>
                                    <reporter username="syan">Sendao Yan</reporter>
                        <labels>
                            <label>intermittent</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>noreg-self</label>
                            <label>ur-ci-health</label>
                    </labels>
                <created>Fri, 8 Nov 2024 17:38:07 -0800</created>
                <updated>Tue, 15 Apr 2025 00:57:28 -0700</updated>
                            <resolved>Thu, 14 Nov 2024 06:47:48 -0800</resolved>
                                    <version>24</version>
                                    <fixVersion>24</fixVersion>
                                    <component>core-libs</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                                                                <comments>
                            <comment id="14725831" author="roboduke" created="Sun, 24 Nov 2024 23:12:17 -0800"  >[jdk17u-fix-request] Approval Request from sendaoYan&lt;br/&gt;
Clean backport to fix the test bug which cause test intermittent fails, backport pair with 17.0.15-oracle. The change has been verified locally, test-fix only, no risk.</comment>
                            <comment id="14725830" author="roboduke" created="Sun, 24 Nov 2024 23:10:03 -0800"  >[jdk21u-fix-request] Approval Request from sendaoYan&lt;br/&gt;
Clean backport to fix the test bug which cause test intermittent fails, backport pair with 21.0.7-oracle. The change has been verified locally, test-fix only, no risk.</comment>
                            <comment id="14725143" author="roboduke" created="Thu, 21 Nov 2024 22:49:32 -0800"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/1174&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/1174&lt;/a&gt;&lt;br/&gt;
Date: 2024-11-22 06:44:31 +0000</comment>
                            <comment id="14725142" author="roboduke" created="Thu, 21 Nov 2024 22:49:04 -0800"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/3071&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/3071&lt;/a&gt;&lt;br/&gt;
Date: 2024-11-22 06:44:34 +0000</comment>
                            <comment id="14722369" author="dukebot" created="Thu, 14 Nov 2024 06:47:47 -0800"  >Changeset: 752e1629&lt;br/&gt;
Branch: master&lt;br/&gt;
Author:    Jaikiran Pai &amp;lt;&lt;a href=&apos;mailto:jpai@openjdk.org&apos;&gt;jpai@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2024-11-14 14:46:19 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/752e1629555f0ec8630373ec87b049afdd709ea6&quot;&gt;https://git.openjdk.org/jdk/commit/752e1629555f0ec8630373ec87b049afdd709ea6&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14722302" author="jpai" created="Thu, 14 Nov 2024 02:16:49 -0800"  >Glad to hear that. Thank you for running the tests.</comment>
                            <comment id="14722281" author="JIRAUSER21405" created="Thu, 14 Nov 2024 01:11:09 -0800"  >After git apply the patch from &lt;a href=&quot;https://github.com/openjdk/jdk/pull/22093&quot;&gt;https://github.com/openjdk/jdk/pull/22093&lt;/a&gt; and run the test 10k times, all test passed.</comment>
                            <comment id="14722201" author="JIRAUSER21405" created="Wed, 13 Nov 2024 22:16:41 -0800"  >Okey</comment>
                            <comment id="14722183" author="jpai" created="Wed, 13 Nov 2024 21:03:58 -0800"  >Hello [~syan], a PR to address this issue in the test is now available &lt;a href=&quot;https://github.com/openjdk/jdk/pull/22093&quot;&gt;https://github.com/openjdk/jdk/pull/22093&lt;/a&gt;. Would it be possible for you to apply that change against mainline and verify that this change does indeed address the issue against your setups where this failure was reproduced?</comment>
                            <comment id="14722181" author="roboduke" created="Wed, 13 Nov 2024 21:01:39 -0800"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/22093&quot;&gt;https://git.openjdk.org/jdk/pull/22093&lt;/a&gt;&lt;br/&gt;
Date: 2024-11-14 04:56:12 +0000</comment>
                            <comment id="14721507" author="msheppar" created="Wed, 13 Nov 2024 06:21:01 -0800"  >good spot [~djelinski]&lt;br/&gt;
&lt;br/&gt;
we can emulate the failure by closing s2 after the latch.await() in the go method. This would infer that there is a strong possibility that s2 is being GCed early, when -Xcomp is enabled, and within the scope of the go method, while still being actively used. It is superficially assumed not in use. This early GCing of objects has been intermittently observed in other tests &lt;br/&gt;
when run with -Xcomp. A common remedy is to use an ReachabilityFence to prohibit early cleanup while the object is still actively used.&lt;br/&gt;
&lt;br/&gt;
As the accepted Socket s2 and the ServerSocket ss are not explicitly closed in the test, then a try-with-resources is probably needed also&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
emulation call flows:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;AsyncClose&lt;br/&gt;
----------stdout:(7/350)----------&lt;br/&gt;
NioSocketImpl.tryRead: ENTER thread 1&lt;br/&gt;
NiosocketImpl.tryRead: nd is_a sun.nio.ch.SocketDispatcher thread 1&lt;br/&gt;
NiosocketImpl.tryRead: nd.read ==   1432 thread 1&lt;br/&gt;
NioSocketImpl.tryRead: ENTER thread 1&lt;br/&gt;
NiosocketImpl.tryRead: nd is_a sun.nio.ch.SocketDispatcher thread 1&lt;br/&gt;
NiosocketImpl.tryRead: nd.read ==   1625 thread 1&lt;br/&gt;
NioSocketImpl.tryRead: ENTER thread 1&lt;br/&gt;
----------stderr:(10/554)----------&lt;br/&gt;
Java_sun_nio_ch_SocketDispatcher_read0: ENTER &lt;br/&gt;
Java_sun_nio_ch_SocketDispatcher_read0: read fd == 7  returned n = 1432 &lt;br/&gt;
Java_sun_nio_ch_SocketDispatcher_read0: ENTER &lt;br/&gt;
Java_sun_nio_ch_SocketDispatcher_read0: read fd == 7  returned n = 1625 &lt;br/&gt;
Java_sun_nio_ch_UnixDispatcher_close0: fd == 16 &lt;br/&gt;
Java_sun_nio_ch_UnixDispatcher_close0: fd == 16 &lt;br/&gt;
Java_sun_nio_ch_SocketDispatcher_read0: ENTER &lt;br/&gt;
Java_sun_nio_ch_SocketDispatcher_read0: read fd == 19  returned n = 0 &lt;br/&gt;
Java_sun_nio_ch_UnixDispatcher_close0: fd == 20 &lt;br/&gt;
Java_sun_nio_ch_UnixDispatcher_close0: fd == 19 &lt;br/&gt;
----------System.out:(17/692)----------&lt;br/&gt;
Socket impl is_a java.net.SocksSocketImpl thread 21&lt;br/&gt;
run: close Server socket s2 thread 23&lt;br/&gt;
NioSocketImpl.tryRead: ENTER thread 23&lt;br/&gt;
NiosocketImpl.tryRead: nd is_a sun.nio.ch.SocketDispatcher thread 23&lt;br/&gt;
go: close Server socket s2 thread 22      &amp;lt;--- emulating premature close of Socket s2&lt;br/&gt;
NioSocketImpl.close: ENTER thread == 22&lt;br/&gt;
NioSocketImpl.tryClose: ENTER readerThread == 0&lt;br/&gt;
NiosocketImpl.tryRead: nd.read ==   -1 thread 23&lt;br/&gt;
go: Socket::close thread 22&lt;br/&gt;
NioSocketImpl.close: ENTER thread == 22&lt;br/&gt;
NioSocketImpl.tryClose: ENTER readerThread == 0&lt;br/&gt;
******************************&lt;br/&gt;
Test: Socket.getInputStream().read()&lt;br/&gt;
Failed: &lt;br/&gt;
&amp;nbsp;- run: Socket.getInputStream().read() returned unexpectedly!! n == -1&lt;br/&gt;
&amp;nbsp;- go: Socket.getInputStream().read() wasn&amp;#39;t preempted&lt;br/&gt;
</comment>
                            <comment id="14721491" author="jpai" created="Wed, 13 Nov 2024 05:43:57 -0800"  >&amp;gt; STDERR:&lt;br/&gt;
&amp;gt; underlying read returned 0, returning EOF&lt;br/&gt;
&amp;gt; Socket read() returning -1&lt;br/&gt;
&amp;gt; marking EOF &lt;br/&gt;
&lt;br/&gt;
Thank you for running these tests. This now brings us closer to understanding what&amp;#39;s going on (which I believe is a test bug). So as noticed in that above logs, it shows that the underlying read() system call returns 0 and we then return a -1 indicating EOF from the Socket.read() call.&lt;br/&gt;
&lt;br/&gt;
The reason why the read() returns 0 (indicating EOF) intermittently I think can be attributed to timing differences, which apparently seem to be introduced by the change in &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt;. As Daniel noted in his previous comment, &amp;quot;s2&amp;quot; (the Socket instance that was &amp;quot;accept()&amp;quot;ed by the server) isn&amp;#39;t used after it&amp;#39;s assigned and I think that is contributing to &amp;quot;s2&amp;quot; being prone to being cleaned up by GC and the underlying file descriptor of the Socket being closed by the cleaner before the client side &amp;quot;Socket.read()&amp;quot; is attempted. That then results in the system call returning EOF. In fact, if you change that test as follows (to simulate what&amp;#39;s happening):&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
diff --git a/test/jdk/java/net/Socket/asyncClose/Socket_getInputStream_read.java b/test/jdk/java/net/Socket/asyncClose/Socket_getInputStream_read.java&lt;br/&gt;
index f2082fcf374..230adc80f15 100644&lt;br/&gt;
--- a/test/jdk/java/net/Socket/asyncClose/Socket_getInputStream_read.java&lt;br/&gt;
+++ b/test/jdk/java/net/Socket/asyncClose/Socket_getInputStream_read.java&lt;br/&gt;
@@ -82,6 +82,7 @@ public AsyncCloseTest go() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Socket s2 = ss.accept();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread thr = new Thread(this);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thr.start();&lt;br/&gt;
+            s2.close();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;latch.await();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(5000); //sleep, so Socket.getInputStream().read() can block&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s.close();&lt;br/&gt;
&lt;br/&gt;
then I believe you should see this failure every time with the same error messages. I think the changes in &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt; has exposed this test bug. </comment>
                            <comment id="14721488" author="JIRAUSER21405" created="Wed, 13 Nov 2024 05:29:30 -0800"  >After git apply patch 8343877-debugging.patch, test 10k times, there is 1 time fails, and the failed sub-test is &amp;#39;Socket.getInputStream().read() (with timeout)&amp;#39; &lt;br/&gt;
The log file 5956.log and AsyncClose.jtr has been uploaded. The log snippet:&lt;br/&gt;
&lt;br/&gt;
Test: Socket.getInputStream().read() (with timeout)&lt;br/&gt;
Failed: &lt;br/&gt;
&amp;nbsp;- Socket.getInputStream().read() returned unexpectedly!! n == -1&lt;br/&gt;
&amp;nbsp;- Socket.getInputStream().read() wasn&amp;#39;t preempted&lt;br/&gt;
&lt;br/&gt;
STDERR:&lt;br/&gt;
underlying read returned 0, returning EOF&lt;br/&gt;
Socket read() returning -1&lt;br/&gt;
marking EOF&lt;br/&gt;
java.lang.Exception: 1 sub-tests failed - see log.&lt;br/&gt;
	at AsyncClose.main(AsyncClose.java:76)</comment>
                            <comment id="14721397" author="JIRAUSER21405" created="Wed, 13 Nov 2024 01:13:18 -0800"  >After git apply patch 8343877-debugging.patch, test 500 times and all passed with C1 on linux-aarch64. I will try more time later.</comment>
                            <comment id="14721396" author="JIRAUSER19825" created="Wed, 13 Nov 2024 01:08:57 -0800"  >if the read says it got an EOF, it&amp;#39;s probably true. Note that the server socket (s2) is leaked and closed asynchronously by a cleaner.</comment>
                            <comment id="14721358" author="jpai" created="Wed, 13 Nov 2024 00:26:50 -0800"  >&amp;gt; Looking through the implementation (and the specification) of java.net.Socket.read(), the only possible way where this method can return -1 would be if Socket.shutdownInput() was called on that Socket before read() was attempted.&lt;br/&gt;
&lt;br/&gt;
The other possibility is that the underlying system call to read() is itself returning 0, which represents EOF and we convert that return value to -1 in our JNI layer. &amp;quot;man 2 read&amp;quot; on linux aarch64 states:&lt;br/&gt;
&lt;br/&gt;
&amp;gt; On  success,  the  number of bytes read is returned (zero indicates end of file) ...&lt;br/&gt;
&lt;br/&gt;
[~syan], it&amp;#39;s easier to run some diagnostics on your setup since you have been consistently reproducing this issue. Could you please apply the attached patch (&amp;quot;8343877-debugging.patch&amp;quot; file) to an unchanged JDK mainline repo and then build the JDK afresh and re-run the test to reproduce this failure? The attached patch merely introduces some debug logs in the relevant code path. Upload the .jtr log when it fails with this patched version and hopefully that will provide further insights.&lt;br/&gt;
</comment>
                            <comment id="14721344" author="jpai" created="Tue, 12 Nov 2024 23:03:56 -0800"  >&amp;gt; Failed:&lt;br/&gt;
&amp;gt; - Socket.getInputStream().read() returned unexpectedly!! n == -1 &lt;br/&gt;
&lt;br/&gt;
Looking through the implementation (and the specification) of java.net.Socket.read(), the only possible way where this method can return -1 would be if Socket.shutdownInput() was called on that Socket before read() was attempted. This Socket_getInputStream_read test doesn&amp;#39;t call shutdownInput() in any code path (and that&amp;#39;s the reason it asserts that read() should never return without throwing a SocketException). So far I haven&amp;#39;t been able to reproduce this on a linux-aarch64 (Neoverse N1) for around 10K runs. I will continue investigating.</comment>
                            <comment id="14721326" author="JIRAUSER21405" created="Tue, 12 Nov 2024 20:35:55 -0800"  >Hi, [~msheppar] All the failure log show messages below:&lt;br/&gt;
&lt;br/&gt;
Failed:&lt;br/&gt;
&amp;nbsp;- Socket.getInputStream().read() returned unexpectedly!! n == -1&lt;br/&gt;
&amp;nbsp;- Socket.getInputStream().read() wasn&amp;#39;t preempted</comment>
                            <comment id="14721259" author="msheppar" created="Tue, 12 Nov 2024 12:56:53 -0800"  >[~syan] could you oblige and modify the run method in the test &lt;br/&gt;
&amp;nbsp;open/test/jdk/java/net/Socket/asyncClose/Socket_getInputStream_read.java&lt;br/&gt;
to add the return value from the read method to the fail message, please &lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int n = in.read();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;failed(&amp;quot;Socket.getInputStream().read() returned unexpectedly!! n == &amp;quot; + n);&lt;br/&gt;
&lt;br/&gt;
and run your tests again to capture this output in a failure scenario. This will provide a hint as to whether a race conditions might be occurring between the close and the read threads. There are a couple of possibilities and this return value will assist in evaluating them, as to whether they are realistic or not.&lt;br/&gt;
&lt;br/&gt;
I have tried to emulate such conditions, but have so far always got the SocketException with socket closed</comment>
                            <comment id="14721093" author="JIRAUSER21405" created="Tue, 12 Nov 2024 03:09:31 -0800"  >Sorry for the mistake. I missed the options &amp;#39;-XX:+UnlockExperimentalVMOptions -XX:CodeCacheSegmentSize=64&amp;#39; for 3.1&lt;br/&gt;
The plus with VM optios for 3.1 should be &amp;#39;-Xcomp -XX:TieredStopAtLevel=1 -XX:+UnlockExperimentalVMOptions -XX:CodeCacheSegmentSize=64&amp;#39;. The default vaule of CodeCacheSegmentSize changed from 128 to 64 by &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt; on linux-aarch64(Neoverse-N2).&lt;br/&gt;
&lt;br/&gt;
That&amp;#39;s the test command I have reproduced the failure on linux-aarch64(Neoverse-N2):&lt;br/&gt;
&lt;br/&gt;
export test=test/jdk/java/net/Socket/asyncClose/AsyncClose.java&lt;br/&gt;
function runJtreg() { jtreg -XX:+UnlockExperimentalVMOptions -XX:CodeCacheSegmentSize=64 -jdk:build/linux-aarch64-server-release/images/jdk -J-Djavatest.maxOutputSize=999999999 -javaoptions:&amp;quot;-Xcomp -XX:TieredStopAtLevel=1&amp;quot; -ea -esa -timeoutFactor:4 -v:fail,error,time,nopass -nr -w $dir/index-$1 $test &amp;amp;&amp;gt; $dir/$1.log ; if [[ 0 -ne $? ]] ; then echo -n &amp;quot;$1 &amp;quot; ;else rm -rf $dir/index-$1 $dir/$1.log ; fi ; } ; export -f runJtreg ; export dir=&amp;quot;tmp-jtreg-&amp;quot;`basename ${test##* } .java | sed &amp;quot;s|#|_|&amp;quot;` ; rm -rf $dir ; mkdir -p $dir ; time seq 500 | xargs -i -n 1 -P `nproc` bash -c &amp;quot;runJtreg {}&amp;quot; ; echo total fail number: `ls $dir/*.log 2&amp;gt; /dev/null | wc | awk &amp;#39;{print $1}&amp;#39;`</comment>
                            <comment id="14721085" author="jpai" created="Tue, 12 Nov 2024 02:29:02 -0800"  >I&amp;#39;m still trying to reproduce this and investigate, but I just noticed that you noted:&lt;br/&gt;
&lt;br/&gt;
&amp;gt; 3.1 I have runned this test on linux-aarch64 500 times with JDK which building from revert the commit of &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt;(git revert d8430efb5e159b8e08d2cac66b46cb4ff1112927) plus with VM option &amp;#39;-Xcomp -XX:TieredStopAtLevel=1&amp;#39;, fail probability is about: 100/500 &lt;br/&gt;
&lt;br/&gt;
So the test has been failing intermittently even without the changes in &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt;. So this really isn&amp;#39;t a regression due to that change. I&amp;#39;ll investigate a bit more to see if we should improve this test when it comes to timing expectations, but first I would like it to reproduce locally to understand why exactly it&amp;#39;s failing.</comment>
                            <comment id="14721066" author="msheppar" created="Tue, 12 Nov 2024 01:47:46 -0800"  >If the local version of the test output the return value from the read, it would allow additional diagnostic reasoning&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int n = in.read();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;failed(&amp;quot;Socket.getInputStream().read() returned unexpectedly!! n == &amp;quot;  + n);&lt;br/&gt;
&lt;br/&gt;
if n == -1, suggests a race condition, n == 0, suggests spurious wakeup in the read, n &amp;gt; 0 suggest the socket accidentally connected to some other concurrently execution server</comment>
                            <comment id="14721041" author="JIRAUSER21405" created="Tue, 12 Nov 2024 00:15:51 -0800"  >&amp;quot;Are the intermittent failures always in the Socket_getInputStream_read scenario? None of the other test scenario are generating intermittent failures?&amp;quot;&lt;br/&gt;
The answer is Yes, only the &amp;#39;Socket.getInputStream().read()&amp;#39; was observed this intermittent fails.</comment>
                            <comment id="14720943" author="msheppar" created="Mon, 11 Nov 2024 15:36:19 -0800"  >So there are a couple of questions wrt the failures ... are  the intermittent failures always in the Socket_getInputStream_read scenario? None of the other test scenario are generating intermittent failures?&lt;br/&gt;
&lt;br/&gt;
If we look at the objective of this scenario: to invoke a socket close in one thread while another thread is reading from that socket&amp;#39;s input stream. &lt;br/&gt;
&lt;br/&gt;
To achieve this the threads must execute in a deterministic manner, but that is not always possible. As such the observation is that the Socket_getInputStream_read.go thread, executing the close, races ahead of the Socket_getInputStream_read reader thread (run method), but only after the threads have synchronised on the CountDownLatch, and even though the Socket_getInputStream_read.go thread sleeps after the CountDownLatch await. This would suggest that the reader thread is being preempted by the OS after the countdown operation. Further suggesting that the -Xcomp option maybe impacting the CountDownLatch (?).&lt;br/&gt;
&lt;br/&gt;
One possibility in the failure test environment, is to experiment by slightly altering the test execution.&lt;br/&gt;
That is,  to invert the operations performed by the two threads:&lt;br/&gt;
the Socket_getInputStream_read.go thread becomes the reader and the run thread becomes the closer. The objective here is that Socket_getInputStream_read.go thread, which currently is observed to race ahead the reader thread, will invoke the input stream read before the run thread invokes the Socket:: close(). Based on the observed execution bias of the two threads the go should, consistently, get to the input stream read before the run thread invokes close. The objective with this change, is to enhance the deterministic behaviour of the test (even though it is non deterministic), such that the read is invoked before the close.&lt;br/&gt;
&lt;br/&gt;
Alternatively, we will still observe intermittent failures in with the go thread performing the read, which may suggest that -Xcomp is impacting the behaviour of the CountDownLatch.&lt;br/&gt;
&lt;br/&gt;
possible change to test is as below:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void run() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;closeReaderSocket();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public AsyncCloseTest go() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;InetAddress lh = InetAddress.getLocalHost();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ServerSocket ss = new ServerSocket(0, 0, lh);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s.connect( new InetSocketAddress(lh, ss.getLocalPort()) );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Socket s2 = ss.accept();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread thr = new Thread(this);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thr.start();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;readFromSocketInputStream();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//latch.await();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Thread.sleep(5000); //sleep, so Socket.getInputStream().read() can block&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//s.close();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thr.join();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (isClosed()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return passed();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return failed(&amp;quot;Socket.getInputStream().read() wasn&amp;#39;t preempted&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (Exception x) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;failed(x.getMessage());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw new RuntimeException(x);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void closeReaderSocket () {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;closeReaderSocket: ENTER in thread &amp;quot; + Thread.currentThread().threadId());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;latch.await();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(5000); //sleep, so Socket.getInputStream().read() can block&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s.close();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (Exception ex) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;closeReadSocket ... ex caught &amp;quot; );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ex.printStackTrace();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void readFromSocketInputStream () {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;InputStream in = s.getInputStream();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (timeout &amp;gt; 0) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s.setSoTimeout(timeout);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;latch.countDown();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int n = in.read();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;failed(&amp;quot;Socket.getInputStream().read() returned unexpectedly!!&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (SocketException se) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (latch.getCount() != 1) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;closed();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (Exception e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;failed(e.getMessage());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} finally {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (latch.getCount() == 1) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;latch.countDown();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14720702" author="jpai" created="Mon, 11 Nov 2024 04:31:09 -0800"  >Thank you for running those tests. It&amp;#39;s interesting that the linked commit appears to be involved in these failures. I&amp;#39;ll assign this to myself and take a deeper look.</comment>
                            <comment id="14720611" author="JIRAUSER21405" created="Sun, 10 Nov 2024 22:33:19 -0800"  >cpu information:&lt;br/&gt;
&amp;gt; lscpu &lt;br/&gt;
Architecture:        aarch64&lt;br/&gt;
Byte Order:          Little Endian&lt;br/&gt;
CPU(s):              64&lt;br/&gt;
On-line CPU(s) list: 0-63&lt;br/&gt;
Thread(s) per core:  1&lt;br/&gt;
Core(s) per socket:  64&lt;br/&gt;
Socket(s):           1&lt;br/&gt;
NUMA node(s):        1&lt;br/&gt;
Vendor ID:           ARM&lt;br/&gt;
Model:               0&lt;br/&gt;
Model name:          Neoverse-N2&lt;br/&gt;
Stepping:            r0p0&lt;br/&gt;
CPU MHz:             3000.000&lt;br/&gt;
CPU max MHz:         3000.0000&lt;br/&gt;
CPU min MHz:         3000.0000&lt;br/&gt;
BogoMIPS:            100.00&lt;br/&gt;
L1d cache:           64K&lt;br/&gt;
L1i cache:           64K&lt;br/&gt;
L2 cache:            1024K&lt;br/&gt;
L3 cache:            65536K&lt;br/&gt;
NUMA node0 CPU(s):   0-63&lt;br/&gt;
Flags:               fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma lrcpc dcpop sha3 sm3 sm4 asimddp sha512 sve asimdfhm dit uscat ilrcpc flagm ssbs sb dcpodp sve2 sveaes svepmull svebitperm svesha3 svesm4 flagm2 frint svei8mm svebf16 i8mm bf16 dgh</comment>
                            <comment id="14720610" author="JIRAUSER21405" created="Sun, 10 Nov 2024 22:29:53 -0800"  >Before &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt;:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;uintx CodeCacheSegmentSize                     = 128                               {pd experimental} {default}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;intx CodeEntryAlignment                       = 64                                {pd experimental} {default}&lt;br/&gt;
&lt;br/&gt;
After &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt;:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;uintx CodeCacheSegmentSize                     = 64                                {pd experimental} {default}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;intx CodeEntryAlignment                       = 64                                {pd experimental} {default}</comment>
                            <comment id="14720599" author="JIRAUSER21405" created="Sun, 10 Nov 2024 22:00:12 -0800"  >Hi [~jpai],&lt;br/&gt;
1. I have runned this test on linux-x64 10k times with JDK builded after commit of &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt; and all passed.&lt;br/&gt;
2. I have runned this test on linux-aarch64 500 times with JDK builded after commit of &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt;, the failure probability is about 50/500.&lt;br/&gt;
3. I have runned this test on linux-aarch64 10k times with JDK which building from revert the commit of &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt;(git revert d8430efb5e159b8e08d2cac66b46cb4ff1112927), 10k times test all passed.&lt;br/&gt;
&amp;nbsp;3.1 I have runned this test on linux-aarch64 500 times with JDK which building from revert the commit of &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt;(git revert d8430efb5e159b8e08d2cac66b46cb4ff1112927) plus with VM option &amp;#39;-Xcomp -XX:TieredStopAtLevel=1 -XX:+UnlockExperimentalVMOptions -XX:CodeCacheSegmentSize=64&amp;#39;, fail probability is about: 100/500</comment>
                            <comment id="14720582" author="jpai" created="Sun, 10 Nov 2024 20:14:37 -0800"  >Hello [~syan]&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Maybe a regress issue caused by &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Is this only failing on aarch64? Does building a JDK by reverting the commit in &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt; and re-running the test, make the test consistently pass? </comment>
                            <comment id="14720574" author="JIRAUSER21405" created="Sun, 10 Nov 2024 19:44:48 -0800"  >Maybe a regress issue caused by &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8339573&quot; title=&quot;Update CodeCacheSegmentSize and CodeEntryAlignment for ARM&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8339573&quot;&gt;&lt;strike&gt;JDK-8339573&lt;/strike&gt;&lt;/a&gt;</comment>
                            <comment id="14720554" author="JIRAUSER21405" created="Sun, 10 Nov 2024 18:25:58 -0800"  >Change timeout value from 20000 to 120000, and change sleep time from 5000 to 25000, like below, also triggrt the same intermittent fails&lt;br/&gt;
&lt;br/&gt;
diff --git a/test/jdk/java/net/Socket/asyncClose/AsyncClose.java b/test/jdk/java/net/Socket/asyncClose/AsyncClose.java&lt;br/&gt;
index 8e465a783a5..f7a919aeb68 100644&lt;br/&gt;
--- a/test/jdk/java/net/Socket/asyncClose/AsyncClose.java&lt;br/&gt;
+++ b/test/jdk/java/net/Socket/asyncClose/AsyncClose.java&lt;br/&gt;
@@ -34,7 +34,7 @@&lt;br/&gt;
&amp;nbsp;&amp;nbsp;* @summary Check that {Socket,ServerSocket,DatagramSocket}.close will&lt;br/&gt;
&amp;nbsp;&amp;nbsp;*          cause any thread blocked on the socket to throw a SocketException.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;* @run main AsyncClose&lt;br/&gt;
- * @run main/othervm -Djava.net.preferIPv4Stack=true AsyncClose&lt;br/&gt;
+ * @run main/othervm/timeout=240 -Djava.net.preferIPv4Stack=true AsyncClose&lt;br/&gt;
&amp;nbsp;&amp;nbsp;*/&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;public class AsyncClose {&lt;br/&gt;
@@ -44,12 +44,12 @@ public static void main(String args[]) throws Exception {&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;AsyncCloseTest tests[] = {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new Socket_getInputStream_read(),&lt;br/&gt;
-            new Socket_getInputStream_read(20000),&lt;br/&gt;
+            new Socket_getInputStream_read(120000),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new Socket_getOutputStream_write(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new DatagramSocket_receive(),&lt;br/&gt;
-            new DatagramSocket_receive(20000),&lt;br/&gt;
+            new DatagramSocket_receive(120000),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new ServerSocket_accept(),&lt;br/&gt;
-            new ServerSocket_accept(20000),&lt;br/&gt;
+            new ServerSocket_accept(120000),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int failures = 0;&lt;br/&gt;
diff --git a/test/jdk/java/net/Socket/asyncClose/Socket_getInputStream_read.java b/test/jdk/java/net/Socket/asyncClose/Socket_getInputStream_read.java&lt;br/&gt;
index f2082fcf374..f044b7cea40 100644&lt;br/&gt;
--- a/test/jdk/java/net/Socket/asyncClose/Socket_getInputStream_read.java&lt;br/&gt;
+++ b/test/jdk/java/net/Socket/asyncClose/Socket_getInputStream_read.java&lt;br/&gt;
@@ -83,7 +83,7 @@ public AsyncCloseTest go() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread thr = new Thread(this);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thr.start();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;latch.await();&lt;br/&gt;
-            Thread.sleep(5000); //sleep, so Socket.getInputStream().read() can block&lt;br/&gt;
+            Thread.sleep(25000); //sleep, so Socket.getInputStream().read() can block&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s.close();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thr.join();&lt;br/&gt;
</comment>
                            <comment id="14720526" author="alanb" created="Sat, 9 Nov 2024 23:58:20 -0800"  >This test has a hardcoded timeout of 5s, maybe this is an issue when running this test with -Xcomp, would be useful to see if increasing that causes the test to pass.</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5144264">JDK-8344528</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5144265">JDK-8344529</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5144266">JDK-8344531</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5144783">JDK-8344963</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5144784">JDK-8344964</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5155205">JDK-8354019</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                                                <inwardlinks description="relates to">
                                                        </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="112073" name="5956.log" size="7844" author="syan" created="Wed, 13 Nov 2024 05:27:19 -0800"/>
                            <attachment id="112066" name="8343877-debugging.patch" size="2741" author="jpai" created="Wed, 13 Nov 2024 00:27:06 -0800"/>
                            <attachment id="111982" name="AsyncClose.java.log" size="11696" author="syan" created="Fri, 8 Nov 2024 17:37:59 -0800"/>
                            <attachment id="112072" name="AsyncClose.jtr" size="9828" author="syan" created="Wed, 13 Nov 2024 05:27:19 -0800"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10000" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>CPU</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="19300"><![CDATA[aarch64]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10005" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>OS</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17023"><![CDATA[linux]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i38ndv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17411"><![CDATA[b25]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="193"><![CDATA[java.net]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>