<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Sat Sep 27 09:36:47 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8325937] runtime/handshake/HandshakeDirectTest.java causes &quot;monitor end should be strictly below the frame pointer&quot; assertion failure on AArch64 </title>
                <link>https://bugs.openjdk.org/browse/JDK-8325937</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>This test fails intermittently (maybe 1 in 50 attempts) in our CI, but so far only on one type of machine (CPU is Arm Neoverse N2). &lt;br/&gt;
&lt;br/&gt;
#&lt;br/&gt;
# A fatal error has been detected by the Java Runtime Environment:&lt;br/&gt;
#&lt;br/&gt;
#  Internal Error (/home/ent-user/jdk_src/src/hotspot/cpu/aarch64/frame_aarch64.cpp:348), pid=1299863, tid=1299905&lt;br/&gt;
#  assert((intptr_t*) result &amp;lt; fp()) failed: monitor end should be strictly below the frame pointer&lt;br/&gt;
#&lt;br/&gt;
# JRE version: OpenJDK Runtime Environment (22.0) (fastdebug build 22-internal-git-57bc96e5c)&lt;br/&gt;
# Java VM: OpenJDK 64-Bit Server VM (fastdebug 22-internal-git-57bc96e5c, mixed mode, compressed oops, compressed class ptrs, g1 gc, linux-aarch64)&lt;br/&gt;
# Problematic frame:&lt;br/&gt;
# V  [libjvm.so+0xb43454]  frame::interpreter_frame_monitor_end() const+0xf4&lt;br/&gt;
#&lt;br/&gt;
&lt;br/&gt;
The full crash dump is attached.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ve also seen this assertion fail once or twice with the same test:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;# assert(has_last_Java_frame()) failed: must have last_Java_sp() when suspended</description>
                <environment></environment>
        <key id="5121554">JDK-8325937</key>
            <summary>runtime/handshake/HandshakeDirectTest.java causes &quot;monitor end should be strictly below the frame pointer&quot; assertion failure on AArch64 </summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://bugs.openjdk.org/images/jbsImages/p2.png">P2</priority>
                        <status id="6" iconUrl="https://bugs.openjdk.org/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="coleenp">Coleen Phillimore</assignee>
                                    <reporter username="ngasson">Nick Gasson</reporter>
                        <labels>
                            <label>aarch64-related</label>
                            <label>amazon-interest</label>
                            <label>intermittent</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>jdk23-defer-request</label>
                            <label>jdk23-defer-yes</label>
                            <label>jdk23u-fix-SQE-ok</label>
                            <label>jdk23u-fix-request</label>
                            <label>jdk23u-fix-yes</label>
                            <label>sync</label>
                    </labels>
                <created>Thu, 15 Feb 2024 01:48:57 -0800</created>
                <updated>Fri, 17 Jan 2025 05:07:23 -0800</updated>
                            <resolved>Thu, 17 Oct 2024 11:11:51 -0700</resolved>
                                    <version>17</version>
                    <version>21</version>
                    <version>22</version>
                    <version>23</version>
                                    <fixVersion>24</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>20</watches>
                                                                                                                <comments>
                            <comment id="14733201" author="roboduke" created="Wed, 18 Dec 2024 02:06:38 -0800"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/3140&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/3140&lt;/a&gt;&lt;br/&gt;
Date: 2024-12-18 10:01:05 +0000</comment>
                            <comment id="14733198" author="goetz" created="Wed, 18 Dec 2024 02:04:49 -0800"  >Fix request [21u,17u]&lt;br/&gt;
&lt;br/&gt;
I backport this for parity with 21.0.7-oracle,17.0.15-oracle.&lt;br/&gt;
Medium risk, fiddling with barriers in core coding. The code is not yet tested in production, but it will be in 23.0.2 and 24 before this is delivered in April 25.&lt;br/&gt;
Clean backport to 21.&lt;br/&gt;
In 17, simple resolve needed.&lt;br/&gt;
Basic hotspot/runtime tests pass. SAP nightly testing passed including linux and mac aarch64.</comment>
                            <comment id="14733173" author="roboduke" created="Wed, 18 Dec 2024 01:36:12 -0800"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/1260&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/1260&lt;/a&gt;&lt;br/&gt;
Date: 2024-12-18 09:30:43 +0000</comment>
                            <comment id="14716249" author="coleenp" created="Wed, 23 Oct 2024 13:21:09 -0700"  >This doesn&amp;#39;t need to be backported to JDK 11 because the Mutex code had a fence() in it then, and the handshake code is also different.</comment>
                            <comment id="14715467" author="roboduke" created="Mon, 21 Oct 2024 15:08:53 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk23u/pull/201&quot;&gt;https://git.openjdk.org/jdk23u/pull/201&lt;/a&gt;&lt;br/&gt;
Date: 2024-10-21 22:00:27 +0000</comment>
                            <comment id="14715466" author="roboduke" created="Mon, 21 Oct 2024 15:08:08 -0700"  >[jdk23u-fix-request] Approval Request from Coleen Phillimore&lt;br/&gt;
Clean backport. Fix is in JDK 24 and was categorized as a P2 but deferred in 23 because we didn&amp;#39;t know the cause and fix yet.</comment>
                            <comment id="14714615" author="dukebot" created="Thu, 17 Oct 2024 11:11:50 -0700"  >Changeset: 83e9e482&lt;br/&gt;
Branch: master&lt;br/&gt;
Author:    Coleen Phillimore &amp;lt;&lt;a href=&apos;mailto:coleenp@openjdk.org&apos;&gt;coleenp@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2024-10-17 18:06:42 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/83e9e482b181e76ca9f645e8cc83cfa9337df498&quot;&gt;https://git.openjdk.org/jdk/commit/83e9e482b181e76ca9f645e8cc83cfa9337df498&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14709764" author="pchilanomate" created="Wed, 2 Oct 2024 07:00:31 -0700"  >&amp;gt; [~pchilanomate] I know that one: on the fast path there&amp;#39;s a casa, which is an acquire but not a release or a full fence.&lt;br/&gt;
Thanks [~aph], then we are missing a StoreLoad fence.</comment>
                            <comment id="14709741" author="aph" created="Wed, 2 Oct 2024 05:44:52 -0700"  >&amp;gt; See my PR. The comment was right above the UseSystemMemoryBarrier conditional in one case and describes what we found. Edit: &amp;gt; Sorry looks like you have seen the PR...&lt;br/&gt;
&lt;br/&gt;
Oh, I see. Yes, I did see that.&lt;br/&gt;
&lt;br/&gt;
So there isn&amp;#39;t a simple synchronisng memory location: there&amp;#39;s a queue push, followed by a full fence. Then the other thread reads from the queue, then writes the JavaThread state. After the full fence, we&amp;#39;re safe to read the JavaThread state.</comment>
                            <comment id="14709737" author="coleenp" created="Wed, 2 Oct 2024 05:15:39 -0700"  >See my PR.  The comment was right above the UseSystemMemoryBarrier conditional in one case and describes what we found. Edit: Sorry looks like you have seen the PR...</comment>
                            <comment id="14709706" author="aph" created="Wed, 2 Oct 2024 01:34:30 -0700"  >[~coleenp] Ah, I don&amp;#39;t realize it was commented. Fair enough. Can you tell me where that comment is, thanks.</comment>
                            <comment id="14709705" author="aph" created="Wed, 2 Oct 2024 01:32:59 -0700"  >[~pchilanomate] I know that one: on the fast path there&amp;#39;s a casa, which is an acquire but not a release or a full fence.</comment>
                            <comment id="14709662" author="pchilanomate" created="Tue, 1 Oct 2024 21:16:23 -0700"  >[~ngasson] Just to double check this missing fence is indeed the issue, could you step through pthread_mutex_trylock and check the instructions we are executing? There should not be a full memory fence being executed.</comment>
                            <comment id="14709579" author="roboduke" created="Tue, 1 Oct 2024 11:46:13 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/21295&quot;&gt;https://git.openjdk.org/jdk/pull/21295&lt;/a&gt;&lt;br/&gt;
Date: 2024-10-01 18:38:33 +0000</comment>
                            <comment id="14709571" author="coleenp" created="Tue, 1 Oct 2024 11:32:15 -0700"  >I agree with you.There are a lot of and a variety of different fences and I spent weeks looking for the missing one.  Most of the things we&amp;#39;re looking at in this safepoint code have load_acquire/release_store accesses (thread_state, for example) so it seemed like the right things were protected as if volatile.  I don&amp;#39;t know of how to make this safer though.  For the record, there was actually a comment that said exactly what was happening so I don&amp;#39;t have to add one.</comment>
                            <comment id="14709530" author="aph" created="Tue, 1 Oct 2024 09:39:57 -0700"  >No, I&amp;#39;m not really saying that, it&amp;#39;s more that there&amp;#39;s a lot of fencing going on, and because fences are not always associated with the things they&amp;#39;re supposed to be ordering it&amp;#39;s very difficult to reason about happens-before relationships. If you see an OrderAccess::fence you can&amp;#39;t see what is ordered with what else.&lt;br/&gt;
&lt;br/&gt;
If, instead of explicit fence instructions, we used sequentially-consistent loads and stores (i.e. the same as Java&amp;#39;s volatile) it&amp;#39;d be a lot easier to reason about what&amp;#39;s going on. I&amp;#39;m not suggesting we change everything though, just food for thought.</comment>
                            <comment id="14709456" author="coleenp" created="Tue, 1 Oct 2024 06:13:07 -0700"  >[~aph] So are you saying that the release() in SafepointMechanism::arm_local_poll_release(_handshakee);&lt;br/&gt;
&amp;nbsp;in add_operation() is unnecessary since we have a full fence just afterwards?&lt;br/&gt;
&lt;br/&gt;
I think it might be still needed.  We push to the queue, release, then arm the poll.  We want the handshakee to see these in the right order.</comment>
                            <comment id="14709402" author="aph" created="Tue, 1 Oct 2024 02:40:11 -0700"  >Great catch, Patricio.&lt;br/&gt;
&lt;br/&gt;
My 2c:&lt;br/&gt;
&lt;br/&gt;
One problem, as I see it, is that naked memory fences are disconnected from the operations they&amp;#39;re intended to separate, making it hard for programmers to reason about them. I think we at least need comments on such fences to say what they&amp;#39;re intended to separate.&lt;br/&gt;
&lt;br/&gt;
Re the question of what we&amp;#39;d choose to do today.&lt;br/&gt;
There is a full fence (because of the memory_order_conservative sledgehammer) fence after add_operation() pushes onto the queue. There is then a release (i.e. LoadStore|StoreStore) fence before the operations in arm_local_poll_release(). It doesn&amp;#39;t seem to make vary much sense to use heroic efforts to avoid another StoreLoad, especially given that modern hardware speculates past fence instructions anyway.</comment>
                            <comment id="14709315" author="dholmes" created="Mon, 30 Sep 2024 21:55:14 -0700"  >Hmmm okay so I refreshed myself on SMB. It is intended to be a one-sided sledge-hammer &amp;quot;memory barrier&amp;quot; to try to speed up native transitions by removing the need for membars on all the paths. I have to wonder though, if the fence had been present when this was being looked at, would we have actually gone down this path? &lt;br/&gt;
&lt;br/&gt;
Anyway just a rhetorical question, as we will use one or the other. Thanks [~pchilanomate]</comment>
                            <comment id="14709308" author="pchilanomate" created="Mon, 30 Sep 2024 20:53:06 -0700"  >So when UseSystemMemoryBarrier is enabled we actually need to call SystemMemoryBarrier::emit() since a full memory fence is not enough. That makes a syscall which essentially generates an interprocessor interrupt to each cpu currently running a thread that belongs to the current process.</comment>
                            <comment id="14709278" author="dholmes" created="Mon, 30 Sep 2024 17:42:24 -0700"  >[~pchilanomate] but if we always had the full fence as being proposed then the SystemMemoryBarrier code would never have been put here - right? That is what I meant by incorrect.&lt;br/&gt;
&lt;br/&gt;
Surprising this went unnoticed for so long if the safepoint code does the right thing.</comment>
                            <comment id="14709262" author="pchilanomate" created="Mon, 30 Sep 2024 16:12:52 -0700"  >[~dholmes] The conditional call to SystemMemoryBarrier::emit() added when UseSystemMemoryBarrier is enabled was correct. The problem is that we were always missing a StoreLoad fence even before the 8292591 changes (and now when UseSystemMemoryBarrier is false). We need a StoreLoad between arming the poll in HandshakeState::add_operation() and reading the target&amp;#39;s state in HandshakeState::try_process(). Otherwise we could read a safepoint safe state before arming the poll on the target, so the target can transition out without noticing the operation. The assumption is that if we read a safepoint safe state it will be safe to execute the handshake because when the target transitions out of that state it will see the poll armed. But if those get reorder the target can escape the handshake. &lt;br/&gt;
We are already doing the right thing for safepoint operations. In SafepointSynchronize::arm_safepoint(), after arming the polls we execute a fence which prevents subsequents reads of thread states to float up.</comment>
                            <comment id="14709259" author="dholmes" created="Mon, 30 Sep 2024 15:20:22 -0700"  >Or is it just another case where we have dubious h/w behaviour and sticking in a full fence tends to fix it?</comment>
                            <comment id="14709258" author="dholmes" created="Mon, 30 Sep 2024 15:18:59 -0700"  >So the conditional &amp;quot;memory barrier&amp;quot; that was put in here is actually incorrect as we need a fence regardless?</comment>
                            <comment id="14709196" author="coleenp" created="Mon, 30 Sep 2024 10:26:48 -0700"  >Thank you [~ngasson].  This does seem like the missing fence instructions where reads could leak up to before the safepoint poll is armed. Thanks to [~pchilanomate] for figuring this out.&lt;br/&gt;
</comment>
                            <comment id="14709166" author="ngasson" created="Mon, 30 Sep 2024 09:08:37 -0700"  >I ran the test 10000 times with the above patch and saw no failures (whereas it would reliably fail with that many iterations previously).</comment>
                            <comment id="14708512" author="coleenp" created="Fri, 27 Sep 2024 11:34:26 -0700"  >[~ngasson] Can you try the following patch to see if it still reproduces?  [~pchilanomate] noticed a missing StoreLoad fence in the handshaking code.&lt;br/&gt;
&lt;br/&gt;
diff --git a/src/hotspot/share/runtime/handshake.cpp b/src/hotspot/share/runtime/handshake.cpp&lt;br/&gt;
index 3919a89789c..dc86ccb0d58 100644&lt;br/&gt;
--- a/src/hotspot/share/runtime/handshake.cpp&lt;br/&gt;
+++ b/src/hotspot/share/runtime/handshake.cpp&lt;br/&gt;
@@ -253,6 +253,8 @@ class VM_HandshakeAllThreads: public VM_Operation {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (UseSystemMemoryBarrier) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SystemMemoryBarrier::emit();&lt;br/&gt;
+    } else {&lt;br/&gt;
+      OrderAccess::fence(); // storestore|storeload, global state -&amp;gt; local state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (number_of_threads_issued &amp;lt; 1) {&lt;br/&gt;
@@ -380,6 +382,8 @@ void Handshake::execute(HandshakeClosure* hs_cl, ThreadsListHandle* tlh, JavaThr&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;// the read of JavaThread state in the try_process() call below.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;if (UseSystemMemoryBarrier) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SystemMemoryBarrier::emit();&lt;br/&gt;
+  } else {&lt;br/&gt;
+    OrderAccess::fence(); // storestore|storeload, global state -&amp;gt; local state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;// Keeps count on how many of own emitted handshakes&lt;br/&gt;
</comment>
                            <comment id="14706344" author="dlong" created="Thu, 19 Sep 2024 16:53:30 -0700"  >Regarding the monitor end fp() assert, that is on an interpreter frame, but the target thread of the handshake has a compiled anchor frame.  That means fp() isn&amp;#39;t coming from the anchor, it&amp;#39;s coming from someplace like frame::sender_for_compiled_frame() or sender_for_interpreter_frame(), depending on how far from the top frame we got before crashing.  It should be fine for the anchor _fp to be 0 or even a random value from C2 when PreserveFramePointer is off.</comment>
                            <comment id="14706226" author="coleenp" created="Thu, 19 Sep 2024 05:30:58 -0700"  >In Nick&amp;#39;s last stack trace the assert was for SP not FP (so confusing):&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;error_msg=error_msg@entry=0xe287d4432b30 &amp;quot;assert(has_last_Java_frame()) failed&amp;quot;, detail_fmt=detail_fmt@entry=0xe287d4433800 &amp;quot;must have last_Java_sp() when suspended&amp;quot;)&lt;br/&gt;
&lt;br/&gt;
But in gdb when he printed the JavaFrameAnchor for the failing thread, it was set:&lt;br/&gt;
&lt;br/&gt;
gdb) p ((JavaThread*)0xe2876000b3c0)-&amp;gt;_anchor&lt;br/&gt;
$5 = {_last_Java_sp = 0xe287ac2b1fb0, _last_Java_pc = 0xe287c91593fc &amp;quot;&amp;quot;, _last_Java_fp = 0x0}&lt;br/&gt;
&lt;br/&gt;
Which is why we&amp;#39;re looking at the memory barriers.  But the store_release of thread_state is after setting last_Java_sp (SP!) in the handshakee, so the handshaking thread reads the thread_state and should see the right value for last_Java_sp.  Certainly not null.&lt;br/&gt;
&lt;br/&gt;
handshakee:    str into _last_Java_sp, store_release(thread_state, thread_in_blocked or some other safe state)&lt;br/&gt;
handshaker:    load_acquire(thread_state) to see if it&amp;#39;s safe to walk, make_walkable (which only sets pc if sp is set), load_acquire _last_Java_sp, which is probably not needed.&lt;br/&gt;
&lt;br/&gt;
The handshaker thread should see last_Java_sp unless the memory barriers don&amp;#39;t work.  We don&amp;#39;t know why we only see this on Neoverse N2.  Making me suspicious.</comment>
                            <comment id="14706186" author="aph" created="Thu, 19 Sep 2024 02:16:00 -0700"  >&amp;gt; As it should! As Coleen stated when you handshake with a target thread you are expected to be able to do anything with it - that is &amp;gt; the whole point of the handshake, to get it into a safe state for interrogation/interaction. &lt;br/&gt;
&lt;br/&gt;
I understand why you say that, but this port follows x86, which doesn&amp;#39;t set FP either, so I don&amp;#39;t think it&amp;#39;s that.&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14706125" author="dholmes" created="Wed, 18 Sep 2024 19:19:09 -0700"  >&amp;gt; It looks to me like the other side of the handshake is assuming that FP is always set. &lt;br/&gt;
&lt;br/&gt;
As it should! As Coleen stated when you handshake with a target thread you are expected to be able to do anything with it - that is the whole point of the handshake, to get it into a safe state for interrogation/interaction.</comment>
                            <comment id="14705864" author="coleenp" created="Wed, 18 Sep 2024 05:31:14 -0700"  >But for all (most) handshakes and safepoints, we assume that the stacks are readable for Java threads, like if we&amp;#39;re going to do GC or anything (?).  Can we add a stronger barrier in make_walkable ?</comment>
                            <comment id="14705854" author="aph" created="Wed, 18 Sep 2024 05:09:13 -0700"  >Coleen Phillimore added a comment - Yesterday&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I was looking at Nick&amp;#39;s stack trace from 2024-09-02 which is why I was looking at last_Java_sp not last_Java_fp.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; in MacroAssembler::set_last_Java_frame, shouldn&amp;#39;t this be stlr ?&lt;br/&gt;
&lt;br/&gt;
&amp;gt;  str(last_java_sp, Address(rthread, JavaThread::last_Java_sp_offset())); &lt;br/&gt;
&lt;br/&gt;
Set_last_Java_frame is a purely thread-local implementation. stlr is expensive. If we need an async-safe version of  set_last_Java_frame we can have one, but it should be a different function.&lt;br/&gt;
As I said over the years, we need to define in exactly which circumstances it&amp;#39;s legitimate for some other thread to trace our stack, and then we can fix things. But defining every set_last_Java_frame as async-safe is too much of a sledgehammer IMO.</comment>
                            <comment id="14705676" author="coleenp" created="Tue, 17 Sep 2024 11:49:49 -0700"  >&lt;br/&gt;
I was looking at Nick&amp;#39;s stack trace from 2024-09-02 which is why I was looking at last_Java_sp not last_Java_fp.&lt;br/&gt;
&lt;br/&gt;
in MacroAssembler::set_last_Java_frame, shouldn&amp;#39;t this be stlr ?&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;str(last_java_sp, Address(rthread, JavaThread::last_Java_sp_offset()));&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14704534" author="aph" created="Thu, 12 Sep 2024 06:42:02 -0700"  >Anyway, I&amp;#39;ve been running tests on a Neoverse V2 for hours, no luck. I&amp;#39;ll back out for now. Please shout me if there&amp;#39;s anything more I can do.</comment>
                            <comment id="14704532" author="aph" created="Thu, 12 Sep 2024 06:38:52 -0700"  >But with regard to SP not being set,&lt;br/&gt;
&lt;br/&gt;
&amp;gt; &amp;gt; $5 = {_last_Java_sp = 0xe287ac2b1fb0, _last_Java_pc = 0xe287c91593fc &amp;quot;&amp;quot;, _last_Java_fp = 0x0}&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Which it should have put there in the native wrapper for this call:&lt;br/&gt;
&amp;gt;  __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));&lt;br/&gt;
&amp;gt;  __ stlrw(rscratch1, rscratch2); &lt;br/&gt;
&amp;gt; so this should serialize the store to _last_Java_sp, right? This seems to only happen on Neoverse N2. &lt;br/&gt;
&lt;br/&gt;
As long as the thread state has been read by ldar (or something stronger), then the SP has been read, yes.</comment>
                            <comment id="14704531" author="aph" created="Thu, 12 Sep 2024 06:35:56 -0700"  >I apologize in advance if you&amp;#39;re already way past me.&lt;br/&gt;
&lt;br/&gt;
But this is one assertion:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert((intptr_t*) result &amp;lt; fp(),  &amp;quot;monitor end should be strictly below the frame pointer&amp;quot;);&lt;br/&gt;
&lt;br/&gt;
When native code is called from the interpreter, FP is set, but AFAICS when called from a compiled java-native wrapper, it isn&amp;#39;t.&lt;br/&gt;
&lt;br/&gt;
It looks to me like the other side of the handshake is assuming that FP is always set.</comment>
                            <comment id="14704502" author="coleenp" created="Thu, 12 Sep 2024 05:10:03 -0700"  >I believe the assert is because _last_Java_sp isn&amp;#39;t set.  I don&amp;#39;t think it&amp;#39;s asserting on last_Java_fp, even though that&amp;#39;s the only thing that&amp;#39;s null in the debug results that [~ngasson] commented.  We haven&amp;#39;t been able to reproduce it here to find out more detail.</comment>
                            <comment id="14704477" author="aph" created="Thu, 12 Sep 2024 02:50:20 -0700"  >It&amp;#39;s this:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// last_java_fp is optional&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (last_java_fp-&amp;gt;is_valid()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;str(last_java_fp, Address(rthread, JavaThread::last_Java_fp_offset()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
</comment>
                            <comment id="14704359" author="coleenp" created="Wed, 11 Sep 2024 12:28:44 -0700"  >I realized that having access to a core file and builds isn&amp;#39;t going to help me at all.  From your output, the target thread does have last_Java_sp set:&lt;br/&gt;
&lt;br/&gt;
&amp;gt; $5 = {_last_Java_sp = 0xe287ac2b1fb0, _last_Java_pc = 0xe287c91593fc &amp;quot;&amp;quot;, _last_Java_fp = 0x0}&lt;br/&gt;
&lt;br/&gt;
Which it should have put there in the native wrapper for this call:&lt;br/&gt;
&lt;br/&gt;
&amp;gt; #15 0x0000e287d40ef540 in Unsafe_GetIntVolatile (env=0xe2876000b7c0, unsafe=&amp;lt;optimized out&amp;gt;, obj=0xe287ac2b1fb8, offset=12) at /home/ent-user/jdk_src/src/hotspot/share/prims/unsafe.cpp:338&lt;br/&gt;
&lt;br/&gt;
In _thread_in_native state it should be safe for the handshake to look at this thread.  _last_Java_sp is set before transitioning to native like:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// Now set thread in native&lt;br/&gt;
&amp;nbsp;&amp;nbsp;__ mov(rscratch1, _thread_in_native);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;__ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;__ stlrw(rscratch1, rscratch2);&lt;br/&gt;
&lt;br/&gt;
so this should serialize the store to _last_Java_sp, right?  This seems to only happen on Neoverse N2.&lt;br/&gt;
&lt;br/&gt;
This code is for coming from the compiler to native, the interpreter code is the same.  If you can get this to fail with the debugger attached &amp;quot;call psf()&amp;quot; on the target thread and that&amp;#39;ll tell you where this comes from.</comment>
                            <comment id="14702341" author="ngasson" created="Mon, 2 Sep 2024 08:21:46 -0700"  >&amp;gt; Can you upload a core file? I want to see this thread (the one in the argument here): &lt;br/&gt;
&lt;br/&gt;
Sorry for the late reply. Do you need the whole set of JVM binaries along with a core dump? Not sure I can upload that much. I have another crash here:&lt;br/&gt;
&lt;br/&gt;
(gdb) bt&lt;br/&gt;
#0  __pthread_kill_implementation (threadid=249070824321312, signo=signo@entry=6, no_tid=no_tid@entry=0) at ./nptl/pthread_kill.c:44&lt;br/&gt;
#1  0x0000e287d4b2f254 in __pthread_kill_internal (signo=6, threadid=&amp;lt;optimized out&amp;gt;) at ./nptl/pthread_kill.c:78&lt;br/&gt;
#2  0x0000e287d4aea67c in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26&lt;br/&gt;
#3  0x0000e287d4ad7130 in __GI_abort () at ./stdlib/abort.c:79&lt;br/&gt;
#4  0x0000e287d3cc9938 in os::abort (dump_core=true, siginfo=&amp;lt;optimized out&amp;gt;, context=&amp;lt;optimized out&amp;gt;) at /home/ent-user/jdk_src/src/hotspot/os/posix/os_posix.cpp:2035&lt;br/&gt;
#5  0x0000e287d417cefc in VMError::report_and_die (id=id@entry=-536870912, message=message@entry=0xe287d4432b30 &amp;quot;assert(has_last_Java_frame()) failed&amp;quot;, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;detail_fmt=detail_fmt@entry=0xe287d4433800 &amp;quot;must have last_Java_sp() when suspended&amp;quot;, detail_args=..., thread=0xe28760021400, pc=pc@entry=0x0, siginfo=siginfo@entry=0x0, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;context=context@entry=0xe287d4a1d0c0 &amp;lt;g_stored_assertion_context&amp;gt;, filename=0xe287d4433828 &amp;quot;/home/ent-user/jdk_src/src/hotspot/os_cpu/linux_aarch64/javaThread_linux_aarch64.cpp&amp;quot;, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lineno=31, size=0) at /home/ent-user/jdk_src/src/hotspot/share/utilities/vmError.cpp:1945&lt;br/&gt;
#6  0x0000e287d417d588 in VMError::report_and_die (thread=&amp;lt;optimized out&amp;gt;, context=context@entry=0xe287d4a1d0c0 &amp;lt;g_stored_assertion_context&amp;gt;, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;filename=filename@entry=0xe287d4433828 &amp;quot;/home/ent-user/jdk_src/src/hotspot/os_cpu/linux_aarch64/javaThread_linux_aarch64.cpp&amp;quot;, lineno=lineno@entry=31, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;message=message@entry=0xe287d4432b30 &amp;quot;assert(has_last_Java_frame()) failed&amp;quot;, detail_fmt=detail_fmt@entry=0xe287d4433800 &amp;quot;must have last_Java_sp() when suspended&amp;quot;, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;detail_args=&amp;lt;error reading variable: Cannot access memory at address 0x8&amp;gt;) at /home/ent-user/jdk_src/src/hotspot/share/utilities/vmError.cpp:1610&lt;br/&gt;
#7  0x0000e287d32cc94c in report_vm_error (file=file@entry=0xe287d4433828 &amp;quot;/home/ent-user/jdk_src/src/hotspot/os_cpu/linux_aarch64/javaThread_linux_aarch64.cpp&amp;quot;, line=line@entry=31, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;error_msg=error_msg@entry=0xe287d4432b30 &amp;quot;assert(has_last_Java_frame()) failed&amp;quot;, detail_fmt=detail_fmt@entry=0xe287d4433800 &amp;quot;must have last_Java_sp() when suspended&amp;quot;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at /home/ent-user/jdk_src/src/hotspot/share/utilities/debug.cpp:193&lt;br/&gt;
#8  0x0000e287d36cca5c in JavaThread::pd_last_frame (this=0xe2876000b3c0) at /home/ent-user/jdk_src/src/hotspot/os_cpu/linux_aarch64/javaThread_linux_aarch64.cpp:31&lt;br/&gt;
#9  0x0000e287d36ccccc in JavaThread::pd_last_frame (this=this@entry=0xe2876000b3c0) at /home/ent-user/jdk_src/src/hotspot/cpu/aarch64/frame_aarch64.inline.hpp:66&lt;br/&gt;
#10 0x0000e287d41d14a4 in JavaThread::last_frame (this=0xe2876000b3c0) at /home/ent-user/jdk_src/src/hotspot/share/runtime/javaThread.hpp:931&lt;br/&gt;
#11 JavaThread::last_java_vframe (reg_map=0xe2875201d6b8, this=0xe2876000b3c0) at /home/ent-user/jdk_src/src/hotspot/share/runtime/javaThread.hpp:933&lt;br/&gt;
#12 ReadMonitorsClosure::do_thread (this=0xe2875201e050, th=0xe2876000b3c0) at /home/ent-user/jdk_src/src/hotspot/share/prims/whitebox.cpp:2196&lt;br/&gt;
#13 0x0000e287d35c00e0 in HandshakeOperation::do_handshake (this=this@entry=0xe2875201dee8, thread=0xe2876000b3c0) at /home/ent-user/jdk_src/src/hotspot/share/runtime/handshake.cpp:326&lt;br/&gt;
#14 0x0000e287d35c0f9c in HandshakeState::try_process (match_op=0xe2875201dee8, this=0xe2876000b978) at /home/ent-user/jdk_src/src/hotspot/share/runtime/handshake.cpp:677&lt;br/&gt;
#15 HandshakeState::try_process (this=0xe2876000b978, match_op=0xe2875201dee8) at /home/ent-user/jdk_src/src/hotspot/share/runtime/handshake.cpp:638&lt;br/&gt;
#16 0x0000e287d35c1354 in Handshake::execute (hs_cl=hs_cl@entry=0xe2875201e050, tlh=tlh@entry=0xe2875201e088, target=0xe2876000b3c0)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at /home/ent-user/jdk_src/src/hotspot/share/runtime/javaThread.hpp:624&lt;br/&gt;
#17 0x0000e287d41c37e0 in WB_HandshakeReadMonitors (env=&amp;lt;optimized out&amp;gt;, wb=&amp;lt;optimized out&amp;gt;, thread_handle=0xe2875201e0c8) at /home/ent-user/jdk_src/src/hotspot/share/prims/whitebox.cpp:2225&lt;br/&gt;
#18 0x0000e287c91586fc in ?? ()&lt;br/&gt;
#19 0x0000e2875201e120 in ?? ()&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
The target thread here 0xe2876000b3c0 is this one:&lt;br/&gt;
&lt;br/&gt;
(gdb) bt&lt;br/&gt;
#0  futex_wait (private=0, expected=2, futex_word=0xe2876000b990) at ../sysdeps/nptl/futex-internal.h:146&lt;br/&gt;
#1  __GI___lll_lock_wait (futex=futex@entry=0xe2876000b990, private=private@entry=0) at ./nptl/lowlevellock.c:49&lt;br/&gt;
#2  0x0000e287d4b3070c in lll_mutex_lock_optimized (mutex=0xe2876000b990) at ./nptl/pthread_mutex_lock.c:48&lt;br/&gt;
#3  ___pthread_mutex_lock (mutex=0xe2876000b990) at ./nptl/pthread_mutex_lock.c:93&lt;br/&gt;
#4  0x0000e287d3c13970 in PlatformMutex::lock (this=0xe2876000b990) at /home/ent-user/jdk_src/src/hotspot/os/posix/mutex_posix.hpp:81&lt;br/&gt;
#5  Mutex::lock_without_safepoint_check (self=&amp;lt;optimized out&amp;gt;, this=&amp;lt;optimized out&amp;gt;) at /home/ent-user/jdk_src/src/hotspot/share/runtime/mutex.cpp:148&lt;br/&gt;
#6  Mutex::lock_without_safepoint_check (this=0xe2876000b988) at /home/ent-user/jdk_src/src/hotspot/share/runtime/mutex.cpp:154&lt;br/&gt;
#7  0x0000e287d35c0aa8 in MutexLockerImpl::MutexLockerImpl (flag=Mutex::SafepointCheckFlag::_no_safepoint_check_flag, mutex=0xe2876000b988, this=&amp;lt;synthetic pointer&amp;gt;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at /home/ent-user/jdk_src/src/hotspot/share/runtime/mutexLocker.hpp:195&lt;br/&gt;
#8  MutexLocker::MutexLocker (flag=Mutex::SafepointCheckFlag::_no_safepoint_check_flag, mutex=0xe2876000b988, this=&amp;lt;synthetic pointer&amp;gt;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at /home/ent-user/jdk_src/src/hotspot/share/runtime/mutexLocker.hpp:230&lt;br/&gt;
#9  HandshakeState::process_by_self (this=this@entry=0xe2876000b978, allow_suspend=allow_suspend@entry=true, check_async_exception=check_async_exception@entry=false)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at /home/ent-user/jdk_src/src/hotspot/share/runtime/handshake.cpp:565&lt;br/&gt;
#10 0x0000e287d3e041a8 in SafepointMechanism::process (thread=thread@entry=0xe2876000b3c0, allow_suspend=allow_suspend@entry=true, check_async_exception=check_async_exception@entry=false)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at /home/ent-user/jdk_src/src/hotspot/share/runtime/safepointMechanism.cpp:159&lt;br/&gt;
#11 0x0000e287d30ec54c in SafepointMechanism::process_if_requested (check_async_exception=false, allow_suspend=true, thread=0xe2876000b3c0)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at /home/ent-user/jdk_src/src/hotspot/share/runtime/safepointMechanism.inline.hpp:83&lt;br/&gt;
#12 SafepointMechanism::process_if_requested_with_exit_check (check_async_exception=false, thread=0xe2876000b3c0)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at /home/ent-user/jdk_src/src/hotspot/share/runtime/safepointMechanism.inline.hpp:88&lt;br/&gt;
#13 ThreadStateTransition::transition_from_native (check_asyncs=true, to=_thread_in_vm, thread=0xe2876000b3c0)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at /home/ent-user/jdk_src/src/hotspot/share/runtime/interfaceSupport.inline.hpp:106&lt;br/&gt;
#14 ThreadInVMfromNative::ThreadInVMfromNative (this=0xe287ac2b1f88, thread=0xe2876000b3c0) at /home/ent-user/jdk_src/src/hotspot/share/runtime/interfaceSupport.inline.hpp:174&lt;br/&gt;
#15 0x0000e287d40ef540 in Unsafe_GetIntVolatile (env=0xe2876000b7c0, unsafe=&amp;lt;optimized out&amp;gt;, obj=0xe287ac2b1fb8, offset=12) at /home/ent-user/jdk_src/src/hotspot/share/prims/unsafe.cpp:338&lt;br/&gt;
#16 0x0000e287c91593fc in ?? ()&lt;br/&gt;
Backtrace stopped: previous frame identical to this frame (corrupt stack?)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
(gdb) p ((JavaThread*)0xe2876000b3c0)-&amp;gt;_anchor &lt;br/&gt;
$5 = {_last_Java_sp = 0xe287ac2b1fb0, _last_Java_pc = 0xe287c91593fc &amp;quot;&amp;quot;, _last_Java_fp = 0x0}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
This was on the JDK 23 release branch, commit 9ad2e63f176364</comment>
                            <comment id="14700060" author="ngasson" created="Thu, 22 Aug 2024 07:50:18 -0700"  >&amp;gt; Please send the exact shell command you used when you reproduced the bug on Neoverse V2. &lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ve been using&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;make exploded-test TEST=&amp;quot;runtime/handshake/HandshakeDirectTest.java&amp;quot; JTREG=&amp;quot;VM_OPTIONS=-XX:-TieredCompilation&amp;quot;&lt;br/&gt;
&lt;br/&gt;
but you should be able to get the jtreg command line from LOG=cmdlines. &lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m not sure if -XX:-TieredCompilation is actually required, that&amp;#39;s just the configuration I saw it in initially.&lt;br/&gt;
</comment>
                            <comment id="14700035" author="coleenp" created="Thu, 22 Aug 2024 05:31:58 -0700"  >Can you upload a core file?  I want to see this thread (the one in the argument here):&lt;br/&gt;
V [libjvm.so+0x18d7a50] WB_HandshakeReadMonitors::ReadMonitorsClosure::do_thread(Thread*)+0x170 (whitebox.cpp:2218)&lt;br/&gt;
&lt;br/&gt;
This thread should be handshake safe.</comment>
                            <comment id="14700033" author="aph" created="Thu, 22 Aug 2024 05:25:23 -0700"  >&amp;gt; Yes it still crashes on the latest master branch (although I got a SIGSEGV this time instead of an assertion failure). Anecdotally it seems less common than when I reported it: I ran the test in a loop 1000 times and got one crash.&lt;br/&gt;
&lt;br/&gt;
So it&amp;#39;s possible that I could run it in GDB, and see what&amp;#39;s happening. I&amp;#39;ll give that a try.&lt;br/&gt;
&lt;br/&gt;
Please send the exact shell command you used when you reproduced the bug on Neoverse V2.</comment>
                            <comment id="14700031" author="ngasson" created="Thu, 22 Aug 2024 05:03:22 -0700"  >&amp;gt; Can you still reproduce this?&lt;br/&gt;
&lt;br/&gt;
Yes it still crashes on the latest master branch (although I got a SIGSEGV this time instead of an assertion failure). Anecdotally it seems less common than when I reported it: I ran the test in a loop 1000 times and got one crash. I&amp;#39;ve attached the full crash log but the stack trace is similar to before:&lt;br/&gt;
&lt;br/&gt;
Current thread (0x0000eec65402db10):  JavaThread &amp;quot;26&amp;quot;               [_thread_in_vm, id=3382752, stack(0x0000eec631e22000,0x0000eec632020000) (2040K)] _threads_hazard_ptr=0x0000eec65400c000, _nested_threads_hazard_ptr_cnt=0&lt;br/&gt;
&lt;br/&gt;
Stack: [0x0000eec631e22000,0x0000eec632020000],  sp=0x0000eec63201d450,  free space=2029k&lt;br/&gt;
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
V  [libjvm.so+0xb179f0]  frame::interpreter_frame_monitor_end() const+0x40  (frame.hpp:257)&lt;br/&gt;
V  [libjvm.so+0x18574dc]  interpretedVFrame::monitors() const+0x1dc  (vframe.cpp:286)&lt;br/&gt;
V  [libjvm.so+0x18d7a50]  WB_HandshakeReadMonitors::ReadMonitorsClosure::do_thread(Thread*)+0x170  (whitebox.cpp:2218)&lt;br/&gt;
V  [libjvm.so+0xcbeb60]  HandshakeOperation::do_handshake(JavaThread*)+0x14c  (handshake.cpp:326)&lt;br/&gt;
V  [libjvm.so+0xcbfa1c]  HandshakeState::try_process(HandshakeOperation*)+0x1fc  (handshake.cpp:677)&lt;br/&gt;
V  [libjvm.so+0xcbfdd4]  Handshake::execute(HandshakeClosure*, ThreadsListHandle*, JavaThread*)+0x180  (handshake.cpp:390)&lt;br/&gt;
V  [libjvm.so+0x18c9ad0]  WB_HandshakeReadMonitors+0x190  (whitebox.cpp:2246)&lt;br/&gt;
J 257  jdk.test.whitebox.WhiteBox.handshakeReadMonitors(Ljava/lang/Thread;)Z (0 bytes) @ 0x0000eec6c859a530 [0x0000eec6c859a480+0x00000000000000b0]&lt;br/&gt;
j  HandshakeDirectTest.run()V+88&lt;br/&gt;
j  java.lang.Thread.runWith(Ljava/lang/Object;Ljava/lang/Runnable;)V+5 java.base&lt;br/&gt;
j  java.lang.Thread.run()V+19 java.base&lt;br/&gt;
v  ~StubRoutines::call_stub 0x0000eec6c8430194&lt;br/&gt;
V  [libjvm.so+0xd87988]  JavaCalls::call_helper(JavaValue*, methodHandle const&amp;amp;, JavaCallArguments*, JavaThread*)+0x484  (javaCalls.cpp:415)&lt;br/&gt;
V  [libjvm.so+0xd87f54]  JavaCalls::call_virtual(JavaValue*, Klass*, Symbol*, Symbol*, JavaCallArguments*, JavaThread*)+0x2c4  (javaCalls.cpp:329)&lt;br/&gt;
V  [libjvm.so+0xd8815c]  JavaCalls::call_virtual(JavaValue*, Handle, Klass*, Symbol*, Symbol*, JavaThread*)+0x6c  (javaCalls.cpp:191)&lt;br/&gt;
V  [libjvm.so+0xef6e34]  thread_entry(JavaThread*, JavaThread*)+0xa0  (jvm.cpp:2910)&lt;br/&gt;
V  [libjvm.so+0xdc1a34]  JavaThread::thread_main_inner()+0x1f0  (javaThread.cpp:758)&lt;br/&gt;
V  [libjvm.so+0x1796cd4]  Thread::call_run()+0xb0  (thread.cpp:225)&lt;br/&gt;
V  [libjvm.so+0x13c7908]  thread_native_entry(Thread*)+0x138  (os_linux.cpp:858)&lt;br/&gt;
C  [libc.so.6+0x7d5c8]&lt;br/&gt;
Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)&lt;br/&gt;
J 257  jdk.test.whitebox.WhiteBox.handshakeReadMonitors(Ljava/lang/Thread;)Z (0 bytes) @ 0x0000eec6c859a530 [0x0000eec6c859a480+0x00000000000000b0]&lt;br/&gt;
j  HandshakeDirectTest.run()V+88&lt;br/&gt;
j  java.lang.Thread.runWith(Ljava/lang/Object;Ljava/lang/Runnable;)V+5 java.base&lt;br/&gt;
j  java.lang.Thread.run()V+19 java.base&lt;br/&gt;
v  ~StubRoutines::call_stub 0x0000eec6c8430194&lt;br/&gt;
&lt;br/&gt;
siginfo: si_signo: 11 (SIGSEGV), si_code: 1 (SEGV_MAPERR), si_addr: 0xffffffffffffffb0&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Was this only on a certain machine? &lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ve seen it on multiple machines but only with certain CPU types: Neoverse N2 and V2.</comment>
                            <comment id="14698369" author="coleenp" created="Wed, 14 Aug 2024 12:57:43 -0700"  >[~ngasson] Can you still reproduce this?  I&amp;#39;ve been looking at a similar bug on JDK 8 because I have a core file for that, but to me now looks different.  I&amp;#39;ve read through the code and the comments here and it seems that setting last_Java_frame() doesn&amp;#39;t matter what order these are written in since the observing thread should have tested the thread_state where memory is synchronized with release_store and load_acquire.  Was this only on a certain machine?  Thanks.</comment>
                            <comment id="14692836" author="kvn" created="Thu, 25 Jul 2024 14:04:10 -0700"  >JDK 23 deferral request approved.</comment>
                            <comment id="14692822" author="lfoltan" created="Thu, 25 Jul 2024 13:29:43 -0700"  >RT Triage: Request for deferral from JDK23.  There is no indication that the issue was introduced or new as a regression in JDK 22. Analysis to date seems to indicate the failure maybe a day one issue with the combination of the JEP 237: Linux/AArch64 support and the interaction of JEP 312: Thread-Local Handshakes (JDK 10) and/or Asynchronous Handshakes support (JDK 16).  More investigation is needed concerning the happens-before relationships between thread states and observers as mentioned by Andrew Haley in the last comment.  Any potential fix at this point for JDK 23 is deemed high risk.</comment>
                            <comment id="14692438" author="kvn" created="Wed, 24 Jul 2024 13:18:56 -0700"  >Need more information for deferral approval.&lt;br/&gt;
1. Request should be public.&lt;br/&gt;
2. Is this old issue (based on comments) or it was introduced in JDK 22 based on &amp;quot;Affected version&amp;quot;?&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14685623" author="aph" created="Fri, 28 Jun 2024 01:18:48 -0700"  >&amp;gt; It is interesting to note that ppc and s390 have barriers in a different order than aarch64. If those barriers are needed, then that implies that we are trying to make it safe to read these values even when the thread is not at a safepoint/handshake. I guess that is for profiler support. &lt;br/&gt;
&lt;br/&gt;
I guess so. This code has bothered me ever since I first saw it, when first doing the AArch64 port. It seemed like a half hearted attempt at trying to make something work, but at the time no one seemed to know what the observers needed and everything seemed to work. In order to make this correct we&amp;#39;d need to define what the happens-before  relationships are between thread states and observers. Maybe it has been defined before, but I&amp;#39;ve never seen it.</comment>
                            <comment id="14685545" author="dlong" created="Thu, 27 Jun 2024 20:17:41 -0700"  >Normally _sp would be written last for set, written first for clear, and read first for has_last_Java_frame(), so acquire would come after reading it, not before.  But there is an optimization that allows _pc to be written lazily after _sp, by make_walkable().  So we would have:&lt;br/&gt;
set _fp&lt;br/&gt;
set _pc&lt;br/&gt;
release()&lt;br/&gt;
set _sp&lt;br/&gt;
&lt;br/&gt;
or with the optimization:&lt;br/&gt;
set_fp&lt;br/&gt;
// _pc is 0 from last reset/clear&lt;br/&gt;
release()&lt;br/&gt;
set _sp&lt;br/&gt;
release() // to allow _pc to be written without a barrier&lt;br/&gt;
&lt;br/&gt;
and for clear:&lt;br/&gt;
set _sp to 0&lt;br/&gt;
release()&lt;br/&gt;
set _pc and _fp to 0&lt;br/&gt;
&lt;br/&gt;
and on the read size:&lt;br/&gt;
read _sp&lt;br/&gt;
acquire()&lt;br/&gt;
read _fp or _pc (which could be 0)&lt;br/&gt;
&lt;br/&gt;
However, as Andrew pointed out, we don&amp;#39;t guarantee asynchronous access like this.  The anchor should be set when the thread state is still _thread_in_Java, and it shouldn&amp;#39;t be read by a different thread until a safepoint/handshake is reached, which would mean the thread state has changed to something like _thread_blocked.  If we follow those rules, then reading and writing these fields shouldn&amp;#39;t need additional barriers.  The barriers are done when changing and reading the thread state.  It is interesting to note that ppc and s390 have barriers in a different order than aarch64.  If those barriers are needed, then that implies that we are trying to make it safe to read these values even when the thread is not at a safepoint/handshake.  I guess that is for profiler support.</comment>
                            <comment id="14685400" author="ngasson" created="Thu, 27 Jun 2024 07:15:39 -0700"  >I tried [~aph]&amp;#39;s suggestion above of a 1000000 iteration spin loop in set_last_Java_frame(). I didn&amp;#39;t see any failures out of 100 attempts, whereas I&amp;#39;d normally get 1-2. Although it did run *very* slowly.&lt;br/&gt;
&lt;br/&gt;
One other thing I tried was:&lt;br/&gt;
&lt;br/&gt;
diff --git a/src/hotspot/share/runtime/javaFrameAnchor.hpp b/src/hotspot/share/runtime/javaFrameAnchor.hpp&lt;br/&gt;
index a0636bc3d..b3221d5af 100644&lt;br/&gt;
--- a/src/hotspot/share/runtime/javaFrameAnchor.hpp&lt;br/&gt;
+++ b/src/hotspot/share/runtime/javaFrameAnchor.hpp&lt;br/&gt;
@@ -75,7 +75,7 @@ friend class UpcallLinker;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;// It is important that when last_Java_sp != nullptr that the rest of the frame&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;// anchor (including platform specific) all be valid.&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
-  bool has_last_Java_frame() const                   { return _last_Java_sp != nullptr; }&lt;br/&gt;
+  bool has_last_Java_frame() const                   { OrderAccess::fence(); bool tmp = _last_Java_sp != nullptr; OrderAccess::fence(); return tmp; }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;// This is very dangerous unless sp == nullptr&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;// Invalidate the anchor so that has_last_frame is false&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;// and no one should look at the other fields.&lt;br/&gt;
&lt;br/&gt;
Which had zero failures in 1000 attempts and perhaps points to a missing barrier somewhere. I tried putting just a OrderAccess::acquire() before the load of _last_java_sp to pair with the release() in set_last_Java_sp() but that isn&amp;#39;t sufficient and I still see crashes. There is also this comment in JavaFrameAnchor::copy():&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_last_Java_fp = src-&amp;gt;_last_Java_fp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_last_Java_pc = src-&amp;gt;_last_Java_pc;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Must be last so profiler will always see valid frame if has_last_frame() is true&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_last_Java_sp = src-&amp;gt;_last_Java_sp;&lt;br/&gt;
&lt;br/&gt;
If the store to _last_Java_sp really must be last then we need a release here too (the PPC port has one).</comment>
                            <comment id="14684969" author="aph" created="Wed, 26 Jun 2024 06:01:28 -0700"  >OK. So let&amp;#39;s see what Nick comes up with, and then we&amp;#39;ll know if the guess that it is the window between set_last_Java_frame() and entering the VM is correct.</comment>
                            <comment id="14684961" author="dholmes" created="Wed, 26 Jun 2024 05:43:11 -0700"  >&amp;gt; If we have a policy about observability between threads, I&amp;#39;d like to know what that is,&lt;br/&gt;
&lt;br/&gt;
It was always the case that safepoints provided sufficient synchronization such that all actions &amp;quot;inside the VM&amp;quot; by a thread that is safepoint-safe can be seen by the thread performing the safepoint op. Handshakes should also enforce that between the handshakee and handshaker. Possibly async handshakes have introduced some gaps but I would hope not.</comment>
                            <comment id="14684958" author="aph" created="Wed, 26 Jun 2024 05:39:23 -0700"  >&lt;a href=&apos;mailto:nick.gasson@arm.com&apos;&gt;nick.gasson@arm.com&lt;/a&gt;, how about you introduce a spin loop (from 0 to 1_000_000, say) at the end of MacroAssembler::set_last_Java_frame(), and see if that increases the failures you see?</comment>
                            <comment id="14684954" author="aph" created="Wed, 26 Jun 2024 05:35:22 -0700"  >&amp;gt; JDK-8087131 was for asynchronous calls to JavaThread::pd_get_top_frame() on &amp;quot;arm&amp;quot;. It looks like aarch64 has a similar check that the anchor is walkable, so this looks like a different bug. This bug seems to be dealing with synchronous safepoints/handshakes, but doing the work in a different thread. Possibly my concerns in 8087131 about possibly missing memory barriers might still apply. I see that MacroAssembler::set_last_Java_frame() does not use a store/release memory barriers between stores, for example, and has_last_Java_frame() does not use a load/acquire barrier. So we appear to be missing release/acquire barriers, unless the safepoint/handshake mechanism is taking care of that.&lt;br/&gt;
&lt;br/&gt;
The target thread is in a futex_wait, which is a full memory barrier, so I guess the observer thread tried to observe the target thread before it hit that.&lt;br/&gt;
&lt;br/&gt;
We could perhaps increase the frequency of this failure by introducing a spin loop in between the Java code and SafepointSynchronize::handle_polling_page_exception. If that makes the fault more common we&amp;#39;ll have found it.&lt;br/&gt;
&lt;br/&gt;
A release at every set_last_Java_frame() would be excessive IMO. Perhaps we can find some more conservative solution? Perhaps a release_set_last_Java_frame().&lt;br/&gt;
&lt;br/&gt;
At no point have we had a policy that all local stack frame manipulation has to be safe for asynchronous threads. And neither should we have, IMO: trying to fix every narrow window for all observers is expensive, so should not be done.&lt;br/&gt;
&lt;br/&gt;
If we have a policy about observability between threads, I&amp;#39;d like to know what that is, and then we can check it. We have to know where exactly the happens-before relationship for the acquires and releases is.</comment>
                            <comment id="14684768" author="dlong" created="Tue, 25 Jun 2024 15:57:24 -0700"  >JDK-8087131 was for asynchronous calls to JavaThread::pd_get_top_frame() on &amp;quot;arm&amp;quot;.  It looks like aarch64 has a similar check that the anchor is walkable, so this looks like a different bug.  This bug seems to be dealing with synchronous safepoints/handshakes, but doing the work in a different thread.  Possibly my concerns in 8087131 about possibly missing memory barriers might still apply.  I see that MacroAssembler::set_last_Java_frame() does not use a store/release memory barriers between stores, for example, and has_last_Java_frame() does not use a load/acquire barrier.  So we appear to be missing release/acquire barriers, unless the safepoint/handshake mechanism is taking care of that.&lt;br/&gt;
&lt;br/&gt;
When SafepointSynchronize::handle_polling_page_exception() calls JavaThread::set_thread_state(), aarch64 does a release store.  And when HandshakeState::try_process() checks the state with JavaThread::thread_state(), it does a load acquire, so all that looks OK.  However, analysis of the crash by [~ngasson] shows the crash stack trace from an interpreter frame, but the target of the handshake appears to be a C2 frame, so something isn&amp;#39;t right there.</comment>
                            <comment id="14684714" author="lfoltan" created="Tue, 25 Jun 2024 12:09:33 -0700"  >[RT Triage] [~dlong] Could this issue be already resolved or duplicated by JDK-8087131?</comment>
                            <comment id="14650923" author="mseledtsov" created="Tue, 20 Feb 2024 11:14:06 -0800"  >ILW = HLH = P2</comment>
                            <comment id="14649593" author="ngasson" created="Thu, 15 Feb 2024 01:51:25 -0800"  >Stack trace of thread where assertion failure occurred:&lt;br/&gt;
&lt;br/&gt;
Thread 42 &amp;quot;18&amp;quot; received signal SIGABRT, Aborted.&lt;br/&gt;
[Switching to Thread 0xffffb0639120 (LWP 1299905)]&lt;br/&gt;
__pthread_kill_implementation (threadid=281473641058592, signo=signo@entry=6, no_tid=no_tid@entry=0) at ./nptl/pthread_kill.c:44&lt;br/&gt;
44      ./nptl/pthread_kill.c: No such file or directory.&lt;br/&gt;
(gdb) bt&lt;br/&gt;
#0  __pthread_kill_implementation (threadid=281473641058592, signo=signo@entry=6, no_tid=no_tid@entry=0) at ./nptl/pthread_kill.c:44&lt;br/&gt;
#1  0x0000fffff7e2f254 in __pthread_kill_internal (signo=6, threadid=&amp;lt;optimized out&amp;gt;) at ./nptl/pthread_kill.c:78&lt;br/&gt;
#2  0x0000fffff7dea67c in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26&lt;br/&gt;
#3  0x0000fffff7dd7130 in __GI_abort () at ./stdlib/abort.c:79&lt;br/&gt;
#4  0x0000fffff6ff3218 in os::abort (dump_core=true, siginfo=&amp;lt;optimized out&amp;gt;, context=&amp;lt;optimized out&amp;gt;) at /home/ent-user/jdk_src/src/hotspot/os/posix/os_posix.cpp:2016&lt;br/&gt;
#5  0x0000fffff747b81c in VMError::report_and_die (id=id@entry=-536870912, message=message@entry=0xfffff76f6bf8 &amp;quot;assert((intptr_t*) result &amp;lt; fp()) failed&amp;quot;, detail_fmt=detail_fmt@entry=0xfffff76f6bc0 &amp;quot;monitor end should be strictly below the frame pointer&amp;quot;, detail_args=..., thread=0xffff880220c0, pc=pc@entry=0x0, siginfo=siginfo@entry=0x0, context=context@entry=0xfffff7d20270 &amp;lt;g_stored_assertion_context&amp;gt;, filename=0xfffff76f6908 &amp;quot;/home/ent-user/jdk_src/src/hotspot/cpu/aarch64/frame_aarch64.cpp&amp;quot;, lineno=348, size=0) at /home/ent-user/jdk_src/src/hotspot/share/utilities/vmError.cpp:1934&lt;br/&gt;
#6  0x0000fffff747bea8 in VMError::report_and_die (thread=&amp;lt;optimized out&amp;gt;, context=context@entry=0xfffff7d20270 &amp;lt;g_stored_assertion_context&amp;gt;, filename=filename@entry=0xfffff76f6908 &amp;quot;/home/ent-user/jdk_src/src/hotspot/cpu/aarch64/frame_aarch64.cpp&amp;quot;, lineno=lineno@entry=348, message=message@entry=0xfffff76f6bf8 &amp;quot;assert((intptr_t*) result &amp;lt; fp()) failed&amp;quot;, detail_fmt=detail_fmt@entry=0xfffff76f6bc0 &amp;quot;monitor end should be strictly below the frame pointer&amp;quot;, detail_args=&amp;lt;error reading variable: Cannot access memory at address 0x8&amp;gt;) at /home/ent-user/jdk_src/src/hotspot/share/utilities/vmError.cpp:1599&lt;br/&gt;
#7  0x0000fffff65dc50c in report_vm_error (file=file@entry=0xfffff76f6908 &amp;quot;/home/ent-user/jdk_src/src/hotspot/cpu/aarch64/frame_aarch64.cpp&amp;quot;, line=line@entry=348, error_msg=error_msg@entry=0xfffff76f6bf8 &amp;quot;assert((intptr_t*) result &amp;lt; fp()) failed&amp;quot;, detail_fmt=detail_fmt@entry=0xfffff76f6bc0 &amp;quot;monitor end should be strictly below the frame pointer&amp;quot;) at /home/ent-user/jdk_src/src/hotspot/share/utilities/debug.cpp:191&lt;br/&gt;
#8  0x0000fffff673345c in frame::interpreter_frame_monitor_end (this=0xffffb0637558) at /home/ent-user/jdk_src/src/hotspot/cpu/aarch64/frame_aarch64.cpp:348&lt;br/&gt;
#9  frame::interpreter_frame_monitor_end (this=this@entry=0xffffb0637558) at /home/ent-user/jdk_src/src/hotspot/cpu/aarch64/frame_aarch64.cpp:344&lt;br/&gt;
#10 0x0000fffff7458320 in interpretedVFrame::monitors (this=0xffff941420a0) at /home/ent-user/jdk_src/src/hotspot/share/runtime/vframe.cpp:282&lt;br/&gt;
#11 0x0000fffff74cdc60 in ReadMonitorsClosure::do_thread (this=0xffffb0638090, th=&amp;lt;optimized out&amp;gt;) at /home/ent-user/jdk_src/src/hotspot/share/prims/whitebox.cpp:2191&lt;br/&gt;
#12 0x0000fffff68da3a0 in HandshakeOperation::do_handshake (this=this@entry=0xffffb0637f28, thread=0xffff8800ace0) at /home/ent-user/jdk_src/src/hotspot/share/runtime/handshake.cpp:326&lt;br/&gt;
#13 0x0000fffff68db25c in HandshakeState::try_process (match_op=0xffffb0637f28, this=0xffff8800b2a0) at /home/ent-user/jdk_src/src/hotspot/share/runtime/handshake.cpp:677&lt;br/&gt;
#14 HandshakeState::try_process (this=0xffff8800b2a0, match_op=0xffffb0637f28) at /home/ent-user/jdk_src/src/hotspot/share/runtime/handshake.cpp:638&lt;br/&gt;
#15 0x0000fffff68db614 in Handshake::execute (hs_cl=hs_cl@entry=0xffffb0638090, tlh=tlh@entry=0xffffb06380c8, target=0xffff8800ace0) at /home/ent-user/jdk_src/src/hotspot/share/runtime/javaThread.hpp:615&lt;br/&gt;
#16 0x0000fffff74bfd10 in WB_HandshakeReadMonitors (env=&amp;lt;optimized out&amp;gt;, wb=&amp;lt;optimized out&amp;gt;, thread_handle=0xffffb0638180) at /home/ent-user/jdk_src/src/hotspot/share/prims/whitebox.cpp:2219&lt;br/&gt;
#17 0x0000ffffed009850 in ?? ()&lt;br/&gt;
Backtrace stopped: previous frame identical to this frame (corrupt stack?)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
(gdb) p *this&lt;br/&gt;
$1 = {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_sp = 0xffffb2a140c0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_offset_sp = -1298054976&lt;br/&gt;
&amp;nbsp;&amp;nbsp;},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;_pc = 0xffffed009850 &amp;quot;\254\203^\370\210\202&amp;quot;,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;_cb = 0xffffed004890,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;_oop_map = 0x0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;_deopt_state = frame::not_deoptimized,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;_on_heap = false,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;_frame_index = -1,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_fp = 0xffffb2a14120,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_offset_fp = -1298054880&lt;br/&gt;
&amp;nbsp;&amp;nbsp;},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_unextended_sp = 0xffffb2a140c0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_offset_unextended_sp = -1298054976&lt;br/&gt;
&amp;nbsp;&amp;nbsp;},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;_sp_is_trusted = true&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
(gdb) p/x this-&amp;gt;_fp[interpreter_frame_monitor_block_top_offset]&lt;br/&gt;
$7 = 0xffffb2a14208&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
And the target thread of the handshake:&lt;br/&gt;
&lt;br/&gt;
#0  futex_wait (private=0, expected=2, futex_word=0xffff8800b2b8) at ../sysdeps/nptl/futex-internal.h:146&lt;br/&gt;
#1  __GI___lll_lock_wait (futex=futex@entry=0xffff8800b2b8, private=private@entry=0) at ./nptl/lowlevellock.c:49&lt;br/&gt;
#2  0x0000fffff7e3070c in lll_mutex_lock_optimized (mutex=0xffff8800b2b8) at ./nptl/pthread_mutex_lock.c:48&lt;br/&gt;
#3  ___pthread_mutex_lock (mutex=0xffff8800b2b8) at ./nptl/pthread_mutex_lock.c:93&lt;br/&gt;
#4  0x0000fffff6f3f7a0 in PlatformMutex::lock (this=0xffff8800b2b8) at /home/ent-user/jdk_src/src/hotspot/os/posix/mutex_posix.hpp:81&lt;br/&gt;
#5  Mutex::lock_without_safepoint_check (self=&amp;lt;optimized out&amp;gt;, this=&amp;lt;optimized out&amp;gt;) at /home/ent-user/jdk_src/src/hotspot/share/runtime/mutex.cpp:147&lt;br/&gt;
#6  Mutex::lock_without_safepoint_check (this=0xffff8800b2b0) at /home/ent-user/jdk_src/src/hotspot/share/runtime/mutex.cpp:153&lt;br/&gt;
#7  0x0000fffff68dad68 in MutexLockerImpl::MutexLockerImpl (flag=Mutex::SafepointCheckFlag::_no_safepoint_check_flag, mutex=0xffff8800b2b0, this=&amp;lt;synthetic pointer&amp;gt;) at /home/ent-user/jdk_src/src/hotspot/share/runtime/mutexLocker.hpp:197&lt;br/&gt;
#8  MutexLocker::MutexLocker (flag=Mutex::SafepointCheckFlag::_no_safepoint_check_flag, mutex=0xffff8800b2b0, this=&amp;lt;synthetic pointer&amp;gt;) at /home/ent-user/jdk_src/src/hotspot/share/runtime/mutexLocker.hpp:232&lt;br/&gt;
#9  HandshakeState::process_by_self (this=this@entry=0xffff8800b2a0, allow_suspend=allow_suspend@entry=true, check_async_exception=check_async_exception@entry=true) at /home/ent-user/jdk_src/src/hotspot/share/runtime/handshake.cpp:565&lt;br/&gt;
#10 0x0000fffff712d518 in SafepointMechanism::process (thread=thread@entry=0xffff8800ace0, allow_suspend=allow_suspend@entry=true, check_async_exception=check_async_exception@entry=true) at /home/ent-user/jdk_src/src/hotspot/share/runtime/safepointMechanism.cpp:159&lt;br/&gt;
#11 0x0000fffff7126700 in SafepointMechanism::process_if_requested (check_async_exception=true, allow_suspend=true, thread=0xffff8800ace0) at /home/ent-user/jdk_src/src/hotspot/share/runtime/safepointMechanism.inline.hpp:83&lt;br/&gt;
#12 SafepointMechanism::process_if_requested_with_exit_check (check_async_exception=true, thread=0xffff8800ace0) at /home/ent-user/jdk_src/src/hotspot/share/runtime/safepointMechanism.inline.hpp:88&lt;br/&gt;
#13 ThreadSafepointState::handle_polling_page_exception (this=&amp;lt;optimized out&amp;gt;) at /home/ent-user/jdk_src/src/hotspot/share/runtime/safepoint.cpp:962&lt;br/&gt;
#14 0x0000fffff7126bd0 in SafepointSynchronize::handle_polling_page_exception (thread=0xffff8800ace0) at /home/ent-user/jdk_src/src/hotspot/share/runtime/safepoint.cpp:778&lt;br/&gt;
#15 0x0000ffffed0d8c50 in ?? ()&lt;br/&gt;
&lt;br/&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5146715">JDK-8346630</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5146842">JDK-8346747</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5131241">JDK-8333736</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5142310">JDK-8342908</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5142318">JDK-8342916</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10002">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="5136974">JDK-8338561</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5140687">JDK-8341544</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5030558">JDK-8253611</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5147563">JDK-8347301</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="108289" name="hs_err_pid1299863.log" size="259352" author="ngasson" created="Thu, 15 Feb 2024 01:48:42 -0800"/>
                            <attachment id="110749" name="hs_err_pid3382703.log" size="386665" author="ngasson" created="Thu, 22 Aug 2024 05:03:53 -0700"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10000" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>CPU</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="19300"><![CDATA[aarch64]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10005" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>OS</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17023"><![CDATA[linux]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i350f7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17412"><![CDATA[b21]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="192"><![CDATA[runtime]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10100" key="com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons">
                        <customfieldname>Verification</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17000"><![CDATA[Verified]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>