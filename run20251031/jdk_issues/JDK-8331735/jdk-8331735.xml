<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Sat Sep 27 09:42:40 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8331735] UpcallLinker::on_exit races with GC when copying frame anchor</title>
                <link>https://bugs.openjdk.org/browse/JDK-8331735</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>A fatal error has been detected by the Java Runtime Environment:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;SIGSEGV (0xb) at pc=0x0000ffff67e651a8, pid=1499163, tid=1499236&lt;br/&gt;
&lt;br/&gt;
JRE version: Java(TM) SE Runtime Environment (23.0+22) (build 23-ea+22-1781)&lt;br/&gt;
&amp;nbsp;Java VM: Java HotSpot(TM) 64-Bit Server VM (23-ea+22-1781, mixed mode, sharing, tiered, compressed oops, compressed class ptrs, g1 gc, linux-aarch64)&lt;br/&gt;
&amp;nbsp;Problematic frame:&lt;br/&gt;
&amp;nbsp;j  java.awt.Font.getFont2D()Lsun/font/Font2D;+0 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
....&lt;br/&gt;
....&lt;br/&gt;
[warning][os] Loading hsdis library failed</description>
                <environment></environment>
        <key id="5128794">JDK-8331735</key>
            <summary>UpcallLinker::on_exit races with GC when copying frame anchor</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="6" iconUrl="https://bugs.openjdk.org/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jvernee">Jorn Vernee</assignee>
                                    <reporter username="honkar">Harshitha Onkar</reporter>
                        <labels>
                            <label>intermittent</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>panama</label>
                            <label>regression</label>
                            <label>sust-ojdk-bp</label>
                            <label>tier3</label>
                    </labels>
                <created>Mon, 6 May 2024 10:00:02 -0700</created>
                <updated>Tue, 15 Apr 2025 13:40:55 -0700</updated>
                            <resolved>Wed, 27 Nov 2024 04:24:44 -0800</resolved>
                                    <version>21</version>
                    <version>22</version>
                    <version>23</version>
                    <version>24</version>
                                    <fixVersion>24</fixVersion>
                                    <component>core-libs</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>21</watches>
                                                                                                                <comments>
                            <comment id="14767308" author="roboduke" created="Fri, 4 Apr 2025 20:25:54 -0700"  >[jdk17u-fix-request] Approval Request from Andrew Hughes&lt;br/&gt;
Partial backport of a fix for a race condition in the FFM API. Can lead to crashes when the FFM code manipulates a frame anchor in native mode, which the GC does not expect to happen. Fix is to move the frame anchor copying to Java mode, where the GC will wait for the thread to get to a safepoint. Risk to other code is low as the UpcallLinker is only used by FFM, which is in incubation in 17u. Patch has been reviewed by Martin Balao.</comment>
                            <comment id="14766937" author="roboduke" created="Thu, 3 Apr 2025 15:25:03 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/3434&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/3434&lt;/a&gt;&lt;br/&gt;
Date: 2025-04-03 22:19:28 +0000</comment>
                            <comment id="14755308" author="roboduke" created="Thu, 20 Feb 2025 09:30:31 -0800"  >[jdk21u-fix-request] Approval Request from Andrew Hughes&lt;br/&gt;
Clean backport of a fix for a race condition in the FFM API. Can lead to crashes when the FFM code manipulates a frame anchor in native mode, which the GC does not expect to happen. Fix is to move the frame anchor copying to Java mode, where the GC will wait for the thread to get to a safepoint. Risk to other code is low as the UpcallLinker is only used by FFM.</comment>
                            <comment id="14755294" author="roboduke" created="Thu, 20 Feb 2025 08:29:55 -0800"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/1424&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/1424&lt;/a&gt;&lt;br/&gt;
Date: 2025-02-20 16:23:03 +0000</comment>
                            <comment id="14726502" author="dukebot" created="Wed, 27 Nov 2024 04:24:43 -0800"  >Changeset: 461ffafe&lt;br/&gt;
Branch: master&lt;br/&gt;
Author:    Jorn Vernee &amp;lt;&lt;a href=&apos;mailto:jvernee@openjdk.org&apos;&gt;jvernee@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2024-11-27 12:20:51 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/461ffafeba459c077f1c2d9c5037305b71a8bc2a&quot;&gt;https://git.openjdk.org/jdk/commit/461ffafeba459c077f1c2d9c5037305b71a8bc2a&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14723127" author="roboduke" created="Mon, 18 Nov 2024 04:49:56 -0800"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/21742&quot;&gt;https://git.openjdk.org/jdk/pull/21742&lt;/a&gt;&lt;br/&gt;
Date: 2024-10-28 13:53:58 +0000</comment>
                            <comment id="14718502" author="jpai" created="Fri, 1 Nov 2024 00:04:24 -0700"  >Jorn has a (draft) PR with the proposed fix &lt;a href=&quot;https://github.com/openjdk/jdk/pull/21742&quot;&gt;https://github.com/openjdk/jdk/pull/21742&lt;/a&gt;. I have been running the reproducer against JDK mainline with that PR&amp;#39;s changes on a linux x64 and a linux aarch64. The repeat launches of the reproducer has been going on for almost 3 days now and it hasn&amp;#39;t crashed even once on either of those hosts. Previously, without that proposed fix, it used to crash within some hours on aarch64 and in a few days in x64. I&amp;#39;ll let the reproducer run for a few more days, but at this point I think the fix proposed in that PR appears to address this issue.</comment>
                            <comment id="14717021" author="jvernee" created="Mon, 28 Oct 2024 05:33:14 -0700"  >[~stefank] Thanks for the analysis. I think I understand what&amp;#39;s going on. This code was originally adapted from `JavaCallWrapper`, but that transitions to _thread_in_vm, rather than _thread_in_native before copying the frame anchor.&lt;br/&gt;
&lt;br/&gt;
I think we can copy the frame anchor while still being in the java thread state instead.</comment>
                            <comment id="14716984" author="stefank" created="Mon, 28 Oct 2024 02:03:44 -0700"  >I managed to catch this with rr on Linux x64. The issue seems to be that the frame anchor is manipulated while in native. The GC is using these fields when scanning for oops in the threads, and expects that these fields are note manipulated concurrently.&lt;br/&gt;
&lt;br/&gt;
This seems to be the problematic code:&lt;br/&gt;
&lt;br/&gt;
#1  UpcallLinker::on_exit (context=0x6d24699ee5f0) at open/src/hotspot/share/prims/upcallLinker.cpp:129&lt;br/&gt;
...&lt;br/&gt;
124	  debug_only(thread-&amp;gt;dec_java_call_counter());&lt;br/&gt;
125	&lt;br/&gt;
126	  // Old thread-local info. has been restored. We are now back in native code.&lt;br/&gt;
127	  ThreadStateTransition::transition_from_java(thread, _thread_in_native);&lt;br/&gt;
128	&lt;br/&gt;
129	  thread-&amp;gt;frame_anchor()-&amp;gt;copy(&amp;amp;context-&amp;gt;jfa);&lt;br/&gt;
130	&lt;br/&gt;
131	  // Release handles after we are marked as being in native code again, since this&lt;br/&gt;
132	  // operation might block&lt;br/&gt;
133	  JNIHandleBlock::release_block(context-&amp;gt;new_handles, thread);&lt;br/&gt;
&lt;br/&gt;
In my crash the scanned JavaThread Thread-10 has called copy on line 129 and has just executed:&lt;br/&gt;
48	  void copy(JavaFrameAnchor* src) {&lt;br/&gt;
...&lt;br/&gt;
56	    if (_last_Java_sp != src-&amp;gt;_last_Java_sp)&lt;br/&gt;
57	      _last_Java_sp = nullptr;&lt;br/&gt;
&lt;br/&gt;
So, _last_Java_sp is now null.&lt;br/&gt;
&lt;br/&gt;
While this is happening the GC thread is scanning this JavaThread and executing this code:&lt;br/&gt;
1431	void JavaThread::oops_do_frames(OopClosure* f, NMethodClosure* cf) {&lt;br/&gt;
1432	  if (!has_last_Java_frame()) {&lt;br/&gt;
1433	    return;&lt;br/&gt;
1434	  }&lt;br/&gt;
&lt;br/&gt;
and because _last_Java_sp is null the has_last_Java_frame function will return false:&lt;br/&gt;
&lt;br/&gt;
JavaThread::has_last_Java_frame (this=0x5b85fc12e1a0) at open/src/hotspot/share/runtime/javaThread.hpp:556&lt;br/&gt;
556	  bool has_last_Java_frame() const               { return _anchor.has_last_Java_frame(); }&lt;br/&gt;
&lt;br/&gt;
JavaFrameAnchor::has_last_Java_frame (this=0x5b85fc12e550) at open/src/hotspot/share/runtime/javaFrameAnchor.hpp:78&lt;br/&gt;
78	  bool has_last_Java_frame() const                   { return _last_Java_sp != nullptr; }&lt;br/&gt;
&lt;br/&gt;
And this has the effect that the GC skips scanning the oops in the frames, leading to various crashes and failures.</comment>
                            <comment id="14716969" author="jpai" created="Mon, 28 Oct 2024 00:40:05 -0700"  >This week I ran the same test repeatedly with a fastdebug JDK mainline build on a Linux x64 machine. After several days of repeat launches, one run ended up crashing the VM this time with an assertion failure in the JDK code:&lt;br/&gt;
&lt;br/&gt;
#  Internal Error (/jdk/open/src/hotspot/share/runtime/javaThread.cpp:1347), pid=1856780, tid=1856858&lt;br/&gt;
#  assert((!has_last_Java_frame() &amp;amp;&amp;amp; java_call_counter() == 0) || (has_last_Java_frame() &amp;amp;&amp;amp; java_call_counter() &amp;gt; 0)) failed: unexpected frame info: has_last_frame=false, java_call_counter=1&lt;br/&gt;
...&lt;br/&gt;
Current thread (0x00007f6e1c01a640):  WorkerThread &amp;quot;GC Thread#15&amp;quot;   [id=1856858, stack(0x00007f6e0e7ce000,0x00007f6e0e8ce000) (1024K)]&lt;br/&gt;
&lt;br/&gt;
Stack: [0x00007f6e0e7ce000,0x00007f6e0e8ce000],  sp=0x00007f6e0e8cc960,  free space=1018k&lt;br/&gt;
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
V  [libjvm.so+0xee5578]  JavaThread::verify_frame_info() [clone .part.0]+0x28  (javaThread.cpp:1347)&lt;br/&gt;
V  [libjvm.so+0xee8bdb]  JavaThread::verify_frame_info()+0x3b  (javaThread.cpp:1346)&lt;br/&gt;
V  [libjvm.so+0xeef82f]  JavaThread::oops_do_no_frames(OopClosure*, NMethodClosure*)+0x5f  (javaThread.cpp:1387)&lt;br/&gt;
V  [libjvm.so+0x180a156]  Thread::oops_do(OopClosure*, NMethodClosure*)+0x76  (thread.cpp:448)&lt;br/&gt;
V  [libjvm.so+0x1822284]  Threads::possibly_parallel_oops_do(bool, OopClosure*, NMethodClosure*)+0x1c4  (threads.cpp:1164)&lt;br/&gt;
V  [libjvm.so+0xd70215]  G1RootProcessor::process_java_roots(G1RootClosures*, G1GCPhaseTimes*, unsigned int)+0x75  (g1RootProcessor.cpp:180)&lt;br/&gt;
V  [libjvm.so+0xd70b71]  G1RootProcessor::evacuate_roots(G1ParScanThreadState*, unsigned int)+0x61  (g1RootProcessor.cpp:61)&lt;br/&gt;
V  [libjvm.so+0xd81ad2]  G1EvacuateRegionsTask::scan_roots(G1ParScanThreadState*, unsigned int)+0x22  (g1YoungCollector.cpp:669)&lt;br/&gt;
V  [libjvm.so+0xd82019]  G1EvacuateRegionsBaseTask::work(unsigned int)+0x89  (g1YoungCollector.cpp:656)&lt;br/&gt;
V  [libjvm.so+0x19555b0]  WorkerThread::run()+0x80  (workerThread.cpp:70)&lt;br/&gt;
V  [libjvm.so+0x180aa2a]  Thread::call_run()+0xba  (thread.cpp:234)&lt;br/&gt;
V  [libjvm.so+0x14eb963]  thread_native_entry(Thread*)+0x123  (os_linux.cpp:858)&lt;br/&gt;
JavaThread 0x00007f6ec4959940 (nid = 1856820) was being processed&lt;br/&gt;
Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)&lt;br/&gt;
v  ~RuntimeStub::nep_invoker_blob 0x00007f6eb3add4e8&lt;br/&gt;
J 2139 c2 sun.font.HBShaper.shape(Lsun/font/Font2D;Lsun/font/FontStrike;F[FLjava/lang/foreign/MemorySegment;[CLsun/font/GlyphLayout$GVData;IIIILjava/awt/geom/Point2D$Float;II)V &lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt; (52 bytes) @ 0x00007f6eb3f45254 [0x00007f6eb3f44660+0x0000000000000bf4]&lt;br/&gt;
J 2180 c2 sun.font.GlyphLayout$EngineRecord.layout()V &lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt; (108 bytes) @ 0x00007f6eb3f4c3f0 [0x00007f6eb3f4bfc0+0x0000000000000430]&lt;br/&gt;
J 1925 c1 sun.font.GlyphLayout.layout(Ljava/awt/Font;Ljava/awt/font/FontRenderContext;[CIIILsun/font/StandardGlyphVector;)Lsun/font/StandardGlyphVector; &lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt; (683 bytes) @ 0x00007f6eac5a7c34 [0x00007f6eac5a5300+0x0000000000002934]&lt;br/&gt;
J 2093 c2 FontLayoutStressTest.doLayout()D (31 bytes) @ 0x00007f6eb3f2ef58 [0x00007f6eb3f2e480+0x0000000000000ad8]&lt;br/&gt;
j  FontLayoutStressTest.lambda$main$0(Ljava/util/concurrent/CyclicBarrier;DLjava/util/concurrent/atomic/AtomicReference;)V+23&lt;br/&gt;
j  FontLayoutStressTest$$Lambda+0x00007f6e2f000a18.run()V+12&lt;br/&gt;
j  java.lang.Thread.runWith(Ljava/lang/Object;Ljava/lang/Runnable;)V+5 &lt;a href=&apos;mailto:java.base@24-internal&apos;&gt;java.base@24-internal&lt;/a&gt;&lt;br/&gt;
j  java.lang.Thread.run()V+19 &lt;a href=&apos;mailto:java.base@24-internal&apos;&gt;java.base@24-internal&lt;/a&gt;&lt;br/&gt;
v  ~StubRoutines::call_stub 0x00007f6eb3742d01&lt;br/&gt;
&lt;br/&gt;
The complete hs_err log file from this crash is attached to this issue (file named &amp;quot;hs_err_pid1856780.log &amp;quot;). It&amp;#39;s unclear if this assertion failure leading to the crash is the same issue as what&amp;#39;s causing the original crashes. But hopefully this has some hints on what&amp;#39;s going on.</comment>
                            <comment id="14716661" author="jpai" created="Fri, 25 Oct 2024 03:15:06 -0700"  >Here&amp;#39;s a summary of what we have investigated and found so far. The code in question resides in sun.font.HBShaper class (&lt;a href=&quot;https://github.com/openjdk/jdk/blob/master/src/java.desktop/share/classes/sun/font/HBShaper.java&quot;&gt;https://github.com/openjdk/jdk/blob/master/src/java.desktop/share/classes/sun/font/HBShaper.java&lt;/a&gt;) and looks like:&lt;br/&gt;
&lt;br/&gt;
static void shape(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Font2D font2D,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;FontStrike fontStrike,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;float ptSize,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;float[] mat,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MemorySegment hbface,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;char[] text,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;GVData gvData,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int script,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int offset,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int limit,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int baseIndex,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Point2D.Float startPt,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int flags,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int slot) {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ScopedVars vars = new ScopedVars(font2D, fontStrike, gvData, startPt);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ScopedValue.where(scopedVars, vars)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.run(() -&amp;gt; {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try (Arena arena = Arena.ofConfined()) {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;float startX = (float)startPt.getX();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;float startY = (float)startPt.getY();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MemorySegment matrix = arena.allocateFrom(JAVA_FLOAT, mat);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MemorySegment chars = arena.allocateFrom(JAVA_CHAR, text);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jdk_hb_shape_handle.invokeExact(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ptSize, matrix, hbface, chars, text.length,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;script, offset, limit,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;baseIndex, startX, startY, flags, slot,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;hb_jdk_font_funcs_struct,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;store_layout_results_stub);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (Throwable t) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
The HBShaper.shape() method (shown above) constructs a ScopedValue and runs a task in that scope. That scoped task constructs a confined FFM Arena, allocates a few MemorySegment(s) and then does a FFM downcall using the &amp;quot;jdk_hb_shape_handle&amp;quot; MethodHandle. The native side of this downcall is the &amp;quot;jdk_hb_shape&amp;quot; function which is implemented in src/java.desktop/share/native/libfontmanager/HBShaper_Panama.c (&lt;a href=&quot;https://github.com/openjdk/jdk/blob/master/src/java.desktop/share/native/libfontmanager/HBShaper_Panama.c&quot;&gt;https://github.com/openjdk/jdk/blob/master/src/java.desktop/share/native/libfontmanager/HBShaper_Panama.c&lt;/a&gt;). The implementation of this jdk_hb_shape function uses harfbuzz native library and apart from doing certain things, ulimately does a FFM based upcall into the HBShaper&amp;#39;s &amp;quot;store_layout_results&amp;quot; method which looks like:&lt;br/&gt;
&lt;br/&gt;
private static void store_layout_results(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int slot,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int baseIndex,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int offset,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;float startX,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;float startY,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;float devScale,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int charCount,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int glyphCount,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MemorySegment /* hb_glyph_info_t* */ glyphInfo,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MemorySegment /* hb_glyph_position_t* */ glyphPos&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;) {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// accesses and uses the scoped value that was set previously in HBShaper.shape()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;GVData gvdata = scopedVars.get().gvData();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Point2D.Float startPt = scopedVars.get().point();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// works against the MemorySegment(s) that are passed around by FFM&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// through the upcall from jdk_hb_shape native function&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
So essentially, at the high level this code path can be depicted as:&lt;br/&gt;
&lt;br/&gt;
HBShaper.shape() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ScopedValue.run() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try (Arena arena = FFM confined Arena through Arena.ofConfined()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;create MemorySegment(s);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;do FFM downcall passing the MemorySegment(s);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;native function in the downcall works with harfbuzz library;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;native function then does a FFM upcall;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java method of the upcall invocation works against the MemorySegment(s);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;upcall completes normally, controls reaches back into native function, which then returns normally too;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} // close the Arena&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} // ScopedValue task completion&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
This HBShaper.shape() gets invoked concurrently by numerous threads (intentionally) through the FontLayoutStressTest. So effectively we have several threads doing these confined Arean allocations, working against MemorySegment(s), doing downcall and upcall and finally closing the confined Arena, all within a ScopedValue of each thread.&lt;br/&gt;
&lt;br/&gt;
With this background of the code flow, let&amp;#39;s take a small step back and look into what a confined Arena, that&amp;#39;s constructed in this code, consists of. A Arena.ofConfined() returns a arena instance which is scoped to the Thread instance which invokes this ofConfined() method. The arena that&amp;#39;s returned is backed by a unique instance of a jdk.internal.foreign.MemorySessionImpl. The MemorySessionImpl is the one which holds on to the Thread instance to which the Arena is scoped. The MemorySessionImpl stores that Thread instance in a internal (final) field called &amp;quot;owner&amp;quot;. When working with the Arena instance, to verify and guarantee that only the &amp;quot;owner&amp;quot; thread is allowed to operate on that Arena, there are checks at relevant operations in the MemorySessionImpl where it asserts that &amp;quot;owner&amp;quot; is the same as the current thread (i.e. owner == Thread.currentThread()). That assertion is implemented in MemorySessionImpl&amp;#39;s checkValidStateRaw() method (which gets invoked from relevant places in the implementation):&lt;br/&gt;
&lt;br/&gt;
@ForceInline&lt;br/&gt;
public void checkValidStateRaw() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (owner != null &amp;amp;&amp;amp; owner != Thread.currentThread()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw WRONG_THREAD;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
If that assertion fails, then the MemorySessionImpl raises a WrongThreadException.&lt;br/&gt;
&lt;br/&gt;
In the above HBShaper code that we looked into previously, there should never be a case of WrongThreadException.&lt;br/&gt;
&lt;br/&gt;
However, during our investigation of this issue, when the JVM crashes, we have noticed that almost always there&amp;#39;s a WrongThreadException raised just before the JVM crashes. That WrongThreadException gets raised when the confined Arena is being closed in the HBShaper&amp;#39;s try-with-resources block, which as noted previously looks as follows:&lt;br/&gt;
&lt;br/&gt;
try (Arena arena = FFM confined Arena through Arena.ofConfined()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;....&lt;br/&gt;
} // close the Arena&lt;br/&gt;
&lt;br/&gt;
During this close() of the Arena, the MemorySessionImpl notices that the &amp;quot;owner&amp;quot; field that stores the Thread instance to which the Arena was scoped is no longer the same as the Thread.currentThread(). Additional investigation has been done and based on that I have ruled out that Thread.currentThread() is returning a wrong value. Instead, what I have noticed is that the &amp;quot;owner&amp;quot; field in the backing MemorySessionImpl instance starts off with the correct value of Thread instance, when the Arena is created. Then sometime during when the Arena is in use and before the Arena is closed, the &amp;quot;owner&amp;quot; field gets corrupted and ends up holding an incorrect value that then doesn&amp;#39;t match the original value that was stored in that (final) field (and thus doesn&amp;#39;t match Thread.currentThread()). It&amp;#39;s as if something in this entire downcall, upcall sequence has ended up overwriting the contents of an address that it shouldn&amp;#39;t have touched. I haven&amp;#39;t yet been able to narrow this down further (my knowledge of native debugging tools is very minimal).&lt;br/&gt;
&lt;br/&gt;
This entire analysis was done during past months and it is even applicable to the latest JDK mainline as of today (which contains the fixes that Jorn and Phil have done for some related code in this area). I continue to consistently reproduce this both on Linux aarch64 and Linux x64. I haven&amp;#39;t tried on other OS. The reproducer I use is the same FontLayoutStressTest that is under investigation here and is attached to this JBS issue (file named &amp;quot;8331735-reproducer-platform-thread.tar.gz&amp;quot;). Instead of running it as a jtreg test, this reproducer repeatedly, in a sequential loop, launches the FontLayoutStressTest as a standalone java process, until the process crashes (due to this bug). The Linux aarch64 crash happens in a few hours whereas the Linux x64 crash takes several days (yes days) to happen.&lt;br/&gt;
</comment>
                            <comment id="14716611" author="jpai" created="Fri, 25 Oct 2024 00:08:20 -0700"  >Hello Jorn,&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Jaikiran Pai I think you had a reproducer that you tested with my fix for &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8337753&quot; title=&quot;Target class of upcall stub may be unloaded&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8337753&quot;&gt;&lt;strike&gt;JDK-8337753&lt;/strike&gt;&lt;/a&gt;, and were still seeing issues with the thread pointer being corrupted, right?&lt;br/&gt;
&lt;br/&gt;
Yes, I can consistently reproduce this, although it sometimes takes hours. I thought I had added the analysis of some of our internal discussion in this JBS issue, but looks like I didn&amp;#39;t. I&amp;#39;ll update this issue with the summarized version of what we have narrowed down so far, in the next hour or so.</comment>
                            <comment id="14716540" author="stefank" created="Thu, 24 Oct 2024 14:36:19 -0700"  >FWIW, I got a crash when running with -XX:+UseParallelGC on macos-aarch64. The crash happened in non-GC code.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #2: 0x00000001048ff8f8 libjvm.dylib`os::start_debugging(buf=&amp;quot;SIGSEGV (0xb) at pc=0x000000010daff6ec, pid=51020, tid=68355\n\nDo you want to debug the problem?\n\nTo debug, run &amp;#39;gdb /proc/51020/exe 51020&amp;#39;;&lt;br/&gt;
&lt;br/&gt;
(lldb) x/40i 0x000000010daff6a0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6a0: 0x95cb6178   unknown     bl     0x114dd7c80&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6a4: 0xd503201f   unknown     nop&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6a8: 0xf280b39f   unknown     movk   xzr, #0x59c&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6ac: 0xf280001f   unknown     movk   xzr, #0x0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6b0: 0xf9404fe1   unknown     ldr    x1, [sp, #0x98]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6b4: 0xd343fc08   unknown     lsr    x8, x0, #3&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6b8: 0xb9003c28   unknown     str    w8, [x1, #0x3c]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6bc: 0xd349fc22   unknown     lsr    x2, x1, #9&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6c0: 0xd2980003   unknown     mov    x3, #0xc000&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6c4: 0xf2bfddc3   unknown     movk   x3, #0xfeee, lsl #16&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6c8: 0x3823785f   unknown     strb   wzr, [x2, x3, lsl #0]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6cc: 0xd28cf904   unknown     mov    x4, #0x67c8&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6d0: 0xf2a80784   unknown     movk   x4, #0x403c, lsl #16&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6d4: 0xf2c00024   unknown     movk   x4, #0x1, lsl #32&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6d8: 0xb50000a0   unknown     cbnz   x0, 0x10daff6ec&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6dc: 0x3943e488   unknown     ldrb   w8, [x4, #0xf9]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6e0: 0xb2400108   unknown     orr    x8, x8, #0x1&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6e4: 0x3903e488   unknown     strb   w8, [x4, #0xf9]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6e8: 0x14000035   unknown     b      0x10daff7bc&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6ec: 0xb9400803   unknown     ldr    w3, [x0, #0x8]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6f0: 0xd25d2c63   unknown     eor    x3, x3, #0x7ff800000000&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6f4: 0x91042089   unknown     add    x9, x4, #0x108&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6f8: 0xf9400128   unknown     ldr    x8, [x9]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6fc: 0xeb08007f   unknown     cmp    x3, x8&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff700: 0x540000a1   unknown     b.ne   0x10daff714&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff704: 0xf9408888   unknown     ldr    x8, [x4, #0x110]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff708: 0x91000508   unknown     add    x8, x8, #0x1&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff70c: 0xf9008888   unknown     str    x8, [x4, #0x110]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff710: 0x1400001c   unknown     b      0x10daff780&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff714: 0x91046089   unknown     add    x9, x4, #0x118&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff718: 0xf9400128   unknown     ldr    x8, [x9]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff71c: 0xeb08007f   unknown     cmp    x3, x8&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff720: 0x540000a1   unknown     b.ne   0x10daff734&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff724: 0xf9409088   unknown     ldr    x8, [x4, #0x120]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff728: 0x91000508   unknown     add    x8, x8, #0x1&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff72c: 0xf9009088   unknown     str    x8, [x4, #0x120]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff730: 0x14000014   unknown     b      0x10daff780&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff734: 0x91042089   unknown     add    x9, x4, #0x108&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff738: 0xf9400128   unknown     ldr    x8, [x9]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff73c: 0xb50000c8   unknown     cbnz   x8, 0x10daff754&lt;br/&gt;
&lt;br/&gt;
It crashes when reading the compressed klass pointer because the object pointer is 0:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6ec: 0xb9400803   unknown     ldr    w3, [x0, #0x8]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0x10daff6f0: 0xd25d2c63   unknown     eor    x3, x3, #0x7ff800000000&lt;br/&gt;
&lt;br/&gt;
(lldb) p $x0&lt;br/&gt;
(unsigned long) 0&lt;br/&gt;
&lt;br/&gt;
(lldb) p CompressedKlassPointers::_base&lt;br/&gt;
(address) 0x00007ff800000000 &amp;quot;&amp;quot;&lt;br/&gt;
</comment>
                            <comment id="14716520" author="stefank" created="Thu, 24 Oct 2024 12:18:18 -0700"  >I don&amp;#39;t think this is a GC issue given that GC crashes when scanning an OopMap. That is often an indication that something is broken outside of the GC.&lt;br/&gt;
&lt;br/&gt;
I wouldn&amp;#39;t mind if we create a new Bug for these latest crashes.</comment>
                            <comment id="14716516" author="jvernee" created="Thu, 24 Oct 2024 12:01:33 -0700"  >Since the issue doesn&amp;#39;t appear to be related to &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8337753&quot; title=&quot;Target class of upcall stub may be unloaded&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8337753&quot;&gt;&lt;strike&gt;JDK-8337753&lt;/strike&gt;&lt;/a&gt;, I&amp;#39;m not sure if the remaining issue is FFM related. Maybe someone from the GC team could take another look at this, as they probably have more experience with debugging this kind of issue. I wouldn&amp;#39;t mind rotating back around to this eventually, but I&amp;#39;m a bit busy with another project at the moment.&lt;br/&gt;
&lt;br/&gt;
[~jpai] I think you had a reproducer that you tested with my fix for &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8337753&quot; title=&quot;Target class of upcall stub may be unloaded&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8337753&quot;&gt;&lt;strike&gt;JDK-8337753&lt;/strike&gt;&lt;/a&gt;, and were still seeing issues with the thread pointer being corrupted, right?</comment>
                            <comment id="14716405" author="stefank" created="Thu, 24 Oct 2024 05:11:16 -0700"  >FWIW, I can reproduce a crash by running the test in a loop and spawning away multiple such loops concurrently (to mess with timing of things). From the crashes I&amp;#39;ve looked at it seem like we are scanning this thread:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;for thread: &amp;quot;Thread-58&amp;quot; #114 [1628888] prio=5 os_prio=0 cpu=49,46ms elapsed=303,70s tid=0x00007ef318183800 nid=1628888 waiting for monitor entry  [0x00007ef3b38fe000]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;java.lang.Thread.State: BLOCKED (on object monitor)&lt;br/&gt;
&lt;br/&gt;
	at sun.font.FontAccess.getFontAccess(&lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt;/FontAccess.java:42)&lt;br/&gt;
	- waiting to lock &amp;lt;0x00000000fa803c98&amp;gt; (a java.lang.Class for sun.font.FontAccess)&lt;br/&gt;
	at sun.font.FontUtilities.getFont2D(&lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt;/FontUtilities.java:151)&lt;br/&gt;
	at sun.font.StandardGlyphVector.initFontData(&lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt;/StandardGlyphVector.java:1110)&lt;br/&gt;
	at sun.font.StandardGlyphVector.initGlyphVector(&lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt;/StandardGlyphVector.java:231)&lt;br/&gt;
	at sun.font.StandardGlyphVector.&amp;lt;init&amp;gt;(&lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt;/StandardGlyphVector.java:186)&lt;br/&gt;
	at sun.font.GlyphLayout$GVData.createGlyphVector(&lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt;/GlyphLayout.java:612)&lt;br/&gt;
	at sun.font.GlyphLayout.layout(&lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt;/GlyphLayout.java:484)&lt;br/&gt;
	at java.awt.Font.layoutGlyphVector(&lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt;/Font.java:2856)&lt;br/&gt;
	at FontLayoutStressTest.doLayout(FontLayoutStressTest.java:51)&lt;br/&gt;
	at FontLayoutStressTest.lambda$main$0(FontLayoutStressTest.java:67)&lt;br/&gt;
	at FontLayoutStressTest$$Lambda/0x00007ef373001208.run(Unknown Source)&lt;br/&gt;
	at java.lang.Thread.runWith(&lt;a href=&apos;mailto:java.base@24-internal&apos;&gt;java.base@24-internal&lt;/a&gt;/Thread.java:1589)&lt;br/&gt;
	at java.lang.Thread.run(&lt;a href=&apos;mailto:java.base@24-internal&apos;&gt;java.base@24-internal&lt;/a&gt;/Thread.java:1576)&lt;br/&gt;
&lt;br/&gt;
And in one of the crashes we were crashing while scanning the OopMap of an nmethod frame:&lt;br/&gt;
0x00007ef3dc494ab8 is at entry_point+1302 in (nmethod*)0x00007ef3dc494408&lt;br/&gt;
Compiled method (c2) 440902 1902       4       sun.font.StandardGlyphVector::initFontData (180 bytes)&lt;br/&gt;
&amp;nbsp;total in heap  [0x00007ef3dc494408,0x00007ef3dc495138] = 3376&lt;br/&gt;
&amp;nbsp;relocation     [0x00007ef3dc4944e0,0x00007ef3dc494570] = 144&lt;br/&gt;
&amp;nbsp;constants      [0x00007ef3dc494580,0x00007ef3dc4945a0] = 32&lt;br/&gt;
&amp;nbsp;main code      [0x00007ef3dc4945a0,0x00007ef3dc495050] = 2736&lt;br/&gt;
&amp;nbsp;stub code      [0x00007ef3dc495050,0x00007ef3dc495068] = 24&lt;br/&gt;
&amp;nbsp;oops           [0x00007ef3dc495068,0x00007ef3dc495070] = 8&lt;br/&gt;
&amp;nbsp;metadata       [0x00007ef3dc495070,0x00007ef3dc495138] = 200&lt;br/&gt;
&amp;nbsp;immutable data [0x00007ef0a4041c30,0x00007ef0a4041f10] = 736&lt;br/&gt;
&amp;nbsp;dependencies   [0x00007ef0a4041c30,0x00007ef0a4041c78] = 72&lt;br/&gt;
&amp;nbsp;nul chk table  [0x00007ef0a4041c78,0x00007ef0a4041ca0] = 40&lt;br/&gt;
&amp;nbsp;handler table  [0x00007ef0a4041ca0,0x00007ef0a4041cd0] = 48&lt;br/&gt;
&amp;nbsp;scopes pcs     [0x00007ef0a4041cd0,0x00007ef0a4041de0] = 272&lt;br/&gt;
&amp;nbsp;scopes data    [0x00007ef0a4041de0,0x00007ef0a4041f10] = 304&lt;br/&gt;
&lt;br/&gt;
End of assembler dump.&lt;br/&gt;
(gdb) disass 0x00007ef3dc494ab8 - 0x40, +100&lt;br/&gt;
Dump of assembler code from 0x7ef3dc494a78 to 0x7ef3dc494adc:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494a78:  out    %al,(%dx)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494a79:  xchg   %ax,%ax&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494a7b:  call   0x7ef3dbd39760&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494a80:  nopl   0x2000678(%rax,%rax,1)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494a88:  mov    $0xfffffff6,%esi&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494a8d:  xchg   %ax,%ax&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494a8f:  call   0x7ef3dbd39760             &amp;lt;= Uncommon trap blob&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494a94:  nopl   0x300068c(%rax,%rax,1)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494a9c:  mov    %r14d,(%rsp)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494aa0:  mov    %rsi,%rbp&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494aa3:  movabs $0xfa803c98,%rsi&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494aad:  lea    0x30(%rsp),%rdx&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494ab2:  nop&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494ab3:  call   0x7ef3dbd45ae0               &amp;lt;= Broken oop map here&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494ab8:  nopl   0x40006b0(%rax,%rax,1)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494ac0:  mov    (%rsp),%r14d&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494ac4:  jmp    0x7ef3dc494653&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494ac9:  movabs $0xfa803c98,%rdi&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494ad3:  lea    0x30(%rsp),%rsi&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494ad8:  mov    %r15,%rdx&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0x00007ef3dc494adb:  movabs $0x7ef3f1dd47f0,%r10&lt;br/&gt;
End of assembler dump.</comment>
                            <comment id="14716363" author="stefank" created="Thu, 24 Oct 2024 02:25:47 -0700"  >&amp;gt; unless trim_queue_to_threshold is a function that is basically the main() of the GC it is really interesting that it keeps coming up. &lt;br/&gt;
&lt;br/&gt;
It *is* the `main() of the GC.</comment>
                            <comment id="14716305" author="prr" created="Wed, 23 Oct 2024 21:57:13 -0700"  >unless trim_queue_to_threshold is a function that is basically the main() of the GC it is really interesting that it keeps coming up.&lt;br/&gt;
The one FFM bug that was noted is fixed, we&amp;#39;ve beaten to death the desktop 3rd party library code usage, the ScopedValues (IIUC) is just a field attached to a Java Thread object, so assuming it is referencing only another Java object should be OK.&lt;br/&gt;
I think on current JDK 24 tip it would be good for GC to take another look.&lt;br/&gt;
&lt;br/&gt;
Perhaps we should run this test 10,000 ( or more) (?) times with a different collector ?</comment>
                            <comment id="14700680" author="dcubed" created="Mon, 26 Aug 2024 07:30:58 -0700"  >Here&amp;#39;s the crashing thread&amp;#39;s stack from the jdk-24+13-1350-tier3 sighting:&lt;br/&gt;
&lt;br/&gt;
java/awt/font/TextLayout/FontLayoutStressTest.java&lt;br/&gt;
&lt;br/&gt;
---------------  T H R E A D  ---------------&lt;br/&gt;
&lt;br/&gt;
Current thread (0x0000ffff4c00a830):  WorkerThread &amp;quot;GC Thread#4&amp;quot;    [id=3306141, stack(0x0000fffef3208000,0x0000fffef3406000) (2040K)]&lt;br/&gt;
&lt;br/&gt;
Stack: [0x0000fffef3208000,0x0000fffef3406000],  sp=0x0000fffef3404520,  free space=2033k&lt;br/&gt;
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
V  [libjvm.so+0xed1890]&lt;br/&gt;
V  [libjvm.so+0x70a260]  G1ParScanThreadState::steal_and_trim_queue(GenericTaskQueueSet&amp;lt;OverflowTaskQueue&amp;lt;ScannerTask, (MEMFLAGS)5, 131072u&amp;gt;, (MEMFLAGS)5&amp;gt;*)+0x31c  (g1ParScanThreadState.inline.hpp:60)&lt;br/&gt;
V  [libjvm.so+0x73afb4]  G1ParEvacuateFollowersClosure::do_void()+0x94  (g1YoungCollector.cpp:582)&lt;br/&gt;
V  [libjvm.so+0x73b594]  G1EvacuateRegionsTask::evacuate_live_objects(G1ParScanThreadState*, unsigned int)+0x74  (g1YoungCollector.cpp:607)&lt;br/&gt;
V  [libjvm.so+0x7391e0]  G1EvacuateRegionsBaseTask::work(unsigned int)+0xa0  (g1YoungCollector.cpp:657)&lt;br/&gt;
V  [libjvm.so+0xdae008]  WorkerThread::run()+0x98  (workerThread.cpp:70)&lt;br/&gt;
V  [libjvm.so+0xd01028]  Thread::call_run()+0xa8  (thread.cpp:225)&lt;br/&gt;
V  [libjvm.so+0xb853b0]  thread_native_entry(Thread*)+0xdc  (os_linux.cpp:858)&lt;br/&gt;
C  [libpthread.so.0+0x7950]  start_thread+0x190&lt;br/&gt;
&lt;br/&gt;
siginfo: si_signo: 4 (SIGILL), si_code: 1 (ILL_ILLOPC), si_addr: 0x0000ffff95187890&lt;br/&gt;
</comment>
                            <comment id="14695434" author="jvernee" created="Fri, 2 Aug 2024 08:36:02 -0700"  >&amp;gt; [~jvernee] does `-Xlog:class+unload` show the class being unloaded? &lt;br/&gt;
&lt;br/&gt;
Yes, it is being unloaded, thanks for the suggestion. I was looking at the class unload events in the hs_err log, but that doesn&amp;#39;t seem to include everything.&lt;br/&gt;
&lt;br/&gt;
I think I&amp;#39;ve figured out the issue I&amp;#39;m seeing: The lambda form holding the method we&amp;#39;re calling is being customized (I thought this was impossible), which replaces the form field in the MethodHandle instance we&amp;#39;re targeting with the upcall stub. It is in principle fine to keep using the un-customized LF like we do, but now that LF class is not being referenced by anything, and is then, evidently, unloaded.&lt;br/&gt;
&lt;br/&gt;
Another clue which I didn&amp;#39;t notice sooner: The Method* embedded in the upcall stub is different from the one pointed to by the receiver MH in several of these crashes where both of those values were still in the registers at the time of the crash.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m going to file a separate issue for that, since I&amp;#39;m still not 100% sure it&amp;#39;s related to this issue, but it seems likely.</comment>
                            <comment id="14695255" author="dholmes" created="Thu, 1 Aug 2024 16:37:09 -0700"  >[~jvernee] does `-Xlog:class+unload` show the class being unloaded?</comment>
                            <comment id="14695181" author="jvernee" created="Thu, 1 Aug 2024 09:31:16 -0700"  >Little update: from examining the many different crashes I&amp;#39;m seeing with the new reproducer, there are strong indications that the class pointed to by the FFM upcall stub is either being unloaded, or being corrupted. e.g. we embed the Method* of the target method in the stub, and then call into `from_compiled`:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;__ ldr(rscratch1, Address(rmethod, Method::from_compiled_offset()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;__ blr(rscratch1);&lt;br/&gt;
&lt;br/&gt;
It is exactly at this blr instruction that a crash occurs (SIGBUS), and from the crash log, the `Method` that rmethod points to can not be decoded, and is just described as &amp;#39;pointing into metadata&amp;#39;. The contents of rmethod is just loaded from a constant (using mov_metadata), and the code looks intact at the time of the crash, when looking at the disassembly. I&amp;#39;ve also seen several other crashes where the IntstanceKlass or constant pool associated with this Method was corrupted.&lt;br/&gt;
&lt;br/&gt;
The holder class is a hidden class, referenced through a MethodHandle stashed in a global JNI ref. Maybe that is not enough to keep the class alive. Or maybe I&amp;#39;m misunderstanding the lifetime of Method objects in metaspace (can they be moved around?). Still investigating.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m also seeing frequent malloc errors reported in STDERR, such as: &amp;#39;int_mallinfo(): unaligned fastbin chunk detected&amp;#39;, which seems to indicate a double free (?). I have not been able to find the source of the issue with ASAN/gdb so far.&lt;br/&gt;
&lt;br/&gt;
Metaspace is not really my area, so suggestions would be welcome.</comment>
                            <comment id="14692203" author="alanb" created="Tue, 23 Jul 2024 23:28:31 -0700"  >The current status on this is that Jorn has a test case based on java/foreign/TestUpcallStress.java that seems to reproduce the issue within a few minutes on linux-aarch64. The test doesn&amp;#39;t use a ScopedValue. </comment>
                            <comment id="14691936" author="jpai" created="Tue, 23 Jul 2024 02:58:52 -0700"  >&amp;gt; I&amp;#39;m running another round of tests, this time with platform threads to rule out any virtual thread usage from the reproducer. &lt;br/&gt;
&lt;br/&gt;
The issue is reproducible even with just platform threads. I&amp;#39;ve now attached 8331735-reproducer-platform-thread.tar.gz which also contains the (same set of) instructions on how to use it. This reproducer is similar to the previous virtual thread reproducer, except that this doesn&amp;#39;t make use of any virtual threads in any part of the testing. The issue continues to reproduce and crashes the JVM. Here too we are noticing that the object instance id of the same platform thread changes unexpectedly during the FFM task execution happening within a ScopedValue block. Additional investigation is currently in progress to understand more about what cause this.&lt;br/&gt;
</comment>
                            <comment id="14691884" author="jpai" created="Tue, 23 Jul 2024 02:09:29 -0700"  >I&amp;#39;ve attached a 8331735-reproducer-virtual-thread.tar.gz which contains a README.md with the instructions on how to use that reproducer. It&amp;#39;s trivial and just requires setting a JAVA_HOME and a JT_HOME (for pointing to jtreg installation). That reproducer uses virtual thread to launch the main() method of the java application/test.</comment>
                            <comment id="14691857" author="jpai" created="Tue, 23 Jul 2024 00:43:52 -0700"  >I now have a reproducer (in fact this same FontLayoutStressTest, just launched in a more simpler way) which consistently reproduced this issue locally against latest mainline master branch. I chose a linux-aarch64 to reproduce it. It takes several runs (sometimes 1000 odd) before it fails with a JVM crash, but it does indeed always crash and fail, sometimes after around 30 minutes of repeated launching of the test.&lt;br/&gt;
&lt;br/&gt;
After looking at the client-libs code and the ScopedValue code involved, I&amp;#39;ve been adding tiny bits of debug logs in the JDK, at relevant places to understand what&amp;#39;s going on. Here&amp;#39;s the launch options I use to try and help narrow this down (only relevant snippet):&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-ea -esa -Dsun.java2d.debugfonts=true -Xlog:exceptions=info -XX:+UnlockDiagnosticVMOptions -XX:+ShowCarrierFrames -XX:+ShowHiddenFrames --add-modules java.desktop&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ve been able to reproduce this consistently when virtual threads are involved. What I mean by that is, if I launch the main class&amp;#39; (which is the FontLayoutStressTest.java) main() method through a virtual thread, then I am always to always reproduce it. How I launch main() method of a main class through a virtual thread is something that borrowed from what jtreg itself does (when -Dtest.threadFactory is Virtual) - I&amp;#39;ll be attaching those relevant scripts and details to this issue.&lt;br/&gt;
&lt;br/&gt;
I haven&amp;#39;t so far been able to reproduce it when launching the main() with a regular platform thread. However, I haven&amp;#39;t completely ruled out that platform threads aren&amp;#39;t impacted, only because I manually stopped the platform threads based run after several hours of not being able to reproduce it. Given the way this is failing (which I explain below), I suspect this issue is likely very much to do with virtual threads.&lt;br/&gt;
&lt;br/&gt;
Based on a few initial runs with -Xlog:exceptions=info (thanks to David Holmes for mentioning this option in a different issue), I managed to notice some interesting exceptions being reported and looking at the code in the client-libs `src/java.desktop/share/classes/sun/font/HBShaper.java`, the following code seemed relevant &lt;a href=&quot;https://github.com/openjdk/jdk/blob/master/src/java.desktop/share/classes/sun/font/HBShaper.java#L462:&quot;&gt;https://github.com/openjdk/jdk/blob/master/src/java.desktop/share/classes/sun/font/HBShaper.java#L462:&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ScopedVars vars = new ScopedVars(font2D, fontStrike, gvData, startPt);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ScopedValue.where(scopedVars, vars)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.run(() -&amp;gt; {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try (Arena arena = Arena.ofConfined()) {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;float startX = (float)startPt.getX();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;float startY = (float)startPt.getY();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MemorySegment matrix = arena.allocateFrom(JAVA_FLOAT, mat);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MemorySegment chars = arena.allocateFrom(JAVA_CHAR, text);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/*int ret =*/ jdk_hb_shape_handle.invokeExact(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ptSize, matrix, hbface, chars, text.length,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;script, offset, limit,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;baseIndex, startX, startY, flags, slot,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;hb_jdk_font_funcs_struct,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;store_layout_results_stub);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (Throwable t) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
So it uses ScopedValues to run a task which uses FFM, specifically `Arena.ofConfined()`. That code also has a `catch(Throwable t)` block which catches and eats up anything that&amp;#39;s thrown from that task, including any exceptions that might happen when the Arena is being used or closed or any FFM operation is invoked. I am not sure if that catch block is intentional in the way it currently is and why any failures from the FFM call might be ignored.&lt;br/&gt;
&lt;br/&gt;
To gain more data from that part of the code, I added a few debug logs in that catch block and reran the reproducer.&lt;br/&gt;
&lt;br/&gt;
When the JVM crashes (the crash log I haven&amp;#39;t included because it&amp;#39;s similar to what we have seen so far), I am noticing the following (only the relevant parts):&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;release0 called from thread Thread[#45,Thread-14,5,VirtualThreads] owner is Thread[#45,Thread-14,5,VirtualThreads]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wrong thread: Thread[#45,Thread-14,5,VirtualThreads] (objid= &lt;a href=&apos;mailto:java.lang.Thread@3c7f8406&apos;&gt;java.lang.Thread@3c7f8406&lt;/a&gt;) owner: Thread[#45,Thread-14,5,VirtualThreads] (objid=java.lang.Thread@5490003)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[0.899s][info][exceptions] Exception &amp;lt;a &amp;#39;jdk/internal/misc/ScopedMemoryAccess$ScopedAccessError&amp;#39;{0x00000005490259c0}: Invalid memory access&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thrown in interpreter method &amp;lt;{method} {0x0000ffff34387520} &amp;#39;checkValidStateRaw&amp;#39; &amp;#39;()V&amp;#39; in &amp;#39;jdk/internal/foreign/MemorySessionImpl&amp;#39;&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at bci 91 for thread 0x0000ffff041f9f60 (Thread-14)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[0.899s][info][exceptions] Exception &amp;lt;a &amp;#39;jdk/internal/misc/ScopedMemoryAccess$ScopedAccessError&amp;#39;{0x00000005490259c0}: Invalid memory access&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thrown in interpreter method &amp;lt;{method} {0x0000ffff34387610} &amp;#39;checkValidState&amp;#39; &amp;#39;()V&amp;#39; in &amp;#39;jdk/internal/foreign/MemorySessionImpl&amp;#39;&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at bci 1 for thread 0x0000ffff041f9f60 (Thread-14)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[0.899s][info][exceptions] Found matching handler for exception of type &amp;quot;jdk.internal.misc.ScopedMemoryAccess$ScopedAccessError&amp;quot; in method &amp;quot;checkValidState&amp;quot; at BCI: 7&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[0.899s][info][exceptions] Exception &amp;lt;a &amp;#39;java/lang/WrongThreadException&amp;#39;{0x000000054e3ff6b8}: Attempted access outside owning thread&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thrown in interpreter method &amp;lt;{method} {0x0000ffff34387610} &amp;#39;checkValidState&amp;#39; &amp;#39;()V&amp;#39; in &amp;#39;jdk/internal/foreign/MemorySessionImpl&amp;#39;&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at bci 12 for thread 0x0000ffff041f9f60 (Thread-14)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[0.899s][info][exceptions] Exception &amp;lt;a &amp;#39;java/lang/WrongThreadException&amp;#39;{0x000000054e3ff6b8}: Attempted access outside owning thread&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thrown in interpreter method &amp;lt;{method} {0x0000ffff34565230} &amp;#39;justClose&amp;#39; &amp;#39;()V&amp;#39; in &amp;#39;jdk/internal/foreign/ConfinedSession&amp;#39;&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at bci 1 for thread 0x0000ffff041f9f60 (Thread-14)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[0.899s][info][exceptions] Exception &amp;lt;a &amp;#39;java/lang/WrongThreadException&amp;#39;{0x000000054e3ff6b8}: Attempted access outside owning thread&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thrown in C1 compiled method &amp;lt;{method} {0x0000ffff34370040} &amp;#39;lambda$shape$0&amp;#39; &amp;#39;(Ljava/awt/geom/Point2D$Float;[F[CFLjava/lang/foreign/MemorySegment;IIIIII)V&amp;#39; in &amp;#39;sun/font/HBShaper&amp;#39;&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at PC0x0000ffff64afcad4 for thread 0x0000ffff041f9f60&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[0.899s][info][exceptions] Found matching handler for exception of type &amp;quot;java.lang.WrongThreadException&amp;quot; in method &amp;quot;lambda$shape$0&amp;quot; at BCI: 129&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[0.899s][info][exceptions] Thread 0x0000ffff041f9f60 continuing at PC 0x0000ffff64afdf04 for exception thrown at PC 0x0000ffff64afcad4&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread[#45,Thread-14,5,VirtualThreads] error: java.lang.WrongThreadException: Attempted access outside owning thread&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;java.lang.WrongThreadException: Attempted access outside owning thread&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/jdk.internal.foreign.MemorySessionImpl.wrongThread(MemorySessionImpl.java:318)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/jdk.internal.foreign.MemorySessionImpl$$Lambda/0x0000008001035148.get(Unknown Source)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/jdk.internal.misc.ScopedMemoryAccess$ScopedAccessError.newRuntimeException(ScopedMemoryAccess.java:113)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/jdk.internal.foreign.MemorySessionImpl.checkValidState(MemorySessionImpl.java:213)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/jdk.internal.foreign.ConfinedSession.justClose(ConfinedSession.java:88)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/jdk.internal.foreign.MemorySessionImpl.close(MemorySessionImpl.java:236)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/jdk.internal.foreign.ArenaImpl.close(ArenaImpl.java:50)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.desktop/sun.font.HBShaper.lambda$shape$0(HBShaper.java:480)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.desktop/sun.font.HBShaper$$Lambda/0x00000080010d6a58.run(Unknown Source)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/jdk.internal.vm.ScopedValueContainer.runWithoutScope(ScopedValueContainer.java:112)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/jdk.internal.vm.ScopedValueContainer.run(ScopedValueContainer.java:98)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.ScopedValue$Carrier.runWith(ScopedValue.java:484)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.ScopedValue$Carrier.run(ScopedValue.java:468)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.desktop/sun.font.HBShaper.shape(HBShaper.java:464)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.desktop/sun.font.SunLayoutEngine.layout(SunLayoutEngine.java:187)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.desktop/sun.font.GlyphLayout$EngineRecord.layout(GlyphLayout.java:669)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.desktop/sun.font.GlyphLayout.layout(GlyphLayout.java:459)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.desktop/java.awt.Font.layoutGlyphVector(Font.java:2856)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at FontLayoutStressTest.doLayout(FontLayoutStressTest.java:51)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at FontLayoutStressTest.lambda$main$0(FontLayoutStressTest.java:67)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at FontLayoutStressTest$$Lambda/0x0000008001001cc8.run(Unknown Source)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.Thread.runWith(Thread.java:1588)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.Thread.run(Thread.java:1575)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
So Arena.close() from that task run through a ScopedValue ends up throwing a WrongThreadException. I additionally had added a few more debug logs at more relevant locations including the code in `checkValidStateRaw()` method of `src/java.base/share/classes/jdk/internal/foreign/MemorySessionImpl.java`, from where the WrongThreadException gets thrown. Something like:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;--- a/src/java.base/share/classes/jdk/internal/foreign/MemorySessionImpl.java&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+++ b/src/java.base/share/classes/jdk/internal/foreign/MemorySessionImpl.java&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@@ -189,7 +189,11 @@ public boolean isAlive() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*/&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@ForceInline&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void checkValidStateRaw() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-        if (owner != null &amp;amp;&amp;amp; owner != Thread.currentThread()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+        final Thread curr;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+        if (owner != null &amp;amp;&amp;amp; owner != (curr = Thread.currentThread())) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+            System.err.println(&amp;quot;wrong thread: &amp;quot; + curr&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+                    + &amp;quot; (objid= &amp;quot; + Objects.toIdentityString(curr)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+                    + &amp;quot;) owner: &amp;quot; + owner + &amp;quot; (objid=&amp;quot; + Objects.toIdentityString(owner) + &amp;quot;)&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw WRONG_THREAD;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
You will notice in the above log snippet, that this line has generated the following message:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wrong thread: Thread[#45,Thread-14,5,VirtualThreads] (objid= &lt;a href=&apos;mailto:java.lang.Thread@3c7f8406&apos;&gt;java.lang.Thread@3c7f8406&lt;/a&gt;) owner: Thread[#45,Thread-14,5,VirtualThreads] (objid=java.lang.Thread@5490003)&lt;br/&gt;
&lt;br/&gt;
So it appears that although it&amp;#39;s the &amp;quot;same&amp;quot; thread that owns the confined arena and is the one closing that Arena, the object identity check for `owner != Thread.currentThread()` on that line isn&amp;#39;t passing. The debug log message that I added, also prints the object identity of the &amp;quot;owner&amp;quot; and the current thread and it shows that the object identities are not the same (although it&amp;#39;s the &amp;quot;same&amp;quot; thread). I haven&amp;#39;t fully grasped what&amp;#39;s going on here and why, but the object identity of the Thread instance changing appears odd. The other part that isn&amp;#39;t clear to me is whether this is the root cause of the JVM crash. &lt;br/&gt;
&lt;br/&gt;
Edit: I&amp;#39;m running another round of tests, this time with platform threads to rule out any virtual thread usage from the reproducer.&lt;br/&gt;
</comment>
                            <comment id="14691717" author="prr" created="Mon, 22 Jul 2024 11:51:43 -0700"  >I don&amp;#39;t know why this was made a P2. It is very rare and there isn&amp;#39;t even a proper understanding of the cause, despite lots of people looking at it very hard.</comment>
                            <comment id="14691700" author="prr" created="Mon, 22 Jul 2024 11:02:17 -0700"  >This happens to be a client test but it isn&amp;#39;t a client bug.</comment>
                            <comment id="14691288" author="aph" created="Fri, 19 Jul 2024 09:57:31 -0700"  >This one is assigned to me, but I don&amp;#39;t think there&amp;#39;s anything I can do. Scoped values are pure Java code, and whatever the problem is, I&amp;#39;m sure it could be reproduced by a test case that doesn&amp;#39;t use scoped values at all. I&amp;#39;d do so if I were able to reproduce the bug.&lt;br/&gt;
I&amp;#39;m unassigning myself now.</comment>
                            <comment id="14689382" author="tschatzl" created="Fri, 12 Jul 2024 05:35:15 -0700"  >No crashes with -Xint after 20k runs on linux-aarch64&lt;br/&gt;
C1 only crashes (-XX:TieredStopAtLevel=1) 3/10000 on linux-aarch64&lt;br/&gt;
C2 only crashes (-XX:-TieredCompilation)</comment>
                            <comment id="14687659" author="tschatzl" created="Mon, 8 Jul 2024 00:36:43 -0700"  >&amp;gt;&amp;quot;All linux-aarch64 (I always run the same number on linux-x64 at the same time). &amp;quot;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;Mmmm, but what exact processor? This might be micro-architecture dependent. &lt;br/&gt;
&lt;br/&gt;
The crashes also occur on linux-x64 (AMD EPYC 9J14, from the attached hs_err file) and osx-x64 (Mac minis, i5-4308U CPU), just much less frequently. Linux-aarch64 are Oracle OCI AmpereOne processors.</comment>
                            <comment id="14687540" author="aph" created="Sat, 6 Jul 2024 06:14:14 -0700"  >&amp;quot;All linux-aarch64 (I always run the same number on linux-x64 at the same time). &amp;quot;&lt;br/&gt;
&lt;br/&gt;
Mmmm, but what exact processor? This might be micro-architecture dependent.</comment>
                            <comment id="14686726" author="tschatzl" created="Wed, 3 Jul 2024 01:30:10 -0700"  >With -XX:+DeoptimizeALot (I made the flag product to be able to use it in release mode as I never managed to reproduce this issue in debug mode) there is no particular change in the number of failures - 3 in 5000. Two of those have the usual broken `scopedValueBindings` member of j.l.Thread. All linux-aarch64 (I always run the same number on linux-x64 at the same time).</comment>
                            <comment id="14686138" author="jvernee" created="Mon, 1 Jul 2024 10:06:35 -0700"  >I&amp;#39;ve also been trying to look at this, but I&amp;#39;m currently stuck on trying to get a working gdb on the Linux/Aarch64 machine I&amp;#39;m using (keeps crashing while evaluating expressions in the debugger).&lt;br/&gt;
&lt;br/&gt;
One other possibility that comes to mind is that deoptimization is at fault here, as that is also quite rare. [~aph] maybe you could try running with -XX:+DeoptimizeALot to see if that triggers the failure.</comment>
                            <comment id="14686047" author="aph" created="Mon, 1 Jul 2024 06:57:29 -0700"  >I&amp;#39;ve carefully stepped through (on AArch64) the code creating and scanning the stack frames associated with an upcall. I can find no fault in the way that saved oops are handled.&lt;br/&gt;
&lt;br/&gt;
Another possibility, given that it&amp;#39;s said to be easier to reproduce this fault on AArch64 (although I haven&amp;#39;t managed to do so) must be to do with inter-thread synchronization. From what I can see, though, these is no shortage of fences when performing a handshake at a safepoint. Having said that, I believe that G1 does some concurrent processing.&lt;br/&gt;
&lt;br/&gt;
I will now return to something else. As I said above, the ScopedValue implementation is plain Java. If it breaks in the way described that&amp;#39;s because of something done to it by the VM, not because of something it did. If anyone can tell me how to reproduce this bug, maybe I can say more.</comment>
                            <comment id="14685843" author="aph" created="Sat, 29 Jun 2024 06:05:30 -0700"  >So far I&amp;#39;ve been unable to reproduce this.&lt;br/&gt;
&lt;br/&gt;
For anyone who has done so outside CI, what was the environment? It&amp;#39;s been seen on Neoverse N2, right? How many cores? Does that matter?&lt;br/&gt;
&lt;br/&gt;
Anything that might help would be good.</comment>
                            <comment id="14685702" author="jvernee" created="Fri, 28 Jun 2024 05:55:23 -0700"  >&amp;gt; we should make sure that the printed OOP map is not misleading&lt;br/&gt;
&lt;br/&gt;
It&amp;#39;s handled by the oop map of the caller frame (that&amp;#39;s the frame that knows whether there&amp;#39;s an oop in FP/RBP after all). You should be able to see it if you print out the oop map of the frame for `TestStackWalk::payload` during the stackwalk (see whitebox.cpp::WB_VerifyFrames) in the test I pointed at. The oop map at the call to the nep_invoker_blob looks like this on my Windows-x64 machine: ImmutableOopMap {rbp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop }[WhiteBox::VerifyFrames]</comment>
                            <comment id="14685619" author="aph" created="Fri, 28 Jun 2024 01:10:04 -0700"  >Let&amp;#39;s check that FP is handled correctly, and we should make sure that the printed OOP map is not misleading, if only for the sake of future maintainers.&lt;br/&gt;
&lt;br/&gt;
The scoped values code that handles this is pure Java. The behaviour we&amp;#39;re seeing here is entirely consistent with a register pointing to scopedValueBindings not being updated whenit should be. We&amp;#39;re missing a GC root somewhere.</comment>
                            <comment id="14685594" author="jpai" created="Thu, 27 Jun 2024 23:41:22 -0700"  >&amp;gt; (I hope I got the intrinsic names right - not sure if the names are actually verified to exist somewhere?) &lt;br/&gt;
&lt;br/&gt;
In &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8334386&quot;&gt;https://bugs.openjdk.org/browse/JDK-8334386&lt;/a&gt; I&amp;#39;m working to introduce a VM option which will list the supported intrinsic names on a platform, along with the class and method names to which that intrinsic name is mapped to.</comment>
                            <comment id="14685536" author="jvernee" created="Thu, 27 Jun 2024 18:48:47 -0700"  >&amp;gt; Yes, it does have an oop map, and the frame pointer should be added to that implicitly. (that might be why it&amp;#39;s not printed?). At least, that&amp;#39;s how it worked several years ago when I looked at it. &lt;br/&gt;
&lt;br/&gt;
Sorry, I think I&amp;#39;m not remembering correctly. I&amp;#39;ll look into this a bit more tomorrow, but the way it works, IIRC, is that when we walk to the sender frame from the nep_invoker_blob frame, we update a register map with the saved location of the frame pointer (see the call to update_map_with_saved_link in frame::sender_for_compiled_frame). The caller can then inspect the saved FP location if it need to.</comment>
                            <comment id="14685524" author="jvernee" created="Thu, 27 Jun 2024 17:01:57 -0700"  >&amp;gt; Does nep_invoker_blob have an oopmap including FP that is scanned and updated by the GC?&lt;br/&gt;
&lt;br/&gt;
Yes, it does have an oop map, and the frame pointer should be added to that implicitly. (that might be why it&amp;#39;s not printed?). At least, that&amp;#39;s how it worked several years ago when I looked at it.&lt;br/&gt;
&lt;br/&gt;
FWIW, we had issues during development with RBP going dead during GC stack walks before, and added tests for that (e.g. &lt;a href=&quot;https://github.com/openjdk/jdk/blob/master/test/jdk/java/foreign/stackwalk/TestStackWalk.java#L145)&quot;&gt;https://github.com/openjdk/jdk/blob/master/test/jdk/java/foreign/stackwalk/TestStackWalk.java#L145)&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
The code has change quite a bit since then, but the oops in the nep_invoker_blob frame were handled through frame::oops_do_internal -&amp;gt; frame::oops_code_blob_do, ~~but it seems that since &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8329629&quot;&gt;https://bugs.openjdk.org/browse/JDK-8329629&lt;/a&gt; we now silently ignore code blobs that are not nmethods? [1]. [~stefank] How are oops in the frames of non-nmethod code blobs handled after &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8329629&quot; title=&quot;GC interfaces should work directly against nmethod instead of CodeBlob&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8329629&quot;&gt;&lt;strike&gt;JDK-8329629&lt;/strike&gt;&lt;/a&gt;?~~ Ah, never mind, that method still handles oops for non-nmethod frames as well&lt;br/&gt;
&lt;br/&gt;
[1]: &lt;a href=&quot;https://github.com/openjdk/jdk/pull/18653/files#diff-47d6ef8a97116fd4facc79e558bd8bf5c7db97d36303d07238a9374a2be3aa3cR987&quot;&gt;https://github.com/openjdk/jdk/pull/18653/files#diff-47d6ef8a97116fd4facc79e558bd8bf5c7db97d36303d07238a9374a2be3aa3cR987&lt;/a&gt;</comment>
                            <comment id="14685479" author="aph" created="Thu, 27 Jun 2024 11:22:41 -0700"  >One thing I&amp;#39;d like to know from the FFM people:&lt;br/&gt;
&lt;br/&gt;
Let&amp;#39;s say that an OOP is in register FP. We call from Java into nep_invoker_blob. That OOP is still live in FP, and must be processed by GC.&lt;br/&gt;
&lt;br/&gt;
Does nep_invoker_blob have an oopmap including FP that is scanned and updated by the GC? stub _oop_maps-&amp;gt;print() doesn&amp;#39;t print it if so. So how does GC know where to find the saved OOP that was in FP, and is now saved in the nep_invoker_blob&amp;#39;s stack? Surely it doesn&amp;#39;t.</comment>
                            <comment id="14685478" author="aph" created="Thu, 27 Jun 2024 11:21:42 -0700"  >The odd thing about this is that the ScopedValue implementation is literally plain Java. It&amp;#39;s not hiding anything where a GC can&amp;#39;t see it. The only odd thing is ensureMaterializedForStackWalk, which literally does nothing - it&amp;#39;s a NOP - but C2 doesn&amp;#39;t know that, so it prevents scalar replacement of the scopedValueBindings.&lt;br/&gt;
&lt;br/&gt;
The only code that accesses scopedValueBindings is in Java, before and after the native code in  jdk_hb_shape().&lt;br/&gt;
&lt;br/&gt;
So whatever the real cause of the problem is, I don&amp;#39;t think it&amp;#39;s in the ScopedValue code. </comment>
                            <comment id="14685384" author="aph" created="Thu, 27 Jun 2024 06:31:40 -0700"  >I am working on this.</comment>
                            <comment id="14684895" author="tschatzl" created="Wed, 26 Jun 2024 02:53:14 -0700"  >I attached the hs_err file for that linux-x64 crash analyzed in &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8331735?focusedId=14684098&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14684098&quot;&gt;https://bugs.openjdk.org/browse/JDK-8331735?focusedId=14684098&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14684098&lt;/a&gt; .&lt;br/&gt;
&lt;br/&gt;
There is no OOME or VM error I can see.</comment>
                            <comment id="14684872" author="aph" created="Wed, 26 Jun 2024 01:21:17 -0700"  >I&amp;#39;ve been thinking about where there is any code in the VM that might cause the current bindings to be invalid, and I can think of only one.&lt;br/&gt;
&lt;br/&gt;
When we get a virtual machine error, we have to repair the scope value context in case it was being updated at the time an out of memory error was detected. &lt;br/&gt;
&lt;br/&gt;
To do this, we do a stack walk: see JVM_FindScopedValueBindings. If there is something incorrect here, it might lead to an invalid OOP in scopedValueBindings. Do we know if a virtual machine error ever occurs during this test?</comment>
                            <comment id="14684762" author="tschatzl" created="Tue, 25 Jun 2024 15:03:48 -0700"  >After 20k runs with intrinsics disabled, ie. with&lt;br/&gt;
&lt;br/&gt;
-XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_findScopedValueBindings,_scopedValueCache,_setScopedValueCache&lt;br/&gt;
&lt;br/&gt;
(I hope I got the intrinsic names right - not sure if the names are actually verified to exist somewhere?)&lt;br/&gt;
&lt;br/&gt;
there are still failures, so unless I got above names wrong, intrinsics do not change the situation.&lt;br/&gt;
&lt;br/&gt;
Now that I know where to look, most of the (G1) crashes have a broken scopedValueBindings field of the j.l.Thread in the register output of the hs_err files, e.g.&lt;br/&gt;
&lt;br/&gt;
R23=0x00000000e74b05ed is pointing into object: java.lang.Thread &lt;br/&gt;
{0x00000000e74b0598} - klass: &amp;#39;java/lang/Thread&amp;#39;&lt;br/&gt;
&amp;nbsp;- ---- fields (total size 15 words):&lt;br/&gt;
&amp;nbsp;- &amp;#39;threadLocalRandomProbe&amp;#39; &amp;#39;I&amp;#39; @12  0 (0x00000000)&lt;br/&gt;
&amp;nbsp;- private volatile &amp;#39;eetop&amp;#39; &amp;#39;J&amp;#39; @16  0 (0x0000000000000000)&lt;br/&gt;
&amp;nbsp;- private final &amp;#39;tid&amp;#39; &amp;#39;J&amp;#39; @24  22 (0x0000000000000016)&lt;br/&gt;
&amp;nbsp;- &amp;#39;threadLocalRandomSeed&amp;#39; &amp;#39;J&amp;#39; @32  0 (0x0000000000000000)&lt;br/&gt;
&amp;nbsp;- injected &amp;#39;jvmti_thread_state&amp;#39; &amp;#39;J&amp;#39; @40  0 (0x0000000000000000)&lt;br/&gt;
&amp;nbsp;- &amp;#39;threadLocalRandomSecondarySeed&amp;#39; &amp;#39;I&amp;#39; @48  80520126 (0x04cca3be)&lt;br/&gt;
&amp;nbsp;- injected &amp;#39;jvmti_VTMS_transition_disable_count&amp;#39; &amp;#39;I&amp;#39; @52  0 (0x00000000)&lt;br/&gt;
&amp;nbsp;- injected &amp;#39;jfr_epoch&amp;#39; &amp;#39;S&amp;#39; @56  0 (0x0000)&lt;br/&gt;
&amp;nbsp;- volatile &amp;#39;interrupted&amp;#39; &amp;#39;Z&amp;#39; @58  false (0x00)&lt;br/&gt;
&amp;nbsp;- injected &amp;#39;jvmti_is_in_VTMS_transition&amp;#39; &amp;#39;Z&amp;#39; @59  false (0x00)&lt;br/&gt;
&amp;nbsp;- private volatile &amp;#39;name&amp;#39; &amp;#39;Ljava/lang/String;&amp;#39; @60  &amp;quot;Thread-1&amp;quot;{0x00000000e74b0610} (0xe74b0610)&lt;br/&gt;
&amp;nbsp;- private volatile &amp;#39;contextClassLoader&amp;#39; &amp;#39;Ljava/lang/ClassLoader;&amp;#39; @64  a &amp;#39;jdk/internal/loader/ClassLoaders$AppClassLoader&amp;#39;{0x00000000e752acc8} (0xe752acc8)&lt;br/&gt;
&amp;nbsp;- private &amp;#39;inheritedAccessControlContext&amp;#39; &amp;#39;Ljava/security/AccessControlContext;&amp;#39; @68  null (0x00000000)&lt;br/&gt;
&amp;nbsp;- private final &amp;#39;holder&amp;#39; &amp;#39;Ljava/lang/Thread$FieldHolder;&amp;#39; @72  a &amp;#39;java/lang/Thread$FieldHolder&amp;#39;{0x00000000e74b0640} (0xe74b0640)&lt;br/&gt;
&amp;nbsp;- &amp;#39;threadLocals&amp;#39; &amp;#39;Ljava/lang/ThreadLocal$ThreadLocalMap;&amp;#39; @76  null (0x00000000)&lt;br/&gt;
&amp;nbsp;- &amp;#39;inheritableThreadLocals&amp;#39; &amp;#39;Ljava/lang/ThreadLocal$ThreadLocalMap;&amp;#39; @80  null (0x00000000)&lt;br/&gt;
&amp;nbsp;- private &amp;#39;scopedValueBindings&amp;#39; &amp;#39;Ljava/lang/Object;&amp;#39; @84  &lt;br/&gt;
[error occurred during error reporting (printing register info, attempt 2), id 0xb, SIGSEGV (0xb) at pc=0x0000ffffa4d72234]  &amp;lt;---------- !!&lt;br/&gt;
R24=0x000000bb0000008d is an unknown value&lt;br/&gt;
&lt;br/&gt;
Just checking this, j.l.Thread, it is also in survivor space (0x00000000e74b0598), i.e. most likely just copied too.</comment>
                            <comment id="14684604" author="tschatzl" created="Tue, 25 Jun 2024 05:23:27 -0700"  >&amp;gt; If someone can duplicate then it we can easily replace the SV in HBShaper to use a TL instead of a SV and see if it duplicates as that would at least hint as to whether it&amp;#39;s a SV or FFM issue. Also testing with the instrinics for Thread.{findScopedValueBindings,scopedValueCache,setScopedValueCache} disabled might yield new information too.&lt;br/&gt;
&lt;br/&gt;
As mentioned above the crashes reproduce &amp;quot;easily&amp;quot; after enough runs. You need at least ~50k runs of the test to be somewhat confident bad/not bad though. I agree that it is useful to perfom the suggested tests with TL and intrinsics enabled/disabled.&lt;br/&gt;
&lt;br/&gt;
Another option is trying to bisect the changes using this test to find some responsible change or even retry to reproduce without the FFM code.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;( Some of the error logs in the CI are a SEGV in java.awt.Font.getFont2D. There&amp;#39;s no native frame or SV in these crashes. It&amp;#39;s glyph layout so same area but not clear if this is the same thing or an unrelated issue ) &lt;br/&gt;
&lt;br/&gt;
If the SV reference is bad, but not bad enough (i.e. pointing to an object start that has no reference by coincidence), GC will happily pass.&lt;br/&gt;
&lt;br/&gt;
At most Java code (but not stubs etc) will cause a ClassCastException or such - and we have such a failure (&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8331735?focusedId=14675454&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14675454&quot;&gt;https://bugs.openjdk.org/browse/JDK-8331735?focusedId=14675454&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14675454&lt;/a&gt;).&lt;br/&gt;
</comment>
                            <comment id="14684603" author="tschatzl" created="Tue, 25 Jun 2024 05:18:13 -0700"  >&amp;gt; Mach5 doesn&amp;#39;t show any test failure in mainline after that. The failures only started to (re?)appear &lt;br/&gt;
&amp;gt; recently. Why was there a ~5 months interval w/o any failures? &lt;br/&gt;
&lt;br/&gt;
The failures are very rare. I got 13 failures out of 243k runs of that test (i.e. one after every 20k runs). All on different machines. Some of them are attempts at being more targeted, or a debug build (which never reproduced), so that number might need to be reduced; I think it&amp;#39;s like 1 in 5-10k runs or so if you just run linux-aarch64.&lt;br/&gt;
&lt;br/&gt;
I initially could not reproduce after 22k iterations for &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8321379&quot; title=&quot; java/awt/font/TextLayout/FontLayoutStressTest.java crashes in  G1ParScanThreadState::trim_queue_to_threshold processing JNI handles&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8321379&quot;&gt;&lt;strike&gt;JDK-8321379&lt;/strike&gt;&lt;/a&gt; (which is not included in that 243k runs) so I closed it as CNR.&lt;br/&gt;
&lt;br/&gt;
Timing on otherwise loaded machines is different than running the same test on the same machine over and over too which might have an impact too.&lt;br/&gt;
&lt;br/&gt;
While some of the mach5 failures were on various platforms (OSX-x64, linux-x64), I only ever got it to reproduce on linux-aarch64 and fairly early just stopped trying to reproduce on anything but there. However the failures were always on different machines.&lt;br/&gt;
&lt;br/&gt;
It is possible that that linux-x64 crash was pure luck (i.e. hardware failure) or due to some other cause, it seems fairly unlikely that exactly this (and apparently only this) memory location was affected (other addresses in that j.l.Thread object are okay, and already successfully adjusted to the new locations). I could not find an indication that this particular machine has faulty hardware either. I.e. other tests failing randomly on that machine.&lt;br/&gt;
&lt;br/&gt;
Not only this crash with the clear indication that the value has been corrupted before GC but also the 45k non-failing runs with FFM/Scoped Values not used (with that flag) gives me a fairly good indication that it is an issue with scoped values.&lt;br/&gt;
</comment>
                            <comment id="14684565" author="jvernee" created="Tue, 25 Jun 2024 04:00:39 -0700"  >FWIW, FFM has only 1 Java heap-related interaction in the upcall stub (none in the downcall stub): It allocates a new JNI handle block, and sets that as active. The reference to the old handle block is saved in the upcall stub frame, which is then set back to active when we are returning from Java to native after the upcall. At that point, the newly allocated handle block is also freed.&lt;br/&gt;
&lt;br/&gt;
This mimics what is done for JNI, and should cover the scenario where a user does a JNI downcall, an FFM upcall, and then wants to continue doing multiple JNI downcalls (for which the new handle block is then used).&lt;br/&gt;
&lt;br/&gt;
The thread&amp;#39;s handle block is only used to store local JNI handles that are created during a native JNI call, AFAIK.&lt;br/&gt;
&lt;br/&gt;
The old handle block is seen by the GC through frame::oops_do_internal -&amp;gt; UpcallStub::oops_do. The newly allocated handle block is handled by the GC through the JavaThread::_active_handles field.</comment>
                            <comment id="14684552" author="alanb" created="Tue, 25 Jun 2024 03:38:34 -0700"  >I ran open/test/jdk/java/awt/font/TextLayout/FontLayoutStressTest.java with release and debug builds, and with JTREG_REPEAT_COUNT=&amp;lt;n&amp;gt;, but couldn&amp;#39;t duplicate the issue.&lt;br/&gt;
&lt;br/&gt;
If someone can duplicate then it we can easily replace the SV in HBShaper to use a TL instead of a SV and see if it duplicates as that would at least hint as to whether it&amp;#39;s a SV or FFM issue. Also testing with the instrinics for Thread.{findScopedValueBindings,scopedValueCache,setScopedValueCache}  disabled might yield new information too.&lt;br/&gt;
&lt;br/&gt;
( Some of the error logs in the CI are a SEGV in java.awt.Font.getFont2D. There&amp;#39;s no native frame or SV in these crashes. It&amp;#39;s glyph layout so same area but not clear if this is the same thing or an unrelated issue )</comment>
                            <comment id="14684529" author="thartmann" created="Tue, 25 Jun 2024 02:30:50 -0700"  >[~tschatzl] No, that doesn&amp;#39;t ring a bell but maybe [~roland] has an idea.</comment>
                            <comment id="14684528" author="tschatzl" created="Tue, 25 Jun 2024 02:26:43 -0700"  >Probably first occurrence was &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8321379&quot; title=&quot; java/awt/font/TextLayout/FontLayoutStressTest.java crashes in  G1ParScanThreadState::trim_queue_to_threshold processing JNI handles&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8321379&quot;&gt;&lt;strike&gt;JDK-8321379&lt;/strike&gt;&lt;/a&gt; right after &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8318364&quot; title=&quot;Add an FFM-based implementation of harfbuzz OpenType layout&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8318364&quot;&gt;&lt;strike&gt;JDK-8318364&lt;/strike&gt;&lt;/a&gt; has been integrated so updating affects version too.</comment>
                            <comment id="14684469" author="tschatzl" created="Tue, 25 Jun 2024 00:52:46 -0700"  >[~thartmann]: maybe, as [~aph] suggests (to me at least), an issue with code generation where wrong register contents are put into that member during stub generation and scoped values, does something come to your mind here?</comment>
                            <comment id="14684178" author="tschatzl" created="Mon, 24 Jun 2024 08:58:01 -0700"  >&amp;gt; The only thing I can think of is that java_lang_Thread::scopedValueBindings is not being scanned by the GC and so is stale. That would certainly lead to garbage in that struct. But it&amp;#39;s just a plain old Java object, with no special properties, so it can&amp;#39;t really be that. &lt;br/&gt;
&lt;br/&gt;
The crash in that analyzed core file occurs exactly because the field is scanned by GC, pointing inside an object (also in eden, i.e. just allocated). As mentioned in that crash, the bad oop for scopedValueBindings is already in the original object, GC &amp;quot;properly&amp;quot; copies the object including the bad value.</comment>
                            <comment id="14684147" author="aph" created="Mon, 24 Jun 2024 07:01:06 -0700"  >The only thing I can think of is that  java_lang_Thread::scopedValueBindings is not being scanned by the GC and so is stale. That would certainly lead to garbage in that struct. But it&amp;#39;s just a plain old Java object, with no special properties,so it can&amp;#39;t really be that.&lt;br/&gt;
&lt;br/&gt;
With regard to strong references, every scoped value binding object is referenced by a frame (of kind Thread::runWith) on the stack. This makes the whole thing robust against stack overflow, etc: you can just walk the stack to find the nearest enclosing bindings.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;d be seriously wondering about register corruption. But anyway, let me know if you want me to have a look.</comment>
                            <comment id="14684143" author="alanb" created="Mon, 24 Jun 2024 06:40:34 -0700"  >I hacked up a quick test to call to native function with a downcall handle, passing it the address of an upcall stub to invoke a callback. The native function is invoked with a ScopedValue binding for the current thread and the callback uses ScopedValue.get to its value. I couldn&amp;#39;t provoke the crash seen here.&lt;br/&gt;
&lt;br/&gt;
(At this time, scopedValueBindings is just a regular field on Thread. The cache (for lookup) is an OopHandle in JavaThread. There are C2 instrinics for the cache access).</comment>
                            <comment id="14684109" author="tschatzl" created="Mon, 24 Jun 2024 04:57:00 -0700"  >A potential workaround could be disabling use of FFM in java/awt/font layout api making -Dsun.font.layout.ffm=false default.</comment>
                            <comment id="14684106" author="tschatzl" created="Mon, 24 Jun 2024 04:50:00 -0700"  >I am adding jhsdb output and gdb stack traces to this issue; any attempt at trying to link the not-yet-initialized scopedValueBindings member to a particular stack trace would just be guessing from me.&lt;br/&gt;
&lt;br/&gt;
One obvious option is that a GC happens while the scoped values are copied into the java.lang.Thread data structure for whatever reason (and for some reason there is magic in java.lang.Thread that prevents it from being zero-initialized) but idk (e.g. thread 3 in jshdb.out).&lt;br/&gt;
&lt;br/&gt;
So far nothing points into that this is a GC issue (crashes with all STW collectors at least, that particular crash showing that GC could not modify that bad reference, does not reproduce without FFM which uses scoped values), so moving it to core-libs/java.lang which are afaict responsible for scoped values.</comment>
                            <comment id="14684098" author="tschatzl" created="Mon, 24 Jun 2024 04:22:23 -0700"  >There has been an interesting failure on x64-linux where the test crashes in G1ParScanThreadState::trim_queue_to_threshold();&lt;br/&gt;
&lt;br/&gt;
Some stack trace:&lt;br/&gt;
&lt;br/&gt;
Thread #1:&lt;br/&gt;
[...]&lt;br/&gt;
#60 0x00007f7d31b023ee in VMError::report_and_die (thread=thread@entry=0x7f7ca800b310, sig=sig@entry=11, pc=pc@entry=0x7f7d313b7282 &amp;lt;G1ParScanThreadState::trim_queue_to_threshold(unsigned int)+7074&amp;gt; &amp;quot;\213H\bH\211E\260\205\311\017\216p\030&amp;quot;, siginfo=siginfo@entry=0x7f7cb8981070, context=context@entry=0x7f7cb8980f40) at open/src/hotspot/share/utilities/vmError.cpp:1604&lt;br/&gt;
#61 0x00007f7d3196d79b in JVM_handle_linux_signal (sig=11, info=0x7f7cb8981070, ucVoid=0x7f7cb8980f40, abort_if_unrecognized=1) at open/src/hotspot/os/posix/signals_posix.cpp:649&lt;br/&gt;
#62 &amp;lt;signal handler called&amp;gt;&lt;br/&gt;
#63 0x00007f7d313b7282 in Klass::layout_helper (this=&amp;lt;optimized out&amp;gt;) at open/src/hotspot/share/oops/klass.hpp:295&lt;br/&gt;
#64 oopDesc::size_given_klass (klass=&amp;lt;optimized out&amp;gt;, this=&amp;lt;optimized out&amp;gt;) at open/src/hotspot/share/oops/oop.inline.hpp:157&lt;br/&gt;
#65 G1ParScanThreadState::do_copy_to_survivor_space (old_mark=..., old=0xe0221218, region_attr=..., this=&amp;lt;optimized out&amp;gt;) at open/src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:463&lt;br/&gt;
#66 G1ParScanThreadState::do_oop_evac&amp;lt;narrowOop&amp;gt; (p=0xda9d7d14, this=0x7f7c44003030) at open/src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:218&lt;br/&gt;
#67 G1ParScanThreadState::dispatch_task (task=..., this=&amp;lt;optimized out&amp;gt;) at open/src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:296&lt;br/&gt;
#68 G1ParScanThreadState::trim_queue_to_threshold (this=this@entry=0x7f7c44003030, threshold=threshold@entry=0) at open/src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:317&lt;br/&gt;
#69 0x00007f7d313bb9ba in G1ParScanThreadState::trim_queue (this=0x7f7c44003030) at open/src/hotspot/share/gc/g1/g1ParScanThreadState.inline.hpp:60&lt;br/&gt;
#70 G1ParScanThreadState::steal_and_trim_queue (this=this@entry=0x7f7c44003030, task_queues=&amp;lt;optimized out&amp;gt;) at open/src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:328&lt;br/&gt;
#71 0x00007f7d313ef6e5 in G1ParEvacuateFollowersClosure::do_void (this=this@entry=0x7f7cb8981d30) at open/src/hotspot/share/gc/g1/g1YoungCollector.cpp:547&lt;br/&gt;
#72 0x00007f7d313efe9f in G1EvacuateRegionsBaseTask::evacuate_live_objects (termination_phase=G1GCPhaseTimes::Termination, objcopy_phase=G1GCPhaseTimes::ObjCopy, worker_id=2, pss=0x7f7c44003030, this=0x7f7cfbffe0e0) at open/src/hotspot/share/gc/g1/g1YoungCollector.cpp:602&lt;br/&gt;
&lt;br/&gt;
The address it crashes on is 0xda9d7d14 (frame 66).&lt;br/&gt;
&lt;br/&gt;
$ (gdb) x/20x 0xda9d7d14&lt;br/&gt;
0xda9d7d14:	0xe0221218	0xda823a10	0x00000000	0x00000000&lt;br/&gt;
0xda9d7d24:	0x00000000	0x00000000	0x00000000	0x00000000&lt;br/&gt;
0xda9d7d34:	0x00000000	0x00000031	0x00000000	0x00166738&lt;br/&gt;
0xda9d7d44:	0x00000000	0x00000000	0xda9d7d50	0x00000031&lt;br/&gt;
0xda9d7d54:	0x00000000	0x00161570	0x00000009	0x65726854&lt;br/&gt;
&lt;br/&gt;
I.e. it refers to 0xe0221218&lt;br/&gt;
&lt;br/&gt;
This is an eden(!) region, i.e. the object has just been allocated, no GC occurred on it.&lt;br/&gt;
&lt;br/&gt;
| 258|0x00000000e0200000, 0x00000000e0300000, 0x00000000e0300000|100%| E|CS|TAMS 0x00000000e0200000| PB 0x00000000e0200000| Complete |  0&lt;br/&gt;
&lt;br/&gt;
&amp;quot;E&amp;quot; means eden region&lt;br/&gt;
&lt;br/&gt;
Looking at the stack slots:&lt;br/&gt;
&lt;br/&gt;
stack at sp + 1 slots: 0x00000000da9d7cc0 is an oop: java.lang.Thread &lt;br/&gt;
{0x00000000da9d7cc0} - klass: &amp;#39;java/lang/Thread&amp;#39;&lt;br/&gt;
&amp;nbsp;- ---- fields (total size 15 words):&lt;br/&gt;
&amp;nbsp;- &amp;#39;threadLocalRandomProbe&amp;#39; &amp;#39;I&amp;#39; @12  0 (0x00000000)&lt;br/&gt;
&amp;nbsp;- private volatile &amp;#39;eetop&amp;#39; &amp;#39;J&amp;#39; @16  0 (0x0000000000000000)&lt;br/&gt;
&amp;nbsp;- private final &amp;#39;tid&amp;#39; &amp;#39;J&amp;#39; @24  43 (0x000000000000002b)&lt;br/&gt;
&amp;nbsp;- &amp;#39;threadLocalRandomSeed&amp;#39; &amp;#39;J&amp;#39; @32  0 (0x0000000000000000)&lt;br/&gt;
&amp;nbsp;- injected &amp;#39;jvmti_thread_state&amp;#39; &amp;#39;J&amp;#39; @40  0 (0x0000000000000000)&lt;br/&gt;
&amp;nbsp;- &amp;#39;threadLocalRandomSecondarySeed&amp;#39; &amp;#39;I&amp;#39; @48  -1170677104 (0xba38e290)&lt;br/&gt;
&amp;nbsp;- injected &amp;#39;jvmti_VTMS_transition_disable_count&amp;#39; &amp;#39;I&amp;#39; @52  0 (0x00000000)&lt;br/&gt;
&amp;nbsp;- injected &amp;#39;jfr_epoch&amp;#39; &amp;#39;S&amp;#39; @56  0 (0x0000)&lt;br/&gt;
&amp;nbsp;- volatile &amp;#39;interrupted&amp;#39; &amp;#39;Z&amp;#39; @58  false (0x00)&lt;br/&gt;
&amp;nbsp;- injected &amp;#39;jvmti_is_in_VTMS_transition&amp;#39; &amp;#39;Z&amp;#39; @59  false (0x00)&lt;br/&gt;
&amp;nbsp;- private volatile &amp;#39;name&amp;#39; &amp;#39;Ljava/lang/String;&amp;#39; @60  &amp;quot;Thread-13&amp;quot;{0x00000000da9d7d38} (0xda9d7d38)&lt;br/&gt;
&amp;nbsp;- private volatile &amp;#39;contextClassLoader&amp;#39; &amp;#39;Ljava/lang/ClassLoader;&amp;#39; @64  a &amp;#39;jdk/internal/loader/ClassLoaders$AppClassLoader&amp;#39;{0x00000000daa08e48} (0xdaa08e48)&lt;br/&gt;
&amp;nbsp;- private &amp;#39;inheritedAccessControlContext&amp;#39; &amp;#39;Ljava/security/AccessControlContext;&amp;#39; @68  null (0x00000000)&lt;br/&gt;
&amp;nbsp;- private final &amp;#39;holder&amp;#39; &amp;#39;Ljava/lang/Thread$FieldHolder;&amp;#39; @72  a &amp;#39;java/lang/Thread$FieldHolder&amp;#39;{0x00000000da9d7d70} (0xda9d7d70)&lt;br/&gt;
&amp;nbsp;- &amp;#39;threadLocals&amp;#39; &amp;#39;Ljava/lang/ThreadLocal$ThreadLocalMap;&amp;#39; @76  null (0x00000000)&lt;br/&gt;
&amp;nbsp;- &amp;#39;inheritableThreadLocals&amp;#39; &amp;#39;Ljava/lang/ThreadLocal$ThreadLocalMap;&amp;#39; @80  null (0x00000000)&lt;br/&gt;
&amp;nbsp;- private &amp;#39;scopedValueBindings&amp;#39; &amp;#39;Ljava/lang/Object;&amp;#39; @84  &lt;br/&gt;
&lt;br/&gt;
0x00000000da9d7cc0 + 84 = 0xda9d7d14, which means that the `scopedValueBindings` member of java.lang.Thread contains garbage, since the java.lang.Thread is in Eden, no GC can have occurred.&lt;br/&gt;
&lt;br/&gt;
The java.lang.Thread instance is in Survivor space:&lt;br/&gt;
&lt;br/&gt;
| 169|0x00000000da900000, 0x00000000daa00000, 0x00000000daa00000|100%| S|  |TAMS 0x00000000da900000| PB 0x00000000da900000| Complete |  0&lt;br/&gt;
&lt;br/&gt;
&amp;quot;S&amp;quot; means survivor region&lt;br/&gt;
&lt;br/&gt;
It has just been copied (in this GC) from 0xda9d7cc0 containing the same garbage value in the `scopedValueBindings` field.&lt;br/&gt;
&lt;br/&gt;
(gdb) find /w 0x00000000da800000, 0x00000000e7400000, 0xba38e290 // looking for the `threadLocalRandomSecondarySeed` value in the j.l.Thread (at offset 48)&lt;br/&gt;
0xda9d7cf0&lt;br/&gt;
0xddccbab0&lt;br/&gt;
(gdb) x/30w 0xddccbab0-48 // original j.l.Thread in Eden, i.e.&lt;br/&gt;
&lt;br/&gt;
| 220|0x00000000ddc00000, 0x00000000ddd00000, 0x00000000ddd00000|100%| E|CS|TAMS 0x00000000ddc00000| PB 0x00000000ddc00000| Complete |  0&lt;br/&gt;
&lt;br/&gt;
0xddccba80:	0xda9d7cc3	0x00000000	0x0016db90	0x00000000&lt;br/&gt;
0xddccba90:	0x00000000	0x00000000	0x0000002b	0x00000000&lt;br/&gt;
0xddccbaa0:	0x00000000	0x00000000	0x00000000	0x00000000&lt;br/&gt;
0xddccbab0:	0xba38e290	0x00000000	0x00000000	0xddcccb40&lt;br/&gt;
0xddccbac0:	0xddc005f0	0x00000000	0xddcccbb8	0x00000000&lt;br/&gt;
0xddccbad0:	0x00000000    &amp;gt;0xe0221218	0xddcccec0	0x00000000&lt;br/&gt;
0xddccbae0:	0x00000000	0x00000000	0x00000000	0x00000000&lt;br/&gt;
0xddccbaf0:	0x00000000	0x00000000&lt;br/&gt;
(gdb) x/30w 0xda9d7cf0-48 // j.l.Thread GC crashed on&lt;br/&gt;
0xda9d7cc0:	0x00000031	0x00000000	0x0016db90	0x00000000&lt;br/&gt;
0xda9d7cd0:	0x00000000	0x00000000	0x0000002b	0x00000000&lt;br/&gt;
0xda9d7ce0:	0x00000000	0x00000000	0x00000000	0x00000000&lt;br/&gt;
0xda9d7cf0:	0xba38e290	0x00000000	0x00000000	0xda9d7d38&lt;br/&gt;
0xda9d7d00:	0xdaa08e48	0x00000000	0xda9d7d70	0x00000000&lt;br/&gt;
0xda9d7d10:	0x00000000	&amp;gt;0xe0221218	0xda823a10	0x00000000&lt;br/&gt;
0xda9d7d20:	0x00000000	0x00000000	0x00000000	0x00000000&lt;br/&gt;
0xda9d7d30:	0x00000000	0x00000000&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Looking at 0xe0221218 and surroundings:&lt;br/&gt;
&lt;br/&gt;
(gdb) x/80x 0xe0221218-32*8&lt;br/&gt;
0xe0221118:	0x00000055	0x00000001	0x00000042	0x0000004e&lt;br/&gt;
0xe0221128:	0x00000046	0x00000055	0x0000000d	0x00000001&lt;br/&gt;
0xe0221138:	0x0000000f	0x0000000f	0x0000000f	0x00000000&lt;br/&gt;
0xe0221148:	&amp;gt;0x00000001&amp;lt;	0x00000000	0x00161170	0x00000040  // seems to be an object start&lt;br/&gt;
0xe0221158:	0x00000000	0x00000000	0x40e00000	0x00000000&lt;br/&gt;
0xe0221168:	0x41500000	0x00000000	0x41880000	0x00000000&lt;br/&gt;
0xe0221178:	0x41b00000	0x00000000	0x41f80000	0x00000000&lt;br/&gt;
0xe0221188:	0x42080000	0x00000000	0x42140000	0x00000000&lt;br/&gt;
0xe0221198:	0x422c0000	0x00000000	0x42400000	0x00000000&lt;br/&gt;
0xe02211a8:	0x42580000	0x00000000	0x427c0000	0x00000000&lt;br/&gt;
0xe02211b8:	0x42840000	0x00000000	0x42900000	0x00000000&lt;br/&gt;
0xe02211c8:	0x429c0000	0x00000000	0x42a20000	0x00000000&lt;br/&gt;
0xe02211d8:	0x42ae0000	0x00000000	0x42b60000	0x00000000&lt;br/&gt;
0xe02211e8:	0x42bc0000	0x00000000	0x42c60000	0x00000000&lt;br/&gt;
0xe02211f8:	0x42cc0000	0x00000000	0x42d20000	0x00000000&lt;br/&gt;
0xe0221208:	0x42d80000	0x00000000	0x42e20000	0x00000000&lt;br/&gt;
0xe0221218:	&amp;gt;0x42f40000&amp;lt;	0x00000000	0x42fe0000	0x00000000   // the broken pointer pointing here&lt;br/&gt;
&lt;br/&gt;
So the `scopedValueBindings` seems to point into the middle of some object, probably just garbage; it is interesting that all the addresses in that array increase by exactly 12kb (= 3 * 4kb).</comment>
                            <comment id="14683748" author="tschatzl" created="Fri, 21 Jun 2024 10:14:17 -0700"  >&amp;gt; &amp;gt; All Java objects on the Java heap directly accessed by native code must be registered with the GC&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;The code here *using* FFM, does not do anything like that.&lt;br/&gt;
&lt;br/&gt;
Did not look that way to me either when inspecting the code.&lt;br/&gt;
&lt;br/&gt;
May best _guess_, given the crashes (bad reference in handle area and the crash upcalling to Java and a crash accessing the Font2D object) may or may not indicate an issue with the scoped values because they also contain one of those and most likely they are implemented using these per-thread handles (or not). I need to get more information on their actual implementation.&lt;br/&gt;
&lt;br/&gt;
The additional tests I did that increased the GC frequency by simply causing GCs in the upcalls did not increase the crash frequency either.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;It can&amp;#39;t because FFM doesn&amp;#39;t provide any way to do it.&lt;br/&gt;
&amp;gt;That&amp;#39;s why scoped values, or bound vars in method handles need to be used when doing upcalls.&lt;br/&gt;
&amp;gt;You can see the native code in src/java.desktop/share/native/libfontmanager/HBShaper.c&lt;br/&gt;
&amp;gt;Not a Java object reference in sight.&lt;br/&gt;
&amp;gt;Now the &amp;#39;upcall stubs&amp;#39; generated by Panama in HBShaper.java which are a MemorySegment&lt;br/&gt;
&amp;gt;there are somehow mapped to the native C function pointers that you&amp;#39;ll see in HBShaper.c&lt;br/&gt;
&amp;gt;and then when called, somehow know which Java method to call but this is a basic part&lt;br/&gt;
&amp;gt;of the Panana functionality so I would be surprised if there&amp;#39;s a problem there. &lt;br/&gt;
&lt;br/&gt;
Afaiu for every such upcall a C-&amp;gt;Java stub (which reorders arguments, saves registers, ...) is generated, and you get a pointer to that one. Then the C code can simply call it as normal (and probably there is a similar stub called when returning from Java).&lt;br/&gt;
&lt;br/&gt;
That is all I understand so far, I do not know either right now where the bad references come from (also because I could not reproduce the issue with verification yet).&lt;br/&gt;
&lt;br/&gt;
&amp;gt; &amp;gt; Do you have a CR for this &amp;quot;other test&amp;quot; available?&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;I was referring to the (2nd level) linked bug&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8320253&quot;&gt;https://bugs.openjdk.org/browse/JDK-8320253&lt;/a&gt;&lt;br/&gt;
&amp;gt;G1: SIGSEGV in G1ParScanThreadState::trim_queue_to_threshold&lt;br/&gt;
&lt;br/&gt;
As mentioned above, garbage collectors tend to show these issues frequently because of any broken reference for any reason, not necessarily (and nowadays actually most of the time) not because of G1 (or any garbage collector) changes. It happens, but is a minority of cases.&lt;br/&gt;
&lt;br/&gt;
A crash in G1ParScanThreadState::trim_queue_to_threshold() or the methods with the same purpose (following the object graph) for the other collectors means nothing other than there is a bad reference somewhere in the object graph.&lt;br/&gt;
&lt;br/&gt;
We advise people to run with verification (-XX:VerifyBefore/AfterGC) first before reporting these issues on the GC component. Depending on when it crashes (before or after the gc pauses) one can fairly easily limit whether the cause is gc or not. Unfortunately verification is expensive, so timing changes a lot, and it might just make the problem disappear (like in this case).&lt;br/&gt;
&lt;br/&gt;
&amp;gt;The test is unrelated to any of this client code or FFM and was submitted a week or so earlier.&lt;br/&gt;
&amp;gt;The timing made me suppose something had changed in G1 to trigger this.&lt;br/&gt;
&lt;br/&gt;
No. Afaics that particular crash at the same location happened because of a machine with defect memory as commented in the CR. Some references were garbage after some bitflips, and the collector came across them first.&lt;br/&gt;
</comment>
                            <comment id="14683462" author="prr" created="Thu, 20 Jun 2024 12:38:07 -0700"  >&lt;br/&gt;
&amp;gt; All Java objects on the Java heap directly accessed by native code must be registered with the GC&lt;br/&gt;
&lt;br/&gt;
The code here *using* FFM, does not do anything like that.&lt;br/&gt;
It can&amp;#39;t because FFM doesn&amp;#39;t provide any way to do it.&lt;br/&gt;
That&amp;#39;s why scoped values, or bound vars in method handles need to be used when doing upcalls.&lt;br/&gt;
You can see the native code in src/java.desktop/share/native/libfontmanager/HBShaper.c&lt;br/&gt;
Not a Java object reference in sight.&lt;br/&gt;
Now the &amp;#39;upcall stubs&amp;#39; generated by Panama in HBShaper.java which are a MemorySegment&lt;br/&gt;
there are somehow mapped to the native C function pointers that you&amp;#39;ll see in HBShaper.c&lt;br/&gt;
and then when called, somehow know which Java method to call but this is a basic part&lt;br/&gt;
of the Panana functionality so I would be surprised if there&amp;#39;s a problem there.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Do you have a CR for this &amp;quot;other test&amp;quot; available?&lt;br/&gt;
&lt;br/&gt;
I was referring to the (2nd level) linked bug&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8320253&quot;&gt;https://bugs.openjdk.org/browse/JDK-8320253&lt;/a&gt;&lt;br/&gt;
G1: SIGSEGV in G1ParScanThreadState::trim_queue_to_threshold&lt;br/&gt;
&lt;br/&gt;
The test is unrelated to any of this client code or FFM and was submitted a week or so earlier.&lt;br/&gt;
The timing made me suppose something had changed in G1 to trigger this.</comment>
                            <comment id="14682751" author="tschatzl" created="Tue, 18 Jun 2024 17:39:56 -0700"  >This seems to be an issue with FFM: with -Dsun.font.layout.ffm=false the test does not fail after 45k iterations; the same configuration with FFM enabled fails three times in 15k iterations.</comment>
                            <comment id="14682623" author="tschatzl" created="Tue, 18 Jun 2024 06:45:26 -0700"  >Thanks [~prr] for this background. This helps a lot.&lt;br/&gt;
&lt;br/&gt;
Some initial comments:&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I can imagine that if GC has relocated some Java object because it&lt;br/&gt;
&amp;gt; has no knowledge that some code using FFM has a direct reference to the&lt;br/&gt;
&amp;gt; storage for the object, that bad things will happen, but I&amp;#39;m not sure where&lt;br/&gt;
&amp;gt; to look for the problem. &lt;br/&gt;
&lt;br/&gt;
All Java objects on the Java heap directly accessed by native code must be registered with the GC (`CollectedHeap::pin_object()` called on it) and later unregistered (`CollectedHeap::unpin_object()`) to let the GC know about that it needs to be careful here.&lt;br/&gt;
&lt;br/&gt;
[...]&lt;br/&gt;
&lt;br/&gt;
&amp;gt; The crashes involving this test whilst few date from shortly after that was&lt;br/&gt;
&amp;gt; integrated - although I also note that the earliest crash in this related group&lt;br/&gt;
&amp;gt; is for another test and pre-dates this code being integrated.&lt;br/&gt;
&lt;br/&gt;
Do you have a CR for this &amp;quot;other test&amp;quot; available? This points to something else being responsible for the crashes, which I would like to investigate.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; But I don&amp;#39;t see how this client (as in client of FFM) code has anything&lt;br/&gt;
&amp;gt;directly to do with the VM oops and GCs.&lt;br/&gt;
&lt;br/&gt;
Not directly, but if native code corrupts java object metadata or references (by using an outdated reference to a java object), the GC is typically the component of the VM that will come across these corrupted objects. It performs actions on every reference of &amp;quot;every&amp;quot; live object, so if there is a broken one, it will typically crash (which is actually better than the other option, silent corruption or passing on garbage to callers allocating memory).&lt;br/&gt;
&lt;br/&gt;
G1ParScanThreadState::trim_queue_to_threshold() is one central method in the G1 collector that reads metadata of live objects and follows references.&lt;br/&gt;
&lt;br/&gt;
I did start tests to check whether FFM could be causing this just in case using the -Dsun.font.layout.ffm=false option.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;Generally this code makes a downcall, which can make multiple upcalls&lt;br/&gt;
&amp;gt;from the downcall, including one to store the results, but once the downcall is done,&lt;br/&gt;
&amp;gt;here&amp;#39;s no FFM-related &amp;#39;state&amp;#39; that&amp;#39;s kept.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;gt;I will throw in that this code also used Scoped Values because FFM has no support&lt;br/&gt;
&amp;gt;for Java objects. These are set up before the downcall and used in the upcalls.&lt;br/&gt;
&lt;br/&gt;
If these scoped values are not used by native code they should be fine.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;But most of the backtraces show crashes after use of these is already finished. &lt;br/&gt;
&lt;br/&gt;
As above, the native code might overwrite some unrelated data with that outdated reference, causing random other data overwrites until the application or GC comes across them.</comment>
                            <comment id="14682184" author="prr" created="Mon, 17 Jun 2024 12:32:04 -0700"  >&lt;br/&gt;
I can imagine that if GC has relocated some Java object because it&lt;br/&gt;
has no knowledge that some code using FFM has a direct reference to the&lt;br/&gt;
storage for the object, that bad things will happen, but I&amp;#39;m not sure where&lt;br/&gt;
to look for the problem.&lt;br/&gt;
&lt;br/&gt;
The test itself is 5 years old but there have been recent changes in the code under test.&lt;br/&gt;
&lt;br/&gt;
(1) The 3rd party native library was upgraded.&lt;br/&gt;
Date:   Tue Oct 31 19:01:15 2023 +0000&lt;br/&gt;
8313643: Update HarfBuzz to 8.2.2&lt;br/&gt;
&lt;br/&gt;
(2) We started to use FFM/Panama to access it.&lt;br/&gt;
Date:   Tue Nov 21 17:46:29 2023 +0000&lt;br/&gt;
8318364: Add an FFM-based implementation of harfbuzz OpenType layout&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m inclined to guess it is related to (2), not (1).&lt;br/&gt;
&lt;br/&gt;
The crashes involving this test whilst few date from shortly after that was integrated - although I also note that the earliest crash in this related group is for another test&lt;br/&gt;
and pre-dates this code being integrated.&lt;br/&gt;
But I don&amp;#39;t see how this client (as in client of FFM) code has anything directly to do with the VM oops and GCs.&lt;br/&gt;
Generally this code makes a downcall, which can make multiple upcalls&lt;br/&gt;
from the downcall, including one to store the results, but once the downcall is done,&lt;br/&gt;
here&amp;#39;s no FFM-related &amp;#39;state&amp;#39; that&amp;#39;s kept.&lt;br/&gt;
I will throw in that this code also used Scoped Values because FFM has no support&lt;br/&gt;
for Java objects. These are set up before the downcall and used in the upcalls.&lt;br/&gt;
But most of the backtraces show crashes after use of these is already finished.&lt;br/&gt;
</comment>
                            <comment id="14682089" author="tschatzl" created="Mon, 17 Jun 2024 06:14:52 -0700"  >&lt;br/&gt;
---------------  T H R E A D  ---------------&lt;br/&gt;
&lt;br/&gt;
Current thread (0x0000ffff28272c50):  JavaThread &amp;quot;Thread-127&amp;quot;        [_thread_in_Java, id=2584393, stack(0x0000fffe57a24000,0x0000fffe57c22000) (2040K)]&lt;br/&gt;
&lt;br/&gt;
Stack: [0x0000fffe57a24000,0x0000fffe57c22000],  sp=0x0000fffe57c1f720,  free space=2029k&lt;br/&gt;
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
J 1618 c2 java.lang.invoke.LambdaForm$MH+0x00000f80010b9000.invoke(Ljava/lang/Object;JJIJ)I &lt;a href=&apos;mailto:java.base@24-internal&apos;&gt;java.base@24-internal&lt;/a&gt; (46 bytes) @ 0x0000ffff703876f0 [0x0000ffff70387640+0x00000000000000b0]&lt;br/&gt;
J 1607 c2 java.lang.invoke.LambdaForm$MH+0x00000f8001096400.invoke(Ljava/lang/Object;JJIJ)I &lt;a href=&apos;mailto:java.base@24-internal&apos;&gt;java.base@24-internal&lt;/a&gt; (50 bytes) @ 0x0000ffff7038c8a0 [0x0000ffff7038c800+0x00000000000000a0]&lt;br/&gt;
v  blob 0x0000ffff6feafac8&lt;br/&gt;
C  [libfontmanager.so+0x4e040]  hb_font_get_glyph_h_advances_default(hb_font_t*, void*, unsigned int, unsigned int const*, unsigned int, int*, unsigned int, void*)+0x70  (hb-font.hh:308)&lt;br/&gt;
C  [libfontmanager.so+0xe06d4]  _hb_ot_shape+0x15a0  (hb-font.hh:326)&lt;br/&gt;
C  [libfontmanager.so+0x1151c4]  hb_shape_plan_execute+0x84  (hb-shaper-list.hh:47)&lt;br/&gt;
C  [libfontmanager.so+0x1156cc]  hb_shape_full+0x78  (hb-shape.cc:148)&lt;br/&gt;
C  [libfontmanager.so+0x8f20]  jdk_hb_shape+0x1a0  (HBShaper_Panama.c:130)&lt;br/&gt;
v  ~RuntimeStub::nep_invoker_blob 0x0000ffff6feb1df8&lt;br/&gt;
J 1732 c1 jdk.internal.foreign.abi.DowncallStub+0x00000f800108bc00.invoke(Ljava/lang/foreign/SegmentAllocator;Ljava/lang/foreign/MemorySegment;FLjava/lang/foreign/MemorySegment;Ljava/lang/foreign/MemorySegment;Ljava/lang/foreign/MemorySegment;IIIIIFFIILjava/lang/foreign/MemorySegment;Ljava/lang/foreign/MemorySegment;)V &lt;a href=&apos;mailto:java.base@24-internal&apos;&gt;java.base@24-internal&lt;/a&gt; (514 bytes) @ 0x0000ffff68a29344 [0x0000ffff68a28c00+0x0000000000000744]&lt;br/&gt;
J 1848 c2 sun.font.HBShaper.shape(Lsun/font/Font2D;Lsun/font/FontStrike;F[FLjava/lang/foreign/MemorySegment;[CLsun/font/GlyphLayout$GVData;IIIILjava/awt/geom/Point2D$Float;II)V &lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt; (52 bytes) @ 0x0000ffff703a3264 [0x0000ffff703a2980+0x00000000000008e4]&lt;br/&gt;
J 1820 c2 sun.font.GlyphLayout$EngineRecord.layout()V &lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt; (108 bytes) @ 0x0000ffff703a9728 [0x0000ffff703a9180+0x00000000000005a8]&lt;br/&gt;
J 1641 c1 sun.font.GlyphLayout.layout(Ljava/awt/Font;Ljava/awt/font/FontRenderContext;[CIIILsun/font/StandardGlyphVector;)Lsun/font/StandardGlyphVector; &lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt; (683 bytes) @ 0x0000ffff689fe878 [0x0000ffff689fcd40+0x0000000000001b38]&lt;br/&gt;
J 1625 c1 java.awt.Font.layoutGlyphVector(Ljava/awt/font/FontRenderContext;[CIII)Ljava/awt/font/GlyphVector; &lt;a href=&apos;mailto:java.desktop@24-internal&apos;&gt;java.desktop@24-internal&lt;/a&gt; (32 bytes) @ 0x0000ffff68a1e9b8 [0x0000ffff68a1e8c0+0x00000000000000f8]&lt;br/&gt;
J 1715 c1 FontLayoutStressTest.doLayout()D (31 bytes) @ 0x0000ffff68a2bc54 [0x0000ffff68a2bbc0+0x0000000000000094]&lt;br/&gt;
J 1908% c1 FontLayoutStressTest.lambda$main$0(Ljava/util/concurrent/CyclicBarrier;DLjava/util/concurrent/atomic/AtomicReference;)V (60 bytes) @ 0x0000ffff68a41de0 [0x0000ffff68a41cc0+0x0000000000000120]&lt;br/&gt;
j  FontLayoutStressTest$$Lambda+0x00000f80010018d0.run()V+12&lt;br/&gt;
j  java.lang.Thread.runWith(Ljava/lang/Object;Ljava/lang/Runnable;)V+5 &lt;a href=&apos;mailto:java.base@24-internal&apos;&gt;java.base@24-internal&lt;/a&gt;&lt;br/&gt;
j  java.lang.Thread.run()V+19 &lt;a href=&apos;mailto:java.base@24-internal&apos;&gt;java.base@24-internal&lt;/a&gt;&lt;br/&gt;
v  ~StubRoutines::call_stub 0x0000ffff6fd6e114&lt;br/&gt;
V  [libjvm.so+0x7e3db8]  JavaCalls::call_helper(JavaValue*, methodHandle const&amp;amp;, JavaCallArguments*, JavaThread*)+0x218  (javaCalls.cpp:415)&lt;br/&gt;
V  [libjvm.so+0x7e5344]  JavaCalls::call_virtual(JavaValue*, Handle, Klass*, Symbol*, Symbol*, JavaThread*)+0x184  (javaCalls.cpp:329)&lt;br/&gt;
V  [libjvm.so+0x8ace7c]  thread_entry(JavaThread*, JavaThread*)+0x8c  (jvm.cpp:2937)&lt;br/&gt;
V  [libjvm.so+0x7fb7b4]  JavaThread::thread_main_inner() [clone .part.0]+0xa0  (javaThread.cpp:759)&lt;br/&gt;
V  [libjvm.so+0xcfa848]  Thread::call_run()+0xa8  (thread.cpp:225)&lt;br/&gt;
V  [libjvm.so+0xb7f340]  thread_native_entry(Thread*)+0xdc  (os_linux.cpp:849)&lt;br/&gt;
C  [libpthread.so.0+0x7950]  start_thread+0x190&lt;br/&gt;
&lt;br/&gt;
siginfo: si_signo: 11 (SIGSEGV), si_code: 2 (SEGV_ACCERR), si_addr: 0x00000000f8facbe0&lt;br/&gt;
&lt;br/&gt;
Crash in panama related code&lt;br/&gt;
&lt;br/&gt;
0x00000000f8facbe0 is an address in unallocated java heap.</comment>
                            <comment id="14682084" author="tschatzl" created="Mon, 17 Jun 2024 06:12:37 -0700"  >Another interesting failure: Oop handle area contains references to stale objects? Someone holding oops across GCs?&lt;br/&gt;
&lt;br/&gt;
Current thread (0x0000ffff54007d20):  WorkerThread &amp;quot;GC Thread#1&amp;quot;    [id=2390714, stack(0x0000fffef3606000,0x0000fffef3804000) (2040K)]&lt;br/&gt;
&lt;br/&gt;
Stack: [0x0000fffef3606000,0x0000fffef3804000],  sp=0x0000fffef38023e0,  free space=2032k&lt;br/&gt;
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
V  [libjvm.so+0x70ad84]  G1ParScanThreadState::trim_queue_to_threshold(unsigned int)+0x2164  (klass.hpp:295)&lt;br/&gt;
V  [libjvm.so+0x728da0]  G1ParCopyClosure&amp;lt;(G1Barrier)0, false&amp;gt;::do_oop(oopDesc**)+0x90  (g1ParScanThreadState.inline.hpp:53)&lt;br/&gt;
V  [libjvm.so+0x77eef8]  HandleArea::oops_do(OopClosure*)+0x48  (handles.cpp:109)&lt;br/&gt;
V  [libjvm.so+0x8004e4]  JavaThread::oops_do_no_frames(OopClosure*, NMethodClosure*)+0x24  (javaThread.cpp:1379)&lt;br/&gt;
V  [libjvm.so+0xcfa344]  Thread::oops_do(OopClosure*, NMethodClosure*)+0xa4  (thread.cpp:439)&lt;br/&gt;
V  [libjvm.so+0xd06370]  Threads::possibly_parallel_oops_do(bool, OopClosure*, NMethodClosure*)+0x10c  (threads.cpp:1154)&lt;br/&gt;
V  [libjvm.so+0x72b7b0]  G1RootProcessor::process_java_roots(G1RootClosures*, G1GCPhaseTimes*, unsigned int)+0x80  (g1RootProcessor.cpp:180)&lt;br/&gt;
V  [libjvm.so+0x72b8b4]  G1RootProcessor::evacuate_roots(G1ParScanThreadState*, unsigned int)+0x64  (g1RootProcessor.cpp:61)&lt;br/&gt;
V  [libjvm.so+0x73d704]  G1EvacuateRegionsTask::scan_roots(G1ParScanThreadState*, unsigned int)+0x24  (g1YoungCollector.cpp:664)&lt;br/&gt;
V  [libjvm.so+0x73d904]  G1EvacuateRegionsBaseTask::work(unsigned int)+0x84  (g1YoungCollector.cpp:651)&lt;br/&gt;
V  [libjvm.so+0xda60f8]  WorkerThread::run()+0x98  (workerThread.cpp:70)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14682071" author="tschatzl" created="Mon, 17 Jun 2024 05:35:36 -0700"  >Crashes do not seem to be limited to linux-aarch64.</comment>
                            <comment id="14681493" author="stefank" created="Thu, 13 Jun 2024 11:56:29 -0700"  >Resetting the bug to give GC triage a chance to give this the proper GC triage treatment.</comment>
                            <comment id="14681464" author="prr" created="Thu, 13 Jun 2024 10:22:43 -0700"  >Crash in the same place&lt;br/&gt;
# V  [libjvm.so+0x708044]  G1ParScanThreadState::trim_queue_to_threshold(unsigned int)+0x2164&lt;br/&gt;
&lt;br/&gt;
Odds now are  on a GC bug. Will reassign.</comment>
                            <comment id="14678592" author="dholmes" created="Mon, 3 Jun 2024 23:48:33 -0700"  >Here is another variation:&lt;br/&gt;
&lt;br/&gt;
#&lt;br/&gt;
# A fatal error has been detected by the Java Runtime Environment:&lt;br/&gt;
#&lt;br/&gt;
#  SIGSEGV (0xb) at pc=0x0000ffff89b089f0, pid=2690501, tid=2690590&lt;br/&gt;
#&lt;br/&gt;
# JRE version: Java(TM) SE Runtime Environment (23.0+26) (build 23-ea+26-2183)&lt;br/&gt;
# Java VM: Java HotSpot(TM) 64-Bit Server VM (23-ea+26-2183, mixed mode, sharing, tiered, compressed oops, compressed class ptrs, g1 gc, linux-aarch64)&lt;br/&gt;
# Problematic frame:&lt;br/&gt;
# V  [libjvm.so+0x7089f0]  G1ParScanThreadState::trim_queue_to_threshold(unsigned int)+0x3b70&lt;br/&gt;
&lt;br/&gt;
---------------  T H R E A D  ---------------&lt;br/&gt;
&lt;br/&gt;
Current thread (0x0000ffff48008860):  WorkerThread &amp;quot;GC Thread#2&amp;quot;    [id=2690590, stack(0x0000ffff34519000,0x0000ffff34717000) (2040K)]&lt;br/&gt;
&lt;br/&gt;
Stack: [0x0000ffff34519000,0x0000ffff34717000],  sp=0x0000ffff34715520,  free space=2033k&lt;br/&gt;
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
V  [libjvm.so+0x7089f0]  G1ParScanThreadState::trim_queue_to_threshold(unsigned int)+0x3b70  (oop.inline.hpp:196)&lt;br/&gt;
V  [libjvm.so+0x70acf0]  G1ParScanThreadState::steal_and_trim_queue(GenericTaskQueueSet&amp;lt;OverflowTaskQueue&amp;lt;ScannerTask, (MEMFLAGS)5, 131072u&amp;gt;, (MEMFLAGS)5&amp;gt;*)+0x310  (g1ParScanThreadState.inline.hpp:60)&lt;br/&gt;
V  [libjvm.so+0x73b984]  G1ParEvacuateFollowersClosure::do_void()+0x94  (g1YoungCollector.cpp:577)&lt;br/&gt;
V  [libjvm.so+0x73bf64]  G1EvacuateRegionsTask::evacuate_live_objects(G1ParScanThreadState*, unsigned int)+0x74  (g1YoungCollector.cpp:602)&lt;br/&gt;
V  [libjvm.so+0x739b7c]  G1EvacuateRegionsBaseTask::work(unsigned int)+0x9c  (g1YoungCollector.cpp:652)&lt;br/&gt;
V  [libjvm.so+0xd9b6f8]  WorkerThread::run()+0x98  (workerThread.cpp:70)&lt;br/&gt;
V  [libjvm.so+0xcf51c8]  Thread::call_run()+0xa8  (thread.cpp:225)&lt;br/&gt;
V  [libjvm.so+0xb79b40]  thread_native_entry(Thread*)+0xdc  (os_linux.cpp:846)&lt;br/&gt;
C  [libpthread.so.0+0x7950]  start_thread+0x190&lt;br/&gt;
&lt;br/&gt;
This all suggests a memory stomp to me.</comment>
                            <comment id="14675454" author="prr" created="Wed, 22 May 2024 12:37:55 -0700"  >Seen once more on OL 8, AARCH64. The trace this time is different but we still look to be in VM code.&lt;br/&gt;
But the runnable in which it occurs does use FFM and ScopedValues, which are new enough both in themselves that there might be a small problem there somewhere.&lt;br/&gt;
&lt;br/&gt;
It looks like the VM is trying to generate  ClassCastException but I don&amp;#39;t see what in the Java code being executed might cause this.&lt;br/&gt;
&lt;br/&gt;
#&lt;br/&gt;
# A fatal error has been detected by the Java Runtime Environment:&lt;br/&gt;
#&lt;br/&gt;
#  SIGSEGV (0xb) at pc=0x0000ffffbbff5128, pid=1211942, tid=1212009&lt;br/&gt;
#&lt;br/&gt;
# JRE version: Java(TM) SE Runtime Environment (23.0+23) (build 23-ea+23-1918)&lt;br/&gt;
# Java VM: Java HotSpot(TM) 64-Bit Server VM (23-ea+23-1918, mixed mode, sharing, tiered, compressed oops, compressed class ptrs, g1 gc, linux-aarch64)&lt;br/&gt;
# Problematic frame:&lt;br/&gt;
# V  [libjvm.so+0xcb6128]  Symbol::as_klass_external_name() const+0x18&lt;br/&gt;
#&lt;br/&gt;
....&lt;br/&gt;
...&lt;br/&gt;
--------------  T H R E A D  ---------------&lt;br/&gt;
&lt;br/&gt;
Current thread (0x0000ffff4c1dfee0):  JavaThread &amp;quot;Thread-9&amp;quot;         [_thread_in_vm, id=1212009, stack(0x0000ffff33a04000,0x0000ffff33c02000) (2040K)]&lt;br/&gt;
&lt;br/&gt;
Stack: [0x0000ffff33a04000,0x0000ffff33c02000],  sp=0x0000ffff33bff290,  free space=2028k&lt;br/&gt;
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
V  [libjvm.so+0xcb6128]  Symbol::as_klass_external_name() const+0x18  (symbol.hpp:139)&lt;br/&gt;
V  [libjvm.so+0xc2ea0c]  SharedRuntime::generate_class_cast_message(Klass*, Klass*, Symbol*)+0x2c  (sharedRuntime.cpp:1843)&lt;br/&gt;
V  [libjvm.so+0xc31210]  SharedRuntime::generate_class_cast_message(JavaThread*, Klass*)+0xd0  (sharedRuntime.cpp:1835)&lt;br/&gt;
V  [libjvm.so+0x4a8204]  Runtime1::throw_class_cast_exception(JavaThread*, oopDesc*)+0x70  (c1_Runtime1.cpp:735)&lt;br/&gt;
v  ~RuntimeStub::throw_class_cast_exception Runtime1 stub 0x0000ffffa3f35834&lt;br/&gt;
J 1586 c1 java.lang.ScopedValue.scopedValueBindings()Ljava/lang/ScopedValue$Snapshot; &lt;a href=&apos;mailto:java.base@23-ea&apos;&gt;java.base@23-ea&lt;/a&gt; (65 bytes) @ 0x0000ffff9cad5bdc [0x0000ffff9cad5a00+0x00000000000001dc]&lt;br/&gt;
j  java.lang.ScopedValue$Carrier.run(Ljava/lang/Runnable;)V+12 &lt;a href=&apos;mailto:java.base@23-ea&apos;&gt;java.base@23-ea&lt;/a&gt;&lt;br/&gt;
j  sun.font.HBShaper.shape(Lsun/font/Font2D;Lsun/font/FontStrike;F[FLjava/lang/foreign/MemorySegment;[CLsun/font/GlyphLayout$GVData;IIIILjava/awt/geom/Point2D$Float;II)V+48 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  sun.font.SunLayoutEngine.layout(Lsun/font/FontStrikeDesc;[FFIILsun/font/TextRecord;ILjava/awt/geom/Point2D$Float;Lsun/font/GlyphLayout$GVData;)V+75 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  sun.font.GlyphLayout$EngineRecord.layout()V+102 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
J 1713 c1 sun.font.GlyphLayout.layout(Ljava/awt/Font;Ljava/awt/font/FontRenderContext;[CIIILsun/font/StandardGlyphVector;)Lsun/font/StandardGlyphVector; &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt; (683 bytes) @ 0x0000ffff9cadaa08 [0x0000ffff9cad8ec0+0x0000000000001b48]&lt;br/&gt;
j  java.awt.Font.layoutGlyphVector(Ljava/awt/font/FontRenderContext;[CIII)Ljava/awt/font/GlyphVector;+19 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  FontLayoutStressTest.doLayout()D+15&lt;br/&gt;
j  FontLayoutStressTest.lambda$main$0(Ljava/util/concurrent/CyclicBarrier;DLjava/util/concurrent/atomic/AtomicReference;)V+23&lt;br/&gt;
j  FontLayoutStressTest$$Lambda+0x00007f80010018d0.run()V+12&lt;br/&gt;
j  java.lang.Thread.runWith(Ljava/lang/Object;Ljava/lang/Runnable;)V+5 &lt;a href=&apos;mailto:java.base@23-ea&apos;&gt;java.base@23-ea&lt;/a&gt;&lt;br/&gt;
j  java.lang.Thread.run()V+19 &lt;a href=&apos;mailto:java.base@23-ea&apos;&gt;java.base@23-ea&lt;/a&gt;&lt;br/&gt;
v  ~StubRoutines::call_stub 0x0000ffffa3e1e114&lt;br/&gt;
V  [libjvm.so+0x7e0dd8]  JavaCalls::call_helper(JavaValue*, methodHandle const&amp;amp;, JavaCallArguments*, JavaThread*)+0x218  (javaCalls.cpp:415)&lt;br/&gt;
V  [libjvm.so+0x7e2364]  JavaCalls::call_virtual(JavaValue*, Handle, Klass*, Symbol*, Symbol*, JavaThread*)+0x184  (javaCalls.cpp:329)&lt;br/&gt;
V  [libjvm.so+0x8a9f5c]  thread_entry(JavaThread*, JavaThread*)+0x8c  (jvm.cpp:2937)&lt;br/&gt;
V  [libjvm.so+0x7f8874]  JavaThread::thread_main_inner() [clone .part.0]+0xa0  (javaThread.cpp:759)&lt;br/&gt;
V  [libjvm.so+0xcf4ac8]  Thread::call_run()+0xa8  (thread.cpp:225)&lt;br/&gt;
V  [libjvm.so+0xb78520]  thread_native_entry(Thread*)+0xdc  (os_linux.cpp:846)&lt;br/&gt;
C  [libpthread.so.0+0x7950]  start_thread+0x190&lt;br/&gt;
Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)&lt;br/&gt;
v  ~RuntimeStub::throw_class_cast_exception Runtime1 stub 0x0000ffffa3f35834&lt;br/&gt;
J 1586 c1 java.lang.ScopedValue.scopedValueBindings()Ljava/lang/ScopedValue$Snapshot; &lt;a href=&apos;mailto:java.base@23-ea&apos;&gt;java.base@23-ea&lt;/a&gt; (65 bytes) @ 0x0000ffff9cad5bdc [0x0000ffff9cad5a00+0x00000000000001dc]&lt;br/&gt;
j  java.lang.ScopedValue$Carrier.run(Ljava/lang/Runnable;)V+12 &lt;a href=&apos;mailto:java.base@23-ea&apos;&gt;java.base@23-ea&lt;/a&gt;&lt;br/&gt;
j  sun.font.HBShaper.shape(Lsun/font/Font2D;Lsun/font/FontStrike;F[FLjava/lang/foreign/MemorySegment;[CLsun/font/GlyphLayout$GVData;IIIILjava/awt/geom/Point2D$Float;II)V+48 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  sun.font.SunLayoutEngine.layout(Lsun/font/FontStrikeDesc;[FFIILsun/font/TextRecord;ILjava/awt/geom/Point2D$Float;Lsun/font/GlyphLayout$GVData;)V+75 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  sun.font.GlyphLayout$EngineRecord.layout()V+102 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
J 1713 c1 sun.font.GlyphLayout.layout(Ljava/awt/Font;Ljava/awt/font/FontRenderContext;[CIIILsun/font/StandardGlyphVector;)Lsun/font/StandardGlyphVector; &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt; (683 bytes) @ 0x0000ffff9cadaa08 [0x0000ffff9cad8ec0+0x0000000000001b48]&lt;br/&gt;
j  java.awt.Font.layoutGlyphVector(Ljava/awt/font/FontRenderContext;[CIII)Ljava/awt/font/GlyphVector;+19 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  FontLayoutStressTest.doLayout()D+15&lt;br/&gt;
j  FontLayoutStressTest.lambda$main$0(Ljava/util/concurrent/CyclicBarrier;DLjava/util/concurrent/atomic/AtomicReference;)V+23&lt;br/&gt;
j  FontLayoutStressTest$$Lambda+0x00007f80010018d0.run()V+12&lt;br/&gt;
j  java.lang.Thread.runWith(Ljava/lang/Object;Ljava/lang/Runnable;)V+5 &lt;a href=&apos;mailto:java.base@23-ea&apos;&gt;java.base@23-ea&lt;/a&gt;&lt;br/&gt;
j  java.lang.Thread.run()V+19 &lt;a href=&apos;mailto:java.base@23-ea&apos;&gt;java.base@23-ea&lt;/a&gt;&lt;br/&gt;
v  ~StubRoutines::call_stub 0x0000ffffa3e1e114&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;</comment>
                            <comment id="14671209" author="vdyakov" created="Mon, 6 May 2024 11:20:08 -0700"  >Ok, this is an indication of JDK 23 regression, so keeping this targeted to fix in 23</comment>
                            <comment id="14671203" author="JIRAUSER19814" created="Mon, 6 May 2024 10:54:04 -0700"  >[~vdyakov] &lt;br/&gt;
Does it affect JDK 22? 21? 17? &lt;br/&gt;
&lt;br/&gt;
The test failure on CI-jdk23 is new. This test failed in the past but for other issues not the same as the recent issue observed on CI-jdk23. </comment>
                            <comment id="14671197" author="prr" created="Mon, 6 May 2024 10:27:20 -0700"  >This is very odd. The whole call stack is Java code, and we&amp;#39;ve not changed anything in this area in some time. This could be a hotspot bug.&lt;br/&gt;
---------------  T H R E A D  --------------- &lt;br/&gt;
&lt;br/&gt;
Current thread (0x0000ffff1022a810):  JavaThread &amp;quot;Thread-4&amp;quot;         [_thread_in_Java, id=1499236, stack(0x0000ffff0f805000,0x0000ffff0fa03000) (2040K)]&lt;br/&gt;
&lt;br/&gt;
Stack: [0x0000ffff0f805000,0x0000ffff0fa03000],  sp=0x0000ffff0fa00cb0,  free space=2031k&lt;br/&gt;
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
j  java.awt.Font.getFont2D()Lsun/font/Font2D;+0 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  java.awt.Font$FontAccessImpl.getFont2D(Ljava/awt/Font;)Lsun/font/Font2D;+1 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  sun.font.FontUtilities.getFont2D(Ljava/awt/Font;)Lsun/font/Font2D;+4 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  sun.font.StandardGlyphVector.initFontData()V+5 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  sun.font.StandardGlyphVector.initGlyphVector(Ljava/awt/Font;Ljava/awt/font/FontRenderContext;[I[F[II)V+39 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  sun.font.StandardGlyphVector.&amp;lt;init&amp;gt;(Ljava/awt/Font;Ljava/awt/font/FontRenderContext;[I[F[II)V+14 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  sun.font.GlyphLayout$GVData.createGlyphVector(Ljava/awt/Font;Ljava/awt/font/FontRenderContext;Lsun/font/StandardGlyphVector;)Lsun/font/StandardGlyphVector;+274 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  sun.font.GlyphLayout.layout(Ljava/awt/Font;Ljava/awt/font/FontRenderContext;[CIIILsun/font/StandardGlyphVector;)Lsun/font/StandardGlyphVector;+675 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  java.awt.Font.layoutGlyphVector(Ljava/awt/font/FontRenderContext;[CIII)Ljava/awt/font/GlyphVector;+19 &lt;a href=&apos;mailto:java.desktop@23-ea&apos;&gt;java.desktop@23-ea&lt;/a&gt;&lt;br/&gt;
j  FontLayoutStressTest.doLayout()D+15&lt;br/&gt;
j  FontLayoutStressTest.lambda$main$0(Ljava/util/concurrent/CyclicBarrier;DLjava/util/concurrent/atomic/AtomicReference;)V+23&lt;br/&gt;
j  FontLayoutStressTest$$Lambda+0x000003fe010018d0.run()V+12&lt;br/&gt;
j  java.lang.Thread.runWith(Ljava/lang/Object;Ljava/lang/Runnable;)V+5 &lt;a href=&apos;mailto:java.base@23-ea&apos;&gt;java.base@23-ea&lt;/a&gt;&lt;br/&gt;
j  java.lang.Thread.run()V+19 &lt;a href=&apos;mailto:java.base@23-ea&apos;&gt;java.base@23-ea&lt;/a&gt;&lt;br/&gt;
v  ~StubRoutines::call_stub 0x0000ffff67e4f114&lt;br/&gt;
V  [libjvm.so+0x7e0618]  JavaCalls::call_helper(JavaValue*, methodHandle const&amp;amp;, JavaCallArguments*, JavaThread*)+0x218  (javaCalls.cpp:415)&lt;br/&gt;
V  [libjvm.so+0x7e1ba4]  JavaCalls::call_virtual(JavaValue*, Handle, Klass*, Symbol*, Symbol*, JavaThread*)+0x184  (javaCalls.cpp:329)&lt;br/&gt;
V  [libjvm.so+0x8a988c]  thread_entry(JavaThread*, JavaThread*)+0x8c  (jvm.cpp:2937)&lt;br/&gt;
V  [libjvm.so+0x7f80b4]  JavaThread::thread_main_inner() [clone .part.0]+0xa0  (javaThread.cpp:761)&lt;br/&gt;
V  [libjvm.so+0xcf4b18]  Thread::call_run()+0xa8  (thread.cpp:221)&lt;br/&gt;
V  [libjvm.so+0xb78290]  thread_native_entry(Thread*)+0xdc  (os_linux.cpp:846)&lt;br/&gt;
C  [libpthread.so.0+0x7950]  start_thread+0x190&lt;br/&gt;
&lt;br/&gt;
siginfo: si_signo: 11 (SIGSEGV), si_code: 1 (SEGV_MAPERR), si_addr: 0x0000000001052d98&lt;br/&gt;
</comment>
                            <comment id="14671192" author="vdyakov" created="Mon, 6 May 2024 10:15:09 -0700"  >Does it affect JDK 22? 21? 17?</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5151700">JDK-8350948</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5155225">JDK-8354038</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5155970">JDK-8354711</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5155981">JDK-8354722</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10000">
                    <name>Blocks</name>
                                            <outwardlinks description="blocks">
                                                        </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10600">
                    <name>Causes</name>
                                                                <inwardlinks description="caused by">
                                        <issuelink>
            <issuekey id="5052510">JDK-8269240</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10002">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="5116163">JDK-8321379</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5133510">JDK-8335733</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5142474">JDK-8343065</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5112670">JDK-8318364</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5135870">JDK-8337753</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="110193" name="8331735-reproducer-platform-thread.tar.gz" size="4764" author="jpai" created="Tue, 23 Jul 2024 02:59:07 -0700"/>
                            <attachment id="110186" name="8331735-reproducer-virtual-thread.tar.gz" size="5083" author="jpai" created="Tue, 23 Jul 2024 02:21:53 -0700"/>
                            <attachment id="110206" name="TestUpcallStress.java" size="3774" author="mcimadamore" created="Wed, 24 Jul 2024 02:25:34 -0700"/>
                            <attachment id="109878" name="hs_err_crash.log" size="137974" author="tschatzl" created="Wed, 26 Jun 2024 02:51:28 -0700"/>
                            <attachment id="111732" name="hs_err_pid1856780.log" size="128834" author="jpai" created="Mon, 28 Oct 2024 00:40:27 -0700"/>
                            <attachment id="109839" name="x64-linux-gdb-stacktrace.out" size="115887" author="tschatzl" created="Mon, 24 Jun 2024 04:54:12 -0700"/>
                            <attachment id="109838" name="x64-linux-jhsdb.out" size="71198" author="tschatzl" created="Mon, 24 Jun 2024 04:52:44 -0700"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i368e3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17357"><![CDATA[b26]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="2492"><![CDATA[java.lang.foreign]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10100" key="com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons">
                        <customfieldname>Verification</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17000"><![CDATA[Verified]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>