<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Sat Sep 27 08:52:23 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8240343] JDI stopListening/stoplis001 &quot;FAILED: listening is successfully stopped without starting listening&quot;</title>
                <link>https://bugs.openjdk.org/browse/JDK-8240343</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>The following test failed in the JDK15 CI:&lt;br/&gt;
&lt;br/&gt;
vmTestbase/nsk/jdi/ListeningConnector/stopListening/stoplis001/TestDescription.java&lt;br/&gt;
&lt;br/&gt;
Here&amp;#39;s a snippet from the log file:&lt;br/&gt;
&lt;br/&gt;
----------System.out:(86/5530)----------&lt;br/&gt;
run [nsk.jdi.ListeningConnector.stopListening.stoplis001, -verbose, -arch=linux-x64, -waittime=5, -debugee.vmkind=java, -transport.address=dynamic, -debugee.vmkeys=-XX:MaxRAMPercentage=6 -Xshare:off -showversion]&lt;br/&gt;
Connector name=com.sun.jdi.SocketListen&lt;br/&gt;
	description=Accepts socket connections initiated by other VMs&lt;br/&gt;
	transport=dt_socket&lt;br/&gt;
	argument name=timeout&lt;br/&gt;
		value=&lt;br/&gt;
	argument name=port&lt;br/&gt;
		value=44321&lt;br/&gt;
	argument name=localAddress&lt;br/&gt;
		value=&lt;br/&gt;
Connector name=com.sun.jdi.SocketListen&lt;br/&gt;
	description=Accepts socket connections initiated by other VMs&lt;br/&gt;
	transport=dt_socket&lt;br/&gt;
	argument name=timeout&lt;br/&gt;
		value=&lt;br/&gt;
	argument name=port&lt;br/&gt;
		value=&lt;br/&gt;
	argument name=localAddress&lt;br/&gt;
		value=&lt;br/&gt;
TEST: start listening the address localhost:44321&lt;br/&gt;
# ERROR: Test case #1 FAILED: listening is successfully stopped without starting listening&lt;br/&gt;
The following stacktrace is for failure analysis.&lt;br/&gt;
nsk.share.TestFailure: Test case #1 FAILED: listening is successfully stopped without starting listening&lt;br/&gt;
	at nsk.share.Log.logExceptionForFailureAnalysis(Log.java:428)&lt;br/&gt;
	at nsk.share.Log.complain(Log.java:399)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.runIt(stoplis001.java:102)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.run(stoplis001.java:72)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.main(stoplis001.java:68)&lt;br/&gt;
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)&lt;br/&gt;
	at PropertyResolvingWrapper.main(PropertyResolvingWrapper.java:104)&lt;br/&gt;
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)&lt;br/&gt;
	at com.sun.javatest.regtest.agent.MainWrapper$MainThread.run(MainWrapper.java:127)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:832)&lt;br/&gt;
# ERROR: FAILURE: Illegal connector arguments: Not listening&lt;br/&gt;
The following stacktrace is for failure analysis.&lt;br/&gt;
nsk.share.TestFailure: FAILURE: Illegal connector arguments: Not listening&lt;br/&gt;
	at nsk.share.Log.logExceptionForFailureAnalysis(Log.java:428)&lt;br/&gt;
	at nsk.share.Log.complain(Log.java:399)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.stopListen(stoplis001.java:185)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.runIt(stoplis001.java:108)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.run(stoplis001.java:72)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.main(stoplis001.java:68)&lt;br/&gt;
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)&lt;br/&gt;
	at PropertyResolvingWrapper.main(PropertyResolvingWrapper.java:104)&lt;br/&gt;
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)&lt;br/&gt;
	at com.sun.javatest.regtest.agent.MainWrapper$MainThread.run(MainWrapper.java:127)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:832)&lt;br/&gt;
com.sun.jdi.connect.IllegalConnectorArgumentsException: Not listening&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.GenericListeningConnector.stopListening(GenericListeningConnector.java:136)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.stopListen(stoplis001.java:169)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.runIt(stoplis001.java:108)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.run(stoplis001.java:72)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.main(stoplis001.java:68)&lt;br/&gt;
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)&lt;br/&gt;
	at PropertyResolvingWrapper.main(PropertyResolvingWrapper.java:104)&lt;br/&gt;
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)&lt;br/&gt;
	at com.sun.javatest.regtest.agent.MainWrapper$MainThread.run(MainWrapper.java:127)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:832)&lt;br/&gt;
# ERROR: Test case #2 FAILED: unable to stop listening&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
#&amp;gt;  &lt;br/&gt;
#&amp;gt;  SUMMARY: Following errors occured&lt;br/&gt;
#&amp;gt;      during test execution:&lt;br/&gt;
#&amp;gt;  &lt;br/&gt;
# ERROR: Test case #1 FAILED: listening is successfully stopped without starting listening&lt;br/&gt;
# ERROR: FAILURE: Illegal connector arguments: Not listening&lt;br/&gt;
# ERROR: Test case #2 FAILED: unable to stop listening&lt;br/&gt;
----------System.err:(3/172)----------</description>
                <environment></environment>
        <key id="5012474">JDK-8240343</key>
            <summary>JDI stopListening/stoplis001 &quot;FAILED: listening is successfully stopped without starting listening&quot;</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://bugs.openjdk.org/images/jbsImages/p4.png">P4</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="amenkov">Alex Menkov</assignee>
                                    <reporter username="dcubed">Daniel Daugherty</reporter>
                        <labels>
                            <label>intermittent</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>noreg-self</label>
                            <label>tier5</label>
                            <label>tier7</label>
                    </labels>
                <created>Mon, 2 Mar 2020 19:20:09 -0800</created>
                <updated>Mon, 11 Nov 2024 01:07:44 -0800</updated>
                            <resolved>Fri, 12 Apr 2024 15:31:47 -0700</resolved>
                                    <version>11</version>
                    <version>15</version>
                    <version>19</version>
                    <version>21</version>
                    <version>23</version>
                                    <fixVersion>23</fixVersion>
                                    <component>core-svc</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>8</watches>
                                                                                                                <comments>
                            <comment id="14720058" author="roboduke" created="Thu, 7 Nov 2024 05:58:36 -0800"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/1139&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/1139&lt;/a&gt;&lt;br/&gt;
Date: 2024-11-07 13:49:44 +0000</comment>
                            <comment id="14720055" author="roboduke" created="Thu, 7 Nov 2024 05:56:43 -0800"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/3035&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/3035&lt;/a&gt;&lt;br/&gt;
Date: 2024-11-07 13:50:41 +0000</comment>
                            <comment id="14720053" author="goetz" created="Thu, 7 Nov 2024 05:51:31 -0800"  >Fix request [17u,21u]&lt;br/&gt;
&lt;br/&gt;
I backport this for parity with 17.0.13-oracle,21.0.5-oracle.&lt;br/&gt;
No risk, only a test change&lt;br/&gt;
Clean backport.&lt;br/&gt;
Test passes. SAP nightly testing passed.</comment>
                            <comment id="14700402" author="roboduke" created="Fri, 23 Aug 2024 21:05:41 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/2822&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/2822&lt;/a&gt;&lt;br/&gt;
Date: 2024-08-24 04:00:39 +0000</comment>
                            <comment id="14700400" author="roboduke" created="Fri, 23 Aug 2024 20:39:21 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/944&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/944&lt;/a&gt;&lt;br/&gt;
Date: 2024-08-24 03:34:15 +0000</comment>
                            <comment id="14665014" author="dukebot" created="Fri, 12 Apr 2024 15:31:45 -0700"  >Changeset: 28b20195&lt;br/&gt;
Author:    Alex Menkov &amp;lt;&lt;a href=&apos;mailto:amenkov@openjdk.org&apos;&gt;amenkov@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2024-04-12 22:29:34 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/28b201955907e145f208d756b607ab545a83b2d3&quot;&gt;https://git.openjdk.org/jdk/commit/28b201955907e145f208d756b607ab545a83b2d3&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14664204" author="roboduke" created="Tue, 9 Apr 2024 17:31:29 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/18705&quot;&gt;https://git.openjdk.org/jdk/pull/18705&lt;/a&gt;&lt;br/&gt;
Date: 2024-04-10 00:28:01 +0000</comment>
                            <comment id="14663764" author="amenkov" created="Mon, 8 Apr 2024 19:20:31 -0700"  >Looked at the test more closely.&lt;br/&gt;
The idea is to start listening and call stopListening() with wrong argument map (exception is expected) and with the map passed to startListening().&lt;br/&gt;
Call argHandler.getTransportPort() after startListening() should resolve the issue.&lt;br/&gt;
We don&amp;#39;t need to retry as cArgs1 just needs to have a port different from cArgs2.&lt;br/&gt;
&lt;br/&gt;
TestDescription contains a note:&lt;br/&gt;
&amp;nbsp;*     NOTE: this test is tagged &amp;quot;nonconcurrent&amp;quot; because it uses the default&lt;br/&gt;
&amp;nbsp;*     &amp;quot;javadebug&amp;quot; shmem file, as do some other tests.&lt;br/&gt;
&lt;br/&gt;
But actually the test does not use shmem connector, it always uses SocketConnector, so &amp;quot;exclusiveAccess.dirs=.&amp;quot; is not needed.&lt;br/&gt;
</comment>
                            <comment id="14662321" author="jpai" created="Tue, 2 Apr 2024 21:13:11 -0700"  >Hello Chris,&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Also, I see this test has exclusiveAccess.dirs set, so it shouldn&amp;#39;t be necessary to do retries due to a port being in use. &lt;br/&gt;
&lt;br/&gt;
Based on what the exclusiveAccess.dirs configuration of jtreg states &lt;a href=&quot;https://openjdk.org/jtreg/tag-spec.html:&quot;&gt;https://openjdk.org/jtreg/tag-spec.html:&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
&amp;gt; A harness that supports concurrent test execution should ensure that all tests in the specified directories are run when no other tests in the same directory is being run.&lt;br/&gt;
&lt;br/&gt;
So it just ensures that tests within the same directory (the one configured as a value of that property) are run sequentially. It doesn&amp;#39;t guarantee that other tests won&amp;#39;t be running when the tests in this directory are in progress. So I think there&amp;#39;s still a chance that the port returned by &amp;quot;findFreePort()&amp;quot; might end up being used by the time the test uses it to do a bind. So the retries may be necessary (could be done as a separate JBS task).&lt;br/&gt;
&lt;br/&gt;
While at it - looking at the TEST.properties in test/hotspot/jtreg/vmTestbase/nsk/jdi/ListeningConnector/stopListening/stoplis001/TEST.properties, it has:&lt;br/&gt;
&lt;br/&gt;
exclusiveAccess.dirs=.&lt;br/&gt;
&lt;br/&gt;
but then looking at the number of tests in that test/hotspot/jtreg/vmTestbase/nsk/jdi/ListeningConnector/stopListening/stoplis001/ directory, there&amp;#39;s just one:&lt;br/&gt;
&lt;br/&gt;
&amp;gt; ls test/hotspot/jtreg/vmTestbase/nsk/jdi/ListeningConnector/stopListening/stoplis001/&lt;br/&gt;
&amp;gt; TEST.properties		TestDescription.java&lt;br/&gt;
&lt;br/&gt;
So the use of exclusiveAccess.dirs=. appears to be of no use here, unless it&amp;#39;s been done this way to future proof any new test files being added in that directory?&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14662237" author="cjplummer" created="Tue, 2 Apr 2024 13:04:12 -0700"  >Ok. That makes sense. I added:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;log.display(&amp;quot;cArgs1: &amp;quot; + cArgs1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;log.display(&amp;quot;cArgs2: &amp;quot; + cArgs2);&lt;br/&gt;
&lt;br/&gt;
And in a passing test run I see:&lt;br/&gt;
&lt;br/&gt;
TEST: start listening the address localhost:42473&lt;br/&gt;
cArgs1: {timeout=timeout=, port=port=45521, localAddress=localAddress=}&lt;br/&gt;
cArgs2: {timeout=timeout=, port=port=42473, localAddress=localAddress=}&lt;br/&gt;
&lt;br/&gt;
So I think we just need to fix the ordering as Jai suggested. Also, I see this test has exclusiveAccess.dirs set, so it shouldn&amp;#39;t be necessary to do retries due to a port being in use.</comment>
                            <comment id="14662232" author="amenkov" created="Tue, 2 Apr 2024 12:14:53 -0700"  >&amp;gt; If you call startListening() with an argument map that does not specify a port, then stopListening() needs to be called with an argument map that includes the port that was actually used listen on, not with the same argument map used to start listening (which specifies no port). &lt;br/&gt;
&lt;br/&gt;
AFAIR if startListening is called with &amp;quot;0&amp;quot; port, the arguments map is updated so &amp;quot;port&amp;quot; argument contains actual listening port.&lt;br/&gt;
So stopListening using the same argument map work as expected.&lt;br/&gt;
</comment>
                            <comment id="14662175" author="cjplummer" created="Tue, 2 Apr 2024 09:08:53 -0700"  >I think I understand now. So the rule with using findFreePort() is that you must actually put the port to use before using ServerSocket(0) again to get a 2nd port. This test is breaking that rule. It calls findFreePort(), then ServerSocket(0), and then uses the port returned by findFreePort().&lt;br/&gt;
&lt;br/&gt;
&amp;gt; That&amp;#39;s why a lot of places where such &amp;quot;find free port&amp;quot; test utility code is used, there&amp;#39;s also retries within the test - where the test after noticing a bind exception when trying to bind to a &amp;quot;free&amp;quot; port will retry the entire task of a finding a free port afresh and then attempting to bind to it. &lt;br/&gt;
&lt;br/&gt;
Doesn&amp;#39;t seem that we are doing that here. Maybe we should. That would also fix the port usage ordering issue in the test.&lt;br/&gt;
&lt;br/&gt;
I still think we have a spec clarification issue here. If you call startListening() with an argument map that does not specify a port, then stopListening() needs to be called with an argument map that includes the port that was actually used listen on, not with the same argument map used to start listening (which specifies no port).</comment>
                            <comment id="14662119" author="jpai" created="Tue, 2 Apr 2024 07:27:16 -0700"  >&amp;gt; What might work is doing the startListen(cArgs2) before calling argHandler.getTransportPort() for cArgs1.&lt;br/&gt;
&lt;br/&gt;
The diff I pasted above isn&amp;#39;t easily readable, but that&amp;#39;s exactly what that change does :) &lt;br/&gt;
&lt;br/&gt;
&amp;gt; I don&amp;#39;t understand why startListen(cArgs2) can end up with a port already allocated by argHandler.getTransportPort(), but not vice versa. &lt;br/&gt;
&lt;br/&gt;
(please ignore the following explanation if you already knew how it works and I just misunderstood your question)&lt;br/&gt;
&lt;br/&gt;
The goal of argHandler.getTransportPort() implementation is to find a port that is not in use and then pass that port along to the test/caller, so that the caller can bind to it. Finding a free port isn&amp;#39;t straightforward. Various places in our tests we use utility code like the one that&amp;#39;s in argHandler.getTransportPort(), which essentially comes down to:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private String findFreePort() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ServerSocket ss = null;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ss = new ServerSocket(0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return String.valueOf(ss.getLocalPort());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return null;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} finally {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ss.close();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (Throwable t) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// ignore&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
The trick here is to use the java.net.ServerSocket (standard) API and pass it port 0, so that the underlying operating system (which accepts port 0) treats it as an ephemeral port and will allocate a free port and bind the ServerSocket instance to it. Once that call to ServerSocket constructor returns, it&amp;#39;s now bound to a (non-zero) port (which was previously unused). The test utility then keeps track of that allocated port. That&amp;#39;s part one of the &amp;quot;find free port&amp;quot; trick. The next part of that trick is to immediately close that ServerSocket instance (as you notice in the code above) so that the (allocated) port is no longer bound to. The test utility then passes along this port to the caller and the caller is expected to &amp;quot;immediately&amp;quot; use it to bind to that port. &lt;br/&gt;
&lt;br/&gt;
The expectation is that within this duration of closing the ServerSocket instance and the test subsequently using that port to do a bind to that (previously allocated but now free) port, the underlying OS won&amp;#39;t allocate this port to some other process that either wants to explicitly bind to this specific port or asked for an ephemeral port. Of course, this expectation can&amp;#39;t always be satisfied - nothing prevents the OS to allocate that (now free) port to some other process. That&amp;#39;s why a lot of places where such &amp;quot;find free port&amp;quot; test utility code is used, there&amp;#39;s also retries within the test - where the test after noticing a bind exception when trying to bind to a &amp;quot;free&amp;quot; port will retry the entire task of a finding a free port afresh and then attempting to bind to it.&lt;br/&gt;
&lt;br/&gt;
So that&amp;#39;s how the (application layer) &amp;quot;findFreePort()&amp;quot; logic works, which the argHandler.getTransportPort() invokes. The important thing to remember here is that this application layer logic of finding a free port is inherently faulty - i.e. by the time you would use a port that was returned as a free port by this utility, that port might have been allocated to and in use by some other process (or by the current process in some other code path).&lt;br/&gt;
&lt;br/&gt;
Now, in this test, when the startListen(cArgs2) gets called, with no specific port specified, it internally ends up instantiating a ServerSocket with a InetSocketAddress with port = 0, which as noted previously implies ephemeral port. This then implies that the code will hand over the responsibility of finding a free port to the underlying OS, which for sure won&amp;#39;t allocate a currently in use port. Plus after the call to startListen(cArgs2) returns, the port continues to be in use (since we haven&amp;#39;t stopped listening or closed the listener). If we use the proposed patch of moving that call to argHandler.getTransportPort() after the startListen(cArgs2), then the application layer &amp;quot;findFreePort()&amp;quot; logic is guaranteed not to return this currently in-use port as a free port and thus should avoid the issue noticed in this test failure.&lt;br/&gt;
&lt;br/&gt;
Having said all this, I will run this proposed change and verify that there isn&amp;#39;t any obvious unaccounted issue with the proposed change.</comment>
                            <comment id="14661902" author="cjplummer" created="Mon, 1 Apr 2024 19:55:01 -0700"  >I&amp;#39;m not certain, but I don&amp;#39;t think the port is allocated until startListen(cArgs2) is called. I don&amp;#39;t see anything in initConnector() that looks like port allocation. What might work is doing the startListen(cArgs2) before calling argHandler.getTransportPort() for cArgs1. However, I&amp;#39;m not even convinced this will work because I don&amp;#39;t understand why startListen(cArgs2) can end up with a port already allocated by argHandler.getTransportPort(), but not vice versa.</comment>
                            <comment id="14661858" author="jpai" created="Mon, 1 Apr 2024 18:45:15 -0700"  >Hello Chris, since the startListen(cArgs2) ends up using a ephemeral port for binding and (like you rightly say) it can end up picking the free port that cArgs1 has identified for its own use, would changing the order of free port identification help in this test? Something like:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;diff --git a/test/hotspot/jtreg/vmTestbase/nsk/jdi/ListeningConnector/stopListening/stoplis001.java b/test/hotspot/jtreg/vmTestbase/nsk/jdi/ListeningConnector/stopListening/stoplis001.java&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;index 9fa40e17d5a..1f6da45d265 100644&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;--- a/test/hotspot/jtreg/vmTestbase/nsk/jdi/ListeningConnector/stopListening/stoplis001.java&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+++ b/test/hotspot/jtreg/vmTestbase/nsk/jdi/ListeningConnector/stopListening/stoplis001.java&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@@ -86,7 +86,6 @@ private int runIt(String argv[], PrintStream out) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.out = out;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;log = new Log(out, argHandler);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-        Map&amp;lt;String,? extends com.sun.jdi.connect.Connector.Argument&amp;gt; cArgs1 = initConnector(argHandler.getTransportPort());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Map&amp;lt;String,? extends com.sun.jdi.connect.Connector.Argument&amp;gt; cArgs2 = initConnector(null);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ((addr = startListen(cArgs2)) == null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;log.complain(&amp;quot;FAILURE: unable to start listening the address &amp;quot; +&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@@ -96,6 +95,10 @@ private int runIt(String argv[], PrintStream out) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;log.display(&amp;quot;TEST: start listening the address &amp;quot; + addr);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+        // init another connector which finds a free port and sets the &amp;quot;port&amp;quot; argument with the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+        // new port value&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+        Map&amp;lt;String,? extends com.sun.jdi.connect.Connector.Argument&amp;gt; cArgs1 = initConnector(argHandler.getTransportPort());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/* Check that an Exception is thrown if ListeningConnector.stopListening&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;has been invoked with argument map different from the one given for&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;a previous ListeningConnector.startListening() invocation */&lt;br/&gt;
&lt;br/&gt;
(I haven&amp;#39;t run any tests, not even local, with this proposed change)&lt;br/&gt;
&lt;br/&gt;
With this reordering, cArgs1 won&amp;#39;t consider as a free port any port that cArgs2 would have started listening on. Would this reordering, change any expectations of the test itself and thus make such a change incorrect?&lt;br/&gt;
</comment>
                            <comment id="14661820" author="cjplummer" created="Mon, 1 Apr 2024 14:38:43 -0700"  >The test does the following:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Map&amp;lt;String,? extends com.sun.jdi.connect.Connector.Argument&amp;gt; cArgs1 = initConnector(argHandler.getTransportPort());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Map&amp;lt;String,? extends com.sun.jdi.connect.Connector.Argument&amp;gt; cArgs2 = initConnector(null);&lt;br/&gt;
&lt;br/&gt;
argHandler.getTransportPort() calls findFreePort(), which returns the port that is allocated by ServerSocket(0). I&amp;#39;m not so sure this provides any guarantee that the port allocated when listening with cArgs2 can&amp;#39;t end up being the same as the port in cArgs1 as I think they are using two different approaches to finding a free port.</comment>
                            <comment id="14661808" author="cjplummer" created="Mon, 1 Apr 2024 14:10:06 -0700"  >I think that last log pretty much explains the problem. The test creates two different argument maps, one with 35567 as the port, and a 2nd with no port specified. It listens with the 2nd argument map, which coincidentally ends up allocating port 35567. The test expects that when it stops listening using the first argument map (which explicitly specifies 35567 as the port), that it should fail because the port is wrong. But in this test run just by chance the port is right. Based on the javadoc for stopListening(), it seems this is incorrect behavior:&lt;br/&gt;
&lt;br/&gt;
&amp;quot;Cancels listening for connections. The given argument map should match the argument map given for a previous startListening()&amp;quot;&lt;br/&gt;
&lt;br/&gt;
Since the test explicitly passes an argument map that does not match, the stopListening() call should fail, but doesn&amp;#39;t because the port of the argument map does match the port it actually is listening on.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m starting to think this is really a test bug combined with a poorly written spec. If &amp;quot;null&amp;quot; is used as the port when listening so a port is automatically allocated, how does one stop listening on this port if the stopListening() argument map must match and therefor must contain &amp;quot;null&amp;quot; as the port. Keep in mind that you can start listening on any number of ports using this argument map with a &amp;quot;null&amp;quot; port. You need a way to stop listening on these ports, and you do that by using an argument map with a specific port even though you started listening by using a &amp;quot;null&amp;quot; port.&lt;br/&gt;
</comment>
                            <comment id="14661802" author="dcubed" created="Mon, 1 Apr 2024 13:52:09 -0700"  >For some reason I couldn&amp;#39;t add this last part of the log file snippet at the&lt;br/&gt;
end of the previous comment. So I&amp;#39;ve added it as a separate comment.&lt;br/&gt;
&lt;br/&gt;
# ERROR: FAILURE: Illegal connector arguments: Not listening&lt;br/&gt;
The following stacktrace is for failure analysis.&lt;br/&gt;
nsk.share.TestFailure: FAILURE: Illegal connector arguments: Not listening&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.share.Log.logExceptionForFailureAnalysis(Log.java:431)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.share.Log.complain(Log.java:402)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.jdi.ListeningConnector.stopListening.stoplis001.stopListen(stoplis001.java:188)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.jdi.ListeningConnector.stopListening.stoplis001.runIt(stoplis001.java:111)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.jdi.ListeningConnector.stopListening.stoplis001.run(stoplis001.java:75)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.jdi.ListeningConnector.stopListening.stoplis001.main(stoplis001.java:68)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.reflect.Method.invoke(Method.java:580)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at com.sun.javatest.regtest.agent.MainActionHelper$AgentVMRunnable.run(MainActionHelper.java:333)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.Thread.run(Thread.java:1575)&lt;br/&gt;
com.sun.jdi.connect.IllegalConnectorArgumentsException: Not listening&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at jdk.jdi/com.sun.tools.jdi.GenericListeningConnector.stopListening(GenericListeningConnector.java:136)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.jdi.ListeningConnector.stopListening.stoplis001.stopListen(stoplis001.java:172)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.jdi.ListeningConnector.stopListening.stoplis001.runIt(stoplis001.java:111)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.jdi.ListeningConnector.stopListening.stoplis001.run(stoplis001.java:75)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.jdi.ListeningConnector.stopListening.stoplis001.main(stoplis001.java:68)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.reflect.Method.invoke(Method.java:580)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at com.sun.javatest.regtest.agent.MainActionHelper$AgentVMRunnable.run(MainActionHelper.java:333)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.Thread.run(Thread.java:1575)&lt;br/&gt;
# ERROR: Test case #2 FAILED: unable to stop listening&lt;br/&gt;
----------System.err:(10/562)----------&lt;br/&gt;
java.lang.RuntimeException: TEST FAILED with result 2&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.jdi.ListeningConnector.stopListening.stoplis001.main(stoplis001.java:70)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.reflect.Method.invoke(Method.java:580)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at com.sun.javatest.regtest.agent.MainActionHelper$AgentVMRunnable.run(MainActionHelper.java:333)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.Thread.run(Thread.java:1575)&lt;br/&gt;
&lt;br/&gt;
JavaTest Message: Test threw exception: java.lang.RuntimeException&lt;br/&gt;
JavaTest Message: shutting down test&lt;br/&gt;
&lt;br/&gt;
result: Failed. Execution failed: `main&amp;#39; threw exception: java.lang.RuntimeException: TEST FAILED with result 2</comment>
                            <comment id="14661801" author="dcubed" created="Mon, 1 Apr 2024 13:50:28 -0700"  >Here&amp;#39;s a log file snippet from the jdk-23+17-1321-tier7 sighting:&lt;br/&gt;
&lt;br/&gt;
vmTestbase/nsk/jdi/ListeningConnector/stopListening/stoplis001/TestDescription.java&lt;br/&gt;
&lt;br/&gt;
#section:driver&lt;br/&gt;
----------messages:(7/1050)----------&lt;br/&gt;
command: driver nsk.jdi.ListeningConnector.stopListening.stoplis001 -verbose -arch=linux-x64 -waittime=5 -debugee.vmkind=java -transport.address=dynamic -debugee.vmkeys=&amp;quot;-XX:MaxRAMPercentage=4.16667 -Dtest.boot.jdk=/opt/mach5/mesos/work_dir/jib-master/install/jdk/21/35/bundles/linux-x64/jdk-21_linux-x64_bin.tar.gz/jdk-21 -Djava.io.tmpdir=/opt/mach5/mesos/work_dir/slaves/2e4bfa93-468c-4a99-b47d-767ce7a9c188-S4271/frameworks/1735e8a2-a1db-478c-8104-60c8b0af87dd-0196/executors/9e773269-3278-48d2-a829-ed1e24c1ae46/runs/2bea8b6c-291d-4b40-87b0-668acfdd569b/testoutput/test-support/jtreg_open_test_hotspot_jtreg_vmTestbase_nsk_jdi_quick/tmp -XX:-UseCompressedOops&amp;quot;&lt;br/&gt;
reason: User specified action: run driver nsk.jdi.ListeningConnector.stopListening.stoplis001 -verbose -arch=${os.family}-${os.simpleArch} -waittime=5 -debugee.vmkind=java -transport.address=dynamic -debugee.vmkeys=&amp;quot;${test.vm.opts} ${test.java.opts}&amp;quot; &lt;br/&gt;
started: Mon Apr 01 20:34:36 UTC 2024&lt;br/&gt;
Mode: agentvm&lt;br/&gt;
Agent id: 9&lt;br/&gt;
finished: Mon Apr 01 20:34:36 UTC 2024&lt;br/&gt;
elapsed time (seconds): 0.147&lt;br/&gt;
----------configuration:(15/2067)----------&lt;br/&gt;
&lt;br/&gt;
&amp;lt; snip&amp;gt;&lt;br/&gt;
&lt;br/&gt;
----------System.out:(55/3241)----------&lt;br/&gt;
Connector name=com.sun.jdi.SocketListen&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;description=Accepts socket connections initiated by other VMs&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transport=dt_socket&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;argument name=timeout&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;value=&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;argument name=port&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;value=35567&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;argument name=localAddress&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;value=&lt;br/&gt;
Connector name=com.sun.jdi.SocketListen&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;description=Accepts socket connections initiated by other VMs&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transport=dt_socket&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;argument name=timeout&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;value=&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;argument name=port&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;value=&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;argument name=localAddress&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;value=&lt;br/&gt;
TEST: start listening the address localhost:35567&lt;br/&gt;
# ERROR: Test case #1 FAILED: listening is successfully stopped without starting listening&lt;br/&gt;
The following stacktrace is for failure analysis.&lt;br/&gt;
nsk.share.TestFailure: Test case #1 FAILED: listening is successfully stopped without starting listening&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.share.Log.logExceptionForFailureAnalysis(Log.java:431)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.share.Log.complain(Log.java:402)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.jdi.ListeningConnector.stopListening.stoplis001.runIt(stoplis001.java:105)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.jdi.ListeningConnector.stopListening.stoplis001.run(stoplis001.java:75)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at nsk.jdi.ListeningConnector.stopListening.stoplis001.main(stoplis001.java:68)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(Dire&lt;br/&gt;
ctMethodHandleAccessor.java:103)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.reflect.Method.invoke(Method.java:580)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at com.sun.javatest.regtest.agent.MainActionHelper$AgentVMRunnable.run(MainActionHelper.java:333)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.Thread.run(Thread.java:1575)</comment>
                            <comment id="14649287" author="dcubed" created="Wed, 14 Feb 2024 06:47:27 -0800"  >Here&amp;#39;s a log file snippet from the jdk-23+10-705-tier5 sighting:&lt;br/&gt;
&lt;br/&gt;
vmTestbase/nsk/jdi/ListeningConnector/stopListening/stoplis001/TestDescription.java&lt;br/&gt;
&lt;br/&gt;
#section:main&lt;br/&gt;
----------messages:(6/1112)----------&lt;br/&gt;
command: main nsk.jdi.ListeningConnector.stopListening.stoplis001 -verbose -arch=linux-x64 -waittime=5 -debugee.vmkind=java -transport.address=dynamic -debugee.vmkeys=&amp;quot;-XX:MaxRAMPercentage=4.16667 -Dtest.boot.jdk=/opt/mach5/mesos/work_dir/jib-master/install/jdk/21/35/bundles/linux-x64/jdk-21_linux-x64_bin.tar.gz/jdk-21 -Djava.io.tmpdir=/opt/mach5/mesos/work_dir/slaves/0db9c48f-6638-40d0-9a4b-bd9cc7533eb8-S10263/frameworks/1735e8a2-a1db-478c-8104-60c8b0af87dd-0196/executors/4868bb18-3da0-44a4-b958-3275246a1c56/runs/6f2c8e9e-576d-4edf-93ec-e15746cf29e2/testoutput/test-support/jtreg_open_test_hotspot_jtreg_vmTestbase_nsk_jdi/tmp -Duse.JTREG_TEST_THREAD_FACTORY=Virtual -XX:+UseZGC -XX:-VerifyContinuations&amp;quot;&lt;br/&gt;
reason: User specified action: run main/othervm nsk.jdi.ListeningConnector.stopListening.stoplis001 -verbose -arch=${os.family}-${os.simpleArch} -waittime=5 -debugee.vmkind=java -transport.address=dynamic -debugee.vmkeys=&amp;quot;${test.vm.opts} ${test.java.opts}&amp;quot; &lt;br/&gt;
started: Wed Feb 14 05:21:20 UTC 2024&lt;br/&gt;
Mode: othervm [/othervm specified]&lt;br/&gt;
finished: Wed Feb 14 05:21:21 UTC 2024&lt;br/&gt;
elapsed time (seconds): 0.669&lt;br/&gt;
----------configuration:(0/0)----------&lt;br/&gt;
----------System.out:(64/3517)----------&lt;br/&gt;
Connector name=com.sun.jdi.SocketListen&lt;br/&gt;
	description=Accepts socket connections initiated by other VMs&lt;br/&gt;
	transport=dt_socket&lt;br/&gt;
	argument name=timeout&lt;br/&gt;
		value=&lt;br/&gt;
	argument name=port&lt;br/&gt;
		value=46061&lt;br/&gt;
	argument name=localAddress&lt;br/&gt;
		value=&lt;br/&gt;
Connector name=com.sun.jdi.SocketListen&lt;br/&gt;
	description=Accepts socket connections initiated by other VMs&lt;br/&gt;
	transport=dt_socket&lt;br/&gt;
	argument name=timeout&lt;br/&gt;
		value=&lt;br/&gt;
	argument name=port&lt;br/&gt;
		value=&lt;br/&gt;
	argument name=localAddress&lt;br/&gt;
		value=&lt;br/&gt;
TEST: start listening the address localhost:46061&lt;br/&gt;
# ERROR: Test case #1 FAILED: listening is successfully stopped without starting listening&lt;br/&gt;
The following stacktrace is for failure analysis.&lt;br/&gt;
nsk.share.TestFailure: Test case #1 FAILED: listening is successfully stopped without starting listening&lt;br/&gt;
	at nsk.share.Log.logExceptionForFailureAnalysis(Log.java:431)&lt;br/&gt;
	at nsk.share.Log.complain(Log.java:402)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.runIt(stoplis001.java:102)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.run(stoplis001.java:72)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.main(stoplis001.java:68)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)&lt;br/&gt;
	at com.sun.javatest.regtest.agent.MainWrapper$MainTask.run(MainWrapper.java:138)&lt;br/&gt;
	at java.base/java.lang.VirtualThread.run(VirtualThread.java:329)&lt;br/&gt;
# ERROR: FAILURE: Illegal connector arguments: Not listening&lt;br/&gt;
The following stacktrace is for failure analysis.&lt;br/&gt;
nsk.share.TestFailure: FAILURE: Illegal connector arguments: Not listening&lt;br/&gt;
	at nsk.share.Log.logExceptionForFailureAnalysis(Log.java:431)&lt;br/&gt;
	at nsk.share.Log.complain(Log.java:402)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.stopListen(stoplis001.java:185)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.runIt(stoplis001.java:108)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.run(stoplis001.java:72)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.main(stoplis001.java:68)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)&lt;br/&gt;
	at com.sun.javatest.regtest.agent.MainWrapper$MainTask.run(MainWrapper.java:138)&lt;br/&gt;
	at java.base/java.lang.VirtualThread.run(VirtualThread.java:329)&lt;br/&gt;
com.sun.jdi.connect.IllegalConnectorArgumentsException: Not listening&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.GenericListeningConnector.stopListening(GenericListeningConnector.java:136)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.stopListen(stoplis001.java:169)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.runIt(stoplis001.java:108)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.run(stoplis001.java:72)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.main(stoplis001.java:68)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)&lt;br/&gt;
	at com.sun.javatest.regtest.agent.MainWrapper$MainTask.run(MainWrapper.java:138)&lt;br/&gt;
	at java.base/java.lang.VirtualThread.run(VirtualThread.java:329)&lt;br/&gt;
# ERROR: Test case #2 FAILED: unable to stop listening</comment>
                            <comment id="14611590" author="clanger" created="Fri, 15 Sep 2023 11:30:29 -0700"  >We (SAP) are getting this error intermittently on one of our test runner machines, too.</comment>
                            <comment id="14510807" author="dcubed" created="Tue, 19 Jul 2022 06:52:08 -0700"  >Here&amp;#39;s log file snippets for the jdk-19+32-2211-tier5 sighting: &lt;br/&gt;
&lt;br/&gt;
vmTestbase/nsk/jdi/ListeningConnector/stopListening/stoplis001/TestDescription.java&lt;br/&gt;
&lt;br/&gt;
#section:main&lt;br/&gt;
----------messages:(4/842)----------&lt;br/&gt;
command: main nsk.jdi.ListeningConnector.stopListening.stoplis001 -verbose -arch=linux-x64 -waittime=5 -debugee.vmkind=java -transport.address=dynamic -debugee.vmkeys=&amp;quot;-XX:MaxRAMPercentage=4.16667 -Djava.io.tmpdir=/opt/mach5/mesos/work_dir/slaves/0c72054a-24ab-4dbb-944f-97f9341a1b96-S14316/frameworks/1735e8a2-a1db-478c-8104-60c8b0af87dd-0196/executors/3c22ec9d-61c8-40a8-a4de-aa60592c0936/runs/640c006f-5bce-44f2-9928-fc624ad47887/testoutput/test-support/jtreg_open_test_hotspot_jtreg_vmTestbase_nsk_jdi/tmp -server&amp;quot;&lt;br/&gt;
reason: User specified action: run main/othervm nsk.jdi.ListeningConnector.stopListening.stoplis001 -verbose -arch=${os.family}-${os.simpleArch} -waittime=5 -debugee.vmkind=java -transport.address=dynamic -debugee.vmkeys=&amp;quot;${test.vm.opts} ${test.java.opts}&amp;quot; &lt;br/&gt;
Mode: othervm [/othervm specified]&lt;br/&gt;
elapsed time (seconds): 0.396&lt;br/&gt;
----------configuration:(0/0)----------&lt;br/&gt;
----------System.out:(64/3484)----------&lt;br/&gt;
Connector name=com.sun.jdi.SocketListen&lt;br/&gt;
	description=Accepts socket connections initiated by other VMs&lt;br/&gt;
	transport=dt_socket&lt;br/&gt;
	argument name=timeout&lt;br/&gt;
		value=&lt;br/&gt;
	argument name=port&lt;br/&gt;
		value=32831&lt;br/&gt;
	argument name=localAddress&lt;br/&gt;
		value=&lt;br/&gt;
Connector name=com.sun.jdi.SocketListen&lt;br/&gt;
	description=Accepts socket connections initiated by other VMs&lt;br/&gt;
	transport=dt_socket&lt;br/&gt;
	argument name=timeout&lt;br/&gt;
		value=&lt;br/&gt;
	argument name=port&lt;br/&gt;
		value=&lt;br/&gt;
	argument name=localAddress&lt;br/&gt;
		value=&lt;br/&gt;
TEST: start listening the address localhost:32831&lt;br/&gt;
# ERROR: Test case #1 FAILED: listening is successfully stopped without starting listening&lt;br/&gt;
The following stacktrace is for failure analysis.&lt;br/&gt;
nsk.share.TestFailure: Test case #1 FAILED: listening is successfully stopped without starting listening&lt;br/&gt;
	at nsk.share.Log.logExceptionForFailureAnalysis(Log.java:432)&lt;br/&gt;
	at nsk.share.Log.complain(Log.java:403)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.runIt(stoplis001.java:102)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.run(stoplis001.java:72)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.main(stoplis001.java:68)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)&lt;br/&gt;
	at com.sun.javatest.regtest.agent.MainWrapper$MainThread.run(MainWrapper.java:127)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:1589)&lt;br/&gt;
# ERROR: FAILURE: Illegal connector arguments: Not listening&lt;br/&gt;
The following stacktrace is for failure analysis.&lt;br/&gt;
nsk.share.TestFailure: FAILURE: Illegal connector arguments: Not listening&lt;br/&gt;
	at nsk.share.Log.logExceptionForFailureAnalysis(Log.java:432)&lt;br/&gt;
	at nsk.share.Log.complain(Log.java:403)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.stopListen(stoplis001.java:185)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.runIt(stoplis001.java:108)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.run(stoplis001.java:72)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.main(stoplis001.java:68)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)&lt;br/&gt;
	at com.sun.javatest.regtest.agent.MainWrapper$MainThread.run(MainWrapper.java:127)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:1589)&lt;br/&gt;
com.sun.jdi.connect.IllegalConnectorArgumentsException: Not listening&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.GenericListeningConnector.stopListening(GenericListeningConnector.java:136)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.stopListen(stoplis001.java:169)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.runIt(stoplis001.java:108)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.run(stoplis001.java:72)&lt;br/&gt;
	at nsk.jdi.ListeningConnector.stopListening.stoplis001.main(stoplis001.java:68)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)&lt;br/&gt;
	at com.sun.javatest.regtest.agent.MainWrapper$MainThread.run(MainWrapper.java:127)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:1589)&lt;br/&gt;
# ERROR: Test case #2 FAILED: unable to stop listening&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
#&amp;gt;  &lt;br/&gt;
#&amp;gt;  SUMMARY: Following errors occured&lt;br/&gt;
#&amp;gt;      during test execution:&lt;br/&gt;
#&amp;gt;  &lt;br/&gt;
# ERROR: Test case #1 FAILED: listening is successfully stopped without starting listening&lt;br/&gt;
# ERROR: FAILURE: Illegal connector arguments: Not listening&lt;br/&gt;
# ERROR: Test case #2 FAILED: unable to stop listening&lt;br/&gt;
----------System.err:(0/0)----------&lt;br/&gt;
----------rerun:(32/7961)*----------</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5132594">JDK-8334911</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5133638">JDK-8335848</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5133749">JDK-8335948</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5134228">JDK-8336358</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5143533">JDK-8343912</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5143538">JDK-8343917</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                                                <inwardlinks description="relates to">
                                                        </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10000" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>CPU</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="19000"><![CDATA[x86_64]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10005" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>OS</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17023"><![CDATA[linux]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2mkyb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17414"><![CDATA[b19]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="370"><![CDATA[debugger]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>